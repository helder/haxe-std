{"sourceRoot":"","names":[],"mappings":"QA+BA;QCDA;QCHA;QCFA;QCpBA;;OC4dO;QCtbA;AClCP;;;;;;CAKC,QAAqB,CACpB;YAAU,GACV;aAAM;;CAGP,WAAwC,CACvC;YAAU,aAAa,GACvB;gBAAgB;MAAhB;eACC,YAAY,SAAI,KAAK,GAAG,GAAG;cAE3B;;;MAAI,WAAU,OACb;2BAAM;IAEN;2BAAM,aAAa;;IAErB;KAAI,cAAa,GAChB;0BAAM;IACP;aACA;EAAO,WAAI;;CAGZ,uBAAkE,CACvD;aAAmB,IAA7B;YAAU,0CAAmB,UAC7B;gBAAgB;MAAhB;eACC,YAAY,SAAI,KAAK,KAAK,KAAK;cAE/B;;;MAAI,WAAU,OACb;2BAAM;IAEN;2BAAM,aAAa;;IAErB;KAAI,cAAa,GAChB;0BAAM;IACP;cAAY,UACZ;EAAO;;CAGR,QACC;eAAa;;CAGd,aACC;SAAQ;GAEN,AADI,OACJ;eAAW;;GAIX,AADI,OACJ;gBAAY;;GAFZ,AADI,OACJ;eAAW,AAAK,aAAa,gBAAW;;;;;CAM3C,OACC;EAAO;;CAGR,MACC;EAAO,mBAAO,aAAa","version":3,"file":"FileInput.js.map","sources":["../../../../../../../haxe/versions/4.1.3/std/haxe/io/Input.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/io/Eof.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/NativeStackTrace.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/Fs.hx","../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/buffer/Buffer.hx","../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/sys/io/FileInput.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte():Int {\n\t\t#if cpp\n\t\tthrow \"Not implemented\";\n\t\t#else\n\t\treturn throw \"Not implemented\";\n\t\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile (k > 0) {\n\t\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b, pos, readByte());\n\t\t\t\t#elseif php\n\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof:haxe.io.Eof) {}\n\t\treturn len - k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close():Void {}\n\n\tfunction set_bigEndian(b:Bool):Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll(?bufsize:Int):Bytes {\n\t\tif (bufsize == null)\n\t\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf, 0, len);\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes(s:Bytes, pos:Int, len:Int):Void {\n\t\twhile (len > 0) {\n\t\t\tvar k = readBytes(s, pos, len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read(nbytes:Int):Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile (nbytes > 0) {\n\t\t\tvar k = readBytes(s, p, nbytes);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil(end:Int):String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\twhile ((last = readByte()) != end)\n\t\t\tbuf.addByte(last);\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine():String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile ((last = readByte()) != 10)\n\t\t\t\tbuf.addByte(last);\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.charCodeAt(s.length - 1) == 13)\n\t\t\t\ts = s.substr(0, -1);\n\t\t} catch (e:Eof) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.length == 0)\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat():Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble():Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2, i1) : FPHelper.i64ToDouble(i1, i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8():Int {\n\t\tvar n = readByte();\n\t\tif (n >= 128)\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif (n & 0x8000 != 0)\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif (n & 0x800000 != 0)\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n\t\t#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn (n | 0x80000000);\n\t\telse\n\t\t\treturn n;\n\t\t#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clampInt32(n);\n\t\t#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\t#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString(len:Int, ?encoding:Encoding):String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b, 0, len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tInput.prototype.bigEndian = false;\n\t\t}\n\t#end\n\n\t#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>) {\n\t\treturn (((bytes[1] & 0xF) << 16) | (bytes[2] << 8) | bytes[3]) * 4294967296.\n\t\t\t+ (bytes[4] >> 7) * 2147483648\n\t\t\t+ (((bytes[4] & 0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\n#if eval\n@:keep\n#end\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n**/\nclass Eof {\n\tpublic function new() {}\n\n\t@:ifFeature(\"haxe.io.Eof.*\")\n\tfunction toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node;\r\n\r\nimport haxe.DynamicAccess;\r\nimport haxe.extern.EitherType;\r\nimport js.node.Buffer;\r\nimport js.node.fs.FSWatcher;\r\nimport js.node.fs.ReadStream;\r\nimport js.node.fs.Stats;\r\nimport js.node.fs.WriteStream;\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n/**\r\n\tMost FS functions now support passing `String` and `Buffer`.\r\n\tThis type is used for path arguments and allows passing either of those.\r\n**/\r\ntypedef FsPath = EitherType<String, Buffer>;\r\n\r\n/**\r\n\tPossible options for `Fs.watchFile`.\r\n**/\r\ntypedef FsWatchFileOptions = {\r\n\t/**\r\n\t\tindicates whether the process should continue to run as long as files are being watched\r\n\t\tdefault: true\r\n\t**/\r\n\t@:optional var persistent:Bool;\r\n\r\n\t/**\r\n\t\tindicates how often the target should be polled, in milliseconds\r\n\t\tdefault: 5007\r\n\t**/\r\n\t@:optional var interval:Int;\r\n}\r\n\r\n/**\r\n\tThe `mode` argument used by `Fs.open` and related functions\r\n\tcan be either an integer or a string with octal number.\r\n**/\r\ntypedef FsMode = EitherType<Int, String>;\r\n\r\n/**\r\n\tPossible options for `Fs.writeFile` and `Fs.appendFile`.\r\n**/\r\ntypedef FsWriteFileOptions = {\r\n\t/**\r\n\t\tEncoding for writing strings.\r\n\t\tDefaults to 'utf8'.\r\n\t\tIgnored if data is a buffer\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tdefault = 438 (aka 0666 in Octal)\r\n\t**/\r\n\t@:optional var mode:FsMode;\r\n\r\n\t/**\r\n\t\tdefault: 'w' for `Fs.writeFile`, 'a' for `Fs.appendFile`\r\n\t**/\r\n\t@:optional var flag:FsOpenFlag;\r\n}\r\n\r\n/**\r\n\tDefaults:\r\n\t{ flags: 'r',\r\n\t  encoding: null,\r\n\t  fd: null,\r\n\t  mode: 0666,\r\n\t  autoClose: true\r\n\t}\r\n**/\r\n/**\r\n\tOptions for `Fs.createReadStream`.\r\n**/\r\ntypedef FsCreateReadStreamOptions = {\r\n\t/**\r\n\t\tdefault: 'r'\r\n\t**/\r\n\t@:optional var flags:FsOpenFlag;\r\n\r\n\t/**\r\n\t\tcan be 'utf8', 'ascii', or 'base64'.\r\n\t\tdefault: null\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tdefault: null\r\n\t**/\r\n\t@:optional var fd:Int;\r\n\r\n\t/**\r\n\t\tdefault: 0666\r\n\t**/\r\n\t@:optional var mode:FsMode;\r\n\r\n\t/**\r\n\t\tIf autoClose is false, then the file descriptor won't be closed, even if there's an error.\r\n\t\tIt is your responsiblity to close it and make sure there's no file descriptor leak.\r\n\r\n\t\tIf autoClose is set to true (default behavior), on error or end the file\r\n\t\tdescriptor will be closed automatically.\r\n\t**/\r\n\t@:optional var autoClose:Bool;\r\n\r\n\t/**\r\n\t\tStart of the range of bytes to read\r\n\t**/\r\n\t@:optional var start:Int;\r\n\r\n\t/**\r\n\t\tEnd of the range of bytes to read\r\n\t**/\r\n\t@:optional var end:Int;\r\n};\r\n\r\n/**\r\n\tOptions for `Fs.createWriteStream`.\r\n**/\r\ntypedef FsCreateWriteStreamOptions = {\r\n\t/**\r\n\t\tdefault: 'w'\r\n\t**/\r\n\t@:optional var flags:FsOpenFlag;\r\n\r\n\t/**\r\n\t\tdefault: null\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tdefault: 0666\r\n\t**/\r\n\t@:optional var mode:FsMode;\r\n\r\n\t/**\r\n\t\tposition to write data the beginning of the file.\r\n\t**/\r\n\t@:optional var start:Int;\r\n}\r\n\r\n/**\r\n\tEnumeration of possible symlink types\r\n**/\r\n@:enum abstract SymlinkType(String) from String to String {\r\n\tvar Dir = \"dir\";\r\n\tvar File = \"file\";\r\n\tvar Junction = \"junction\";\r\n}\r\n\r\n/**\r\n\tEnumeration of possible flags for opening file.\r\n\r\n\tThe exclusive flag 'x' (O_EXCL flag in open(2)) ensures that path is newly created.\r\n\tOn POSIX systems, path is considered to exist even if it is a symlink to a non-existent file.\r\n\tThe exclusive flag may or may not work with network file systems.\r\n\r\n\tOn Linux, positional writes don't work when the file is opened in append mode.\r\n\tThe kernel ignores the position argument and always appends the data to the end of the file.\r\n**/\r\n@:enum abstract FsOpenFlag(String) from String to String {\r\n\t/**\r\n\t\tOpen file for reading.\r\n\t\tAn exception occurs if the file does not exist.\r\n\t**/\r\n\tvar Read = \"r\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and writing.\r\n\t\tAn exception occurs if the file does not exist.\r\n\t**/\r\n\tvar ReadWrite = \"r+\";\r\n\r\n\t/**\r\n\t\tOpen file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.\r\n\r\n\t\tThis is primarily useful for opening files on NFS mounts as it allows you to skip the potentially stale local cache.\r\n\t\tIt has a very real impact on I/O performance so don't use this flag unless you need it.\r\n\r\n\t\tNote that this doesn't turn `Fs.open` into a synchronous blocking call.\r\n\t\tIf that's what you want then you should be using `Fs.openSync`\r\n\t**/\r\n\tvar ReadSync = \"rs\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and writing, telling the OS to open it synchronously.\r\n\t\tSee notes for `ReadSync` about using this with caution.\r\n\t**/\r\n\tvar ReadWriteSync = \"rs+\";\r\n\r\n\t/**\r\n\t\tOpen file for writing.\r\n\t\tThe file is created (if it does not exist) or truncated (if it exists).\r\n\t**/\r\n\tvar WriteCreate = \"w\";\r\n\r\n\t/**\r\n\t\tLike `WriteCreate` but fails if path exists.\r\n\t**/\r\n\tvar WriteCheck = \"wx\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and writing.\r\n\t\tThe file is created (if it does not exist) or truncated (if it exists).\r\n\t**/\r\n\tvar WriteReadCreate = \"w+\";\r\n\r\n\t/**\r\n\t\tLike `WriteReadCreate` but fails if path exists.\r\n\t**/\r\n\tvar WriteReadCheck = \"wx+\";\r\n\r\n\t/**\r\n\t\tOpen file for appending.\r\n\t\tThe file is created if it does not exist.\r\n\t**/\r\n\tvar AppendCreate = \"a\";\r\n\r\n\t/**\r\n\t\tLike `AppendCreate` but fails if path exists.\r\n\t**/\r\n\tvar AppendCheck = \"ax\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and appending.\r\n\t\tThe file is created if it does not exist.\r\n\t */\r\n\tvar AppendReadCreate = \"a+\";\r\n\r\n\t/**\r\n\t\tLike `AppendReadCreate` but fails if path exists.\r\n\t**/\r\n\tvar AppendReadCheck = \"ax+\";\r\n}\r\n\r\n/**\r\n\tConstants for use in `Fs` module.\r\n\r\n\tNote: Not every constant will be available on every operating system.\r\n**/\r\ntypedef FsConstants = {\r\n\t/**\r\n\t\tFlag indicating that the file is visible to the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar F_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file can be read by the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar R_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file can be written by the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar W_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file can be executed by the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar X_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open a file for read-only access.\r\n\t**/\r\n\tvar O_RDONLY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open a file for write-only access.\r\n\t**/\r\n\tvar O_WRONLY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open a file for read-write access.\r\n\t**/\r\n\tvar O_RDWR:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to create the file if it does not already exist.\r\n\t**/\r\n\tvar O_CREAT:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists.\r\n\t**/\r\n\tvar O_EXCL:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one).\r\n\t**/\r\n\tvar O_NOCTTY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero.\r\n\t**/\r\n\tvar O_TRUNC:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that data will be appended to the end of the file.\r\n\t**/\r\n\tvar O_APPEND:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the open should fail if the path is not a directory.\r\n\t**/\r\n\tvar O_DIRECTORY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating reading accesses to the file system will no longer result in an update to the atime information associated with the file. This flag is available on Linux operating systems only.\r\n\t**/\r\n\tvar O_NOATIME:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the open should fail if the path is a symbolic link.\r\n\t**/\r\n\tvar O_NOFOLLOW:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file is opened for synchronous I/O.\r\n\t**/\r\n\tvar O_SYNC:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open the symbolic link itself rather than the resource it is pointing to.\r\n\t**/\r\n\tvar O_SYMLINK:Int;\r\n\r\n\t/**\r\n\t\tWhen set, an attempt will be made to minimize caching effects of file I/O.\r\n\t**/\r\n\tvar O_DIRECT:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open the file in nonblocking mode when possible.\r\n\t**/\r\n\tvar O_NONBLOCK:Int;\r\n\r\n\t/**\r\n\t\tBit mask used to extract the file type code.\r\n\t**/\r\n\tvar S_IFMT:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a regular file.\r\n\t**/\r\n\tvar S_IFREG:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a directory.\r\n\t**/\r\n\tvar S_IFDIR:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a character-oriented device file.\r\n\t**/\r\n\tvar S_IFCHR:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a block-oriented device file.\r\n\t**/\r\n\tvar S_IFBLK:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a FIFO/pipe.\r\n\t**/\r\n\tvar S_IFIFO:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a symbolic link.\r\n\t**/\r\n\tvar S_IFLNK:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a socket.\r\n\t**/\r\n\tvar S_IFSOCK:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable, writable and executable by owner.\r\n\t**/\r\n\tvar S_IRWXU:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable by owner.\r\n\t**/\r\n\tvar S_IRUSR:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating writable by owner.\r\n\t**/\r\n\tvar S_IWUSR:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating executable by owner.\r\n\t**/\r\n\tvar S_IXUSR:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable, writable and executable by group.\r\n\t**/\r\n\tvar S_IRWXG:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable by group.\r\n\t**/\r\n\tvar S_IRGRP:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating writable by group.\r\n\t**/\r\n\tvar S_IWGRP:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating executable by group.\r\n\t**/\r\n\tvar S_IXGRP:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable, writable and executable by others.\r\n\t**/\r\n\tvar S_IRWXO:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable by others.\r\n\t**/\r\n\tvar S_IROTH:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating writable by others.\r\n\t**/\r\n\tvar S_IWOTH:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating executable by others.\r\n\t**/\r\n\tvar S_IXOTH:Int;\r\n}\r\n\r\n/**\r\n\tFile I/O is provided by simple wrappers around standard POSIX functions.\r\n\tAll the methods have asynchronous and synchronous forms.\r\n\r\n\tThe asynchronous form always take a completion callback as its last argument.\r\n\tThe arguments passed to the completion callback depend on the method,\r\n\tbut the first argument is always reserved for an exception.\r\n\r\n\tIf the operation was completed successfully, then the first argument will be null.\r\n\r\n\tWhen using the synchronous form any exceptions are immediately thrown.\r\n\tYou can use try/catch to handle exceptions or allow them to bubble up.\r\n**/\r\n@:jsRequire(\"fs\")\r\nextern class Fs {\r\n\t/**\r\n\t\tAn object containing commonly used constants for file system operations.\r\n\t**/\r\n\tstatic var constants(default, null):FsConstants;\r\n\r\n\t/**\r\n\t\tAsynchronous rename(2).\r\n\t**/\r\n\tstatic function rename(oldPath:FsPath, newPath:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous rename(2).\r\n\t**/\r\n\tstatic function renameSync(oldPath:FsPath, newPath:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous ftruncate(2).\r\n\t**/\r\n\tstatic function ftruncate(fd:Int, len:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous ftruncate(2).\r\n\t**/\r\n\tstatic function ftruncateSync(fd:Int, len:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous truncate(2).\r\n\t**/\r\n\tstatic function truncate(path:FsPath, len:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous truncate(2).\r\n\t**/\r\n\tstatic function truncateSync(path:FsPath, len:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous chown(2).\r\n\t**/\r\n\tstatic function chown(path:FsPath, uid:Int, gid:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous chown(2).\r\n\t**/\r\n\tstatic function chownSync(path:FsPath, uid:Int, gid:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fchown(2).\r\n\t**/\r\n\tstatic function fchown(fd:Int, uid:Int, gid:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous fchown(2).\r\n\t**/\r\n\tstatic function fchownSync(fd:Int, uid:Int, gid:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous lchown(2).\r\n\t**/\r\n\tstatic function lchown(path:FsPath, uid:Int, gid:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous lchown(2).\r\n\t**/\r\n\tstatic function lchownSync(path:FsPath, uid:Int, gid:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous chmod(2).\r\n\t**/\r\n\tstatic function chmod(path:FsPath, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous chmod(2).\r\n\t**/\r\n\tstatic function chmodSync(path:FsPath, mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fchmod(2).\r\n\t**/\r\n\tstatic function fchmod(fd:Int, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous fchmod(2).\r\n\t**/\r\n\tstatic function fchmodSync(fd:Int, mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous lchmod(2).\r\n\t\tOnly available on Mac OS X.\r\n\t**/\r\n\tstatic function lchmod(path:FsPath, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous lchmod(2).\r\n\t**/\r\n\tstatic function lchmodSync(path:FsPath, mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous stat(2).\r\n\t**/\r\n\tstatic function stat(path:FsPath, callback:Error->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous lstat(2).\r\n\r\n\t\tlstat() is identical to stat(), except that if path is a symbolic link,\r\n\t\tthen the link itself is stat-ed, not the file that it refers to.\r\n\t**/\r\n\tstatic function lstat(path:FsPath, callback:Error->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fstat(2).\r\n\r\n\t\tfstat() is identical to stat(), except that the file to be stat-ed\r\n\t\tis specified by the file descriptor fd.\r\n\t**/\r\n\tstatic function fstat(fd:Int, callback:Error->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous stat(2).\r\n\t**/\r\n\tstatic function statSync(path:FsPath):Stats;\r\n\r\n\t/**\r\n\t\tSynchronous lstat(2).\r\n\t**/\r\n\tstatic function lstatSync(path:FsPath):Stats;\r\n\r\n\t/**\r\n\t\tSynchronous fstat(2).\r\n\t**/\r\n\tstatic function fstatSync(fd:Int):Stats;\r\n\r\n\t/**\r\n\t\tAsynchronous link(2).\r\n\t**/\r\n\tstatic function link(srcpath:FsPath, dstpath:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous link(2).\r\n\t**/\r\n\tstatic function linkSync(srcpath:FsPath, dstpath:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous symlink(2).\r\n\r\n\t\tThe `type` argument can be set to 'dir', 'file', or 'junction' (default is 'file')\r\n\t\tand is only available on Windows (ignored on other platforms). Note that Windows junction\r\n\t\tpoints require the destination path to be absolute. When using 'junction', the destination\r\n\t\targument will automatically be normalized to absolute path.\r\n\t**/\r\n\t@:overload(function(srcpath:FsPath, dstpath:FsPath, callback:Error->Void):Void {})\r\n\tstatic function symlink(srcpath:FsPath, dstpath:FsPath, type:SymlinkType, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous symlink(2).\r\n\t**/\r\n\t@:overload(function(srcpath:FsPath, dstpath:FsPath):Void {})\r\n\tstatic function symlinkSync(srcpath:FsPath, dstpath:FsPath, type:SymlinkType):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous readlink(2).\r\n\t**/\r\n\tstatic function readlink(path:FsPath, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous readlink(2).\r\n\t\tReturns the symbolic link's string value.\r\n\t**/\r\n\tstatic function readlinkSync(path:FsPath):String;\r\n\r\n\t/**\r\n\t\tAsynchronous realpath(2).\r\n\r\n\t\tThe callback gets two arguments (err, resolvedPath).\r\n\r\n\t\tMay use process.cwd to resolve relative paths.\r\n\r\n\t\t`cache` is an object literal of mapped paths that can be used to force a specific path resolution\r\n\t\tor avoid additional `stat` calls for known real paths.\r\n\t**/\r\n\t@:overload(function(path:FsPath, callback:Error->String->Void):Void {})\r\n\tstatic function realpath(path:FsPath, cache:DynamicAccess<String>, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous realpath(2).\r\n\t\tReturns the resolved path.\r\n\t**/\r\n\t@:overload(function(path:FsPath):String {})\r\n\tstatic function realpathSync(path:FsPath, cache:DynamicAccess<String>):String;\r\n\r\n\t/**\r\n\t\tAsynchronous unlink(2).\r\n\t**/\r\n\tstatic function unlink(path:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous unlink(2).\r\n\t**/\r\n\tstatic function unlinkSync(path:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous rmdir(2).\r\n\t**/\r\n\tstatic function rmdir(path:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous rmdir(2).\r\n\t**/\r\n\tstatic function rmdirSync(path:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous mkdir(2).\r\n\t\t`mode` defaults to 0777.\r\n\t**/\r\n\t@:overload(function(path:FsPath, callback:Error->Void):Void {})\r\n\tstatic function mkdir(path:FsPath, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous mkdir(2).\r\n\t**/\r\n\tstatic function mkdirSync(path:FsPath, ?mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tCreates a unique temporary directory.\r\n\r\n\t\tGenerates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\r\n\r\n\t\tThe created folder path is passed as a string to the `callback`'s second parameter.\r\n\t**/\r\n\tstatic function mkdtemp(prefix:String, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tThe synchronous version of `mkdtemp`.\r\n\r\n\t\tReturns the created folder path.\r\n\t**/\r\n\tstatic function mkdtempSync(template:String):String;\r\n\r\n\t/**\r\n\t\tAsynchronous readdir(3).\r\n\t\tReads the contents of a directory.\r\n\r\n\t\tThe callback gets two arguments (err, files) where files is an array of the\r\n\t\tnames of the files in the directory excluding '.' and '..'.\r\n\t**/\r\n\tstatic function readdir(path:FsPath, callback:Error->Array<String>->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous readdir(3).\r\n\t\tReturns an array of filenames excluding '.' and '..'.\r\n\t**/\r\n\tstatic function readdirSync(path:FsPath):Array<String>;\r\n\r\n\t/**\r\n\t\tAsynchronous close(2).\r\n\t**/\r\n\tstatic function close(fd:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous close(2).\r\n\t**/\r\n\tstatic function closeSync(fd:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous file open. See open(2).\r\n\r\n\t\tSee `FsOpenFlag` for description of possible `flags`.\r\n\r\n\t\t`mode` sets the file mode (permission and sticky bits), but only if the file was created.\r\n\t\tIt defaults to 0666, readable and writeable.\r\n\r\n\t\tThe `callback` gets two arguments (err, fd).\r\n\t**/\r\n\t@:overload(function(path:FsPath, flags:FsOpenFlag, callback:Error->Int->Void):Void {})\r\n\tstatic function open(path:FsPath, flags:FsOpenFlag, mode:FsMode, callback:Error->Int->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of open().\r\n\t**/\r\n\t@:overload(function(path:FsPath, flags:FsOpenFlag):Int {})\r\n\tstatic function openSync(path:FsPath, flags:FsOpenFlag, mode:FsMode):Int;\r\n\r\n\t/**\r\n\t\tChange file timestamps of the file referenced by the supplied path.\r\n\t**/\r\n\tstatic function utimes(path:FsPath, atime:Date, mtime:Date, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tChange file timestamps of the file referenced by the supplied path.\r\n\t**/\r\n\tstatic function utimesSync(path:FsPath, atime:Date, mtime:Date):Void;\r\n\r\n\t/**\r\n\t\tChange the file timestamps of a file referenced by the supplied file descriptor.\r\n\t**/\r\n\tstatic function futimes(fd:Int, atime:Date, mtime:Date, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tChange the file timestamps of a file referenced by the supplied file descriptor.\r\n\t**/\r\n\tstatic function futimesSync(fd:Int, atime:Date, mtime:Date):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fsync(2).\r\n\t**/\r\n\tstatic function fsync(fd:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous fsync(2).\r\n\t**/\r\n\tstatic function fsyncSync(fd:Int):Void;\r\n\r\n\t/**\r\n\t\tDocumentation for the overloads with the `buffer` argument:\r\n\r\n\t\tWrite `buffer` to the file specified by `fd`.\r\n\r\n\t\t`offset` and `length` determine the part of the `buffer` to be written.\r\n\r\n\t\t`position` refers to the offset from the beginning of the file where this data should be written.\r\n\t\tIf position is null, the data will be written at the current position. See pwrite(2).\r\n\r\n\t\tThe `callback` will be given three arguments (err, written, buffer)\r\n\t\twhere `written` specifies how many bytes were written from `buffer`.\r\n\r\n\t\t---\r\n\r\n\t\tDocumentation for the overloads with the `data` argument:\r\n\r\n\t\tWrite `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then\r\n\t\tthe value will be coerced to a string.\r\n\r\n\t\t`position` refers to the offset from the beginning of the file where this data should be written.\r\n\t\tIf omitted, the data will be written at the current position. See pwrite(2).\r\n\r\n\t\t`encoding` is the expected string encoding.\r\n\r\n\t\tThe `callback` will receive the arguments (err, written, string) where written specifies how many bytes\r\n\t\tthe passed string required to be written. Note that bytes written is not the same as string characters.\r\n\t\tSee `Buffer.byteLength`.\r\n\r\n\t\tUnlike when writing `buffer`, the entire string must be written. No substring may be specified.\r\n\t\tThis is because the byte offset of the resulting data may not be the same as the string offset.\r\n\r\n\t\t---\r\n\r\n\t\tCommon notes:\r\n\r\n\t\tNote that it is unsafe to use `write` multiple times on the same file without waiting for the callback.\r\n\t\tFor this scenario, `createWriteStream` is strongly recommended.\r\n\r\n\t\tOn Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position\r\n\t\targument and always appends the data to the end of the file.\r\n\t**/\r\n\t@:overload(function(fd:Int, data:Dynamic, position:Int, encoding:String, callback:Error->Int->String->Void):Void {})\r\n\t@:overload(function(fd:Int, data:Dynamic, position:Int, callback:Error->Int->String->Void):Void {})\r\n\t@:overload(function(fd:Int, data:Dynamic, callback:Error->Int->String->Void):Void {})\r\n\t@:overload(function(fd:Int, buffer:Buffer, offset:Int, length:Int, callback:Error->Int->Buffer->Void):Void {})\r\n\tstatic function write(fd:Int, buffer:Buffer, offset:Int, length:Int, position:Int, callback:Error->Int->Buffer->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `write`. Returns the number of bytes written.\r\n\t**/\r\n\t@:overload(function(fd:Int, data:Dynamic, position:Int, encoding:String):Int {})\r\n\t@:overload(function(fd:Int, data:Dynamic, ?position:Int):Int {})\r\n\tstatic function writeSync(fd:Int, buffer:Buffer, offset:Int, length:Int, ?position:Int):Int;\r\n\r\n\t/**\r\n\t\tRead data from the file specified by `fd`.\r\n\r\n\t\t`buffer` is the buffer that the data will be written to.\r\n\r\n\t\t`offset` is the offset in the `buffer` to start writing at.\r\n\r\n\t\t`length` is an integer specifying the number of bytes to read.\r\n\r\n\t\t`position` is an integer specifying where to begin reading from in the file.\r\n\t\tIf position is null, data will be read from the current file position.\r\n\r\n\t\tThe `callback` is given the three arguments, (err, bytesRead, buffer).\r\n\t**/\r\n\tstatic function read(fd:Int, buffer:Buffer, offset:Int, length:Int, position:Null<Int>, callback:Error->Int->Buffer->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `read`. Returns the number of bytes read.\r\n\t**/\r\n\tstatic function readSync(fd:Int, buffer:Buffer, offset:Int, length:Int, position:Null<Int>):Int;\r\n\r\n\t/**\r\n\t\tAsynchronously reads the entire contents of a file.\r\n\r\n\t\tThe `callback` is passed two arguments (err, data), where data is the contents of the file.\r\n\t\tIf no `encoding` is specified, then the raw buffer is returned.\r\n\r\n\t\tIf `options` is a string, then it specifies the encoding.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, callback:Error->Buffer->Void):Void {})\r\n\t@:overload(function(filename:FsPath, options:{flag:FsOpenFlag}, callback:Error->Buffer->Void):Void {})\r\n\t@:overload(function(filename:FsPath, options:String, callback:Error->String->Void):Void {})\r\n\tstatic function readFile(filename:FsPath, options:{encoding:String, ?flag:FsOpenFlag}, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `readFile`. Returns the contents of the filename.\r\n\t\tIf the `encoding` option is specified then this function returns a string. Otherwise it returns a buffer.\r\n\t**/\r\n\t@:overload(function(filename:FsPath):Buffer {})\r\n\t@:overload(function(filename:FsPath, options:{flag:FsOpenFlag}):Buffer {})\r\n\t@:overload(function(filename:FsPath, options:String):String {})\r\n\tstatic function readFileSync(filename:FsPath, options:{encoding:String, ?flag:FsOpenFlag}):String;\r\n\r\n\t/**\r\n\t\tAsynchronously writes data to a file, replacing the file if it already exists.\r\n\r\n\t\t`data` can be a string or a buffer.\r\n\r\n\t\tThe encoding option is ignored if data is a buffer. It defaults to 'utf8'.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:String, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void {})\r\n\tstatic function writeFile(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tThe synchronous version of `writeFile`.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer):Void {})\r\n\t@:overload(function(filename:FsPath, data:String):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>):Void {})\r\n\tstatic function writeFileSync(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>):Void;\r\n\r\n\t/**\r\n\t\tAsynchronously append data to a file, creating the file if it not yet exists.\r\n\t\t`data` can be a string or a buffer.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:String, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void {})\r\n\tstatic function appendFile(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tThe synchronous version of `appendFile`.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer):Void {})\r\n\t@:overload(function(filename:FsPath, data:String):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>):Void {})\r\n\tstatic function appendFileSync(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>):Void;\r\n\r\n\t/**\r\n\t\tUnstable. Use `watch` instead, if possible.\r\n\r\n\t\tWatch for changes on `filename`.\r\n\t\tThe callback `listener` will be called each time the file is accessed.\r\n\r\n\t\tThe `options` if provided should be an object containing two members:\r\n\t\t\t- `persistent` indicates whether the process should continue to run as long as files are being watched.\r\n\t\t\t- `interval` indicates how often the target should be polled, in milliseconds.\r\n\t\tThe default is { persistent: true, interval: 5007 }.\r\n\r\n\t\tThe `listener` gets two arguments: the current stat object and the previous stat object.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, listener:Stats->Stats->Void):Void {})\r\n\tstatic function watchFile(filename:FsPath, options:FsWatchFileOptions, listener:Stats->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tUnstable. Use `watch` instead, if possible.\r\n\r\n\t\tStop watching for changes on filename.\r\n\t\tIf `listener` is specified, only that particular listener is removed.\r\n\t\tOtherwise, all listeners are removed and you have effectively stopped watching filename.\r\n\t\tCalling `unwatchFile` with a `filename` that is not being watched is a no-op, not an error.\r\n\t**/\r\n\tstatic function unwatchFile(filename:FsPath, ?listener:Stats->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tWatch for changes on `filename`, where filename is either a file or a directory.\r\n\r\n\t\t`persistent` indicates whether the process should continue to run as long as files are being watched. Default is `true`.\r\n\r\n\t\tThe `listener` callback gets two arguments (event, filename). event is either 'rename' or 'change', and filename\r\n\t\tis the name of the file which triggered the event.\r\n\t**/\r\n\t@:overload(function(filename:FsPath):FSWatcher {})\r\n\t@:overload(function(filename:FsPath, options:{persistent:Bool, ?recursive:Bool}, listener:FSWatcherChangeType->String->Void):FSWatcher {})\r\n\tstatic function watch(filename:FsPath, listener:FSWatcherChangeType->FsPath->Void):FSWatcher;\r\n\r\n\t/**\r\n\t\tTest whether or not the given `path` exists by checking with the file system.\r\n\t\tThen call the `callback` argument with either `true` or `false`.\r\n\r\n\t\t`exists` is an anachronism and exists only for historical reasons.\r\n\t\tThere should almost never be a reason to use it in your own code.\r\n\r\n\t\tIn particular, checking if a file exists before opening it is an anti-pattern that leaves you vulnerable to race conditions:\r\n\t\tanother process may remove the file between the calls to `exists` and `open`.\r\n\r\n\t\tJust open the file and handle the error when it's not there.\r\n\t**/\r\n\t@:deprecated(\"Use Fs.stat or Fs.access instead\")\r\n\tstatic function exists(path:FsPath, callback:Bool->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `exists`.\r\n\t**/\r\n\tstatic function existsSync(path:FsPath):Bool;\r\n\r\n\t/**\r\n\t\tTests a user's permissions for the file or directory specified by `path`.\r\n\r\n\t\tThe `mode` argument is an optional integer that specifies the accessibility checks to be performed.\r\n\t\tThe following constants define the possible values of `mode`. It is possible to create a mask consisting\r\n\t\tof the bitwise OR of two or more values.\r\n\r\n\t\t* `Fs.constants.F_OK` - path is visible to the calling process. This is useful for determining if a file exists,\r\n\t\t  but says nothing about `rwx` permissions. Default if no `mode` is specified.\r\n\t\t* `Fs.constants.R_OK` - path can be read by the calling process.\r\n\t\t* `Fs.constants.W_OK` - path can be written by the calling process.\r\n\t\t* `Fs.constants.X_OK` - path can be executed by the calling process.\r\n\t\t  This has no effect on Windows (will behave like `Fs.constants.F_OK`).\r\n\r\n\t\tThe final argument, `callback`, is a callback function that is invoked with a possible error argument.\r\n\t\tIf any of the accessibility checks fail, the error argument will be populated.\r\n\t**/\r\n\t@:overload(function(path:FsPath, callback:Error->Void):Void {})\r\n\tstatic function access(path:FsPath, mode:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile is visible to the calling process.\r\n\t\tThis is useful for determining if a file exists, but says nothing about rwx permissions.\r\n\t**/\r\n\tstatic var F_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile can be read by the calling process.\r\n\t**/\r\n\tstatic var R_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile can be written by the calling process.\r\n\t**/\r\n\tstatic var W_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile can be executed by the calling process.\r\n\t\tThis has no effect on Windows.\r\n\t**/\r\n\tstatic var X_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tSynchronous version of `access`.\r\n\t\tThis throws if any accessibility checks fail, and does nothing otherwise.\r\n\t**/\r\n\tstatic function accessSync(path:FsPath, ?mode:Int):Void;\r\n\r\n\t/**\r\n\t\tReturns a new ReadStream object (See Readable Stream).\r\n\r\n\t\t`options` can include `start` and `end` values to read a range of bytes from the file instead of the entire file.\r\n\t\tBoth `start` and `end` are inclusive and start at 0.\r\n\r\n\t\tThe encoding can be 'utf8', 'ascii', or 'base64'.\r\n\r\n\t\tIf `autoClose` is `false`, then the file descriptor won't be closed, even if there's an error.\r\n\t\tIt is your responsiblity to close it and make sure there's no file descriptor leak.\r\n\t\tIf `autoClose` is set to true (default behavior), on error or end the file descriptor will be closed automatically.\r\n\t**/\r\n\tstatic function createReadStream(path:FsPath, ?options:EitherType<String, FsCreateReadStreamOptions>):ReadStream;\r\n\r\n\t/**\r\n\t\tReturns a new WriteStream object (See Writable Stream).\r\n\r\n\t\t`options` may also include a `start` option to allow writing data at some position past the beginning of the file.\r\n\r\n\t\tModifying a file rather than replacing it may require a flags mode of r+ rather than the default mode w.\r\n\t**/\r\n\tstatic function createWriteStream(path:FsPath, ?options:FsCreateWriteStreamOptions):WriteStream;\r\n}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.buffer;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.UInt8Array;\r\n#if haxe4\r\nimport js.lib.ArrayBuffer;\r\nimport js.lib.ArrayBufferView;\r\nimport js.lib.Object;\r\nimport js.lib.Uint8Array;\r\n#else\r\nimport js.html.ArrayBuffer;\r\nimport js.html.ArrayBufferView;\r\nimport js.html.Uint8Array;\r\n#end\r\n\r\n/**\r\n\tThe `Buffer` class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.\r\n\r\n\t@see https://nodejs.org/api/buffer.html#buffer_class_buffer\r\n**/\r\n@:jsRequire(\"buffer\", \"Buffer\")\r\nextern class Buffer extends Uint8Array {\r\n\t/**\r\n\t\tAllocates a new buffer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding\r\n\t**/\r\n\t@:deprecated\r\n\t@:overload(function(array:Array<Int>):Void {})\r\n\t@:overload(function(arrayBuffer:ArrayBuffer, ?byteOffset:Int, ?length:Int):Void {})\r\n\t@:overload(function(buffer:UInt8Array):Void {})\r\n\t@:overload(function(size:Int):Void {})\r\n\tfunction new(string:String, ?encoding:String):Void;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the `Buffer` will be zero-filled.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding\r\n\t**/\r\n\t@:overload(function(size:Int, fill:String, ?encoding:String):Buffer {})\r\n\t@:overload(function(size:Int, fill:Uint8Array):Buffer {})\r\n\t@:overload(function(size:Int, fill:Int):Buffer {})\r\n\tstatic function alloc(size:Int):Buffer;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer` of `size` bytes. If `size` is larger than\r\n\t\t`buffer.constants.MAX_LENGTH` or smaller than 0, `ERR_INVALID_OPT_VALUE`\r\n\t\tis thrown. A zero-length `Buffer` is created if `size` is 0.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafe_size\r\n\t**/\r\n\tstatic function allocUnsafe(size:Int):Buffer;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer` of `size` bytes. If `size` is larger than\r\n\t\t`buffer.constants.MAX_LENGTH` or smaller than 0, `ERR_INVALID_OPT_VALUE`\r\n\t\tis thrown. A zero-length `Buffer` is created if `size` is 0.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafeslow_size\r\n\t**/\r\n\tstatic function allocUnsafeSlow(size:Int):Buffer;\r\n\r\n\t/**\r\n\t\tReturns the actual byte length of a string. This is not the same as\r\n\t\t`String.prototype.length` since that returns the number of characters in\r\n\t\ta string.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_bytelength_string_encoding\r\n\t**/\r\n\t#if (haxe_ver >= 3.3)\r\n\t// it need extern SharedArrayBuffer for Node\r\n\t// @:overload(function(string:SharedArrayBuffer):Int {})\r\n\t@:overload(function(string:String, ?encoding:String):Int {})\r\n\t@:overload(function(string:ArrayBufferView):Int {})\r\n\t@:overload(function(string:ArrayBuffer):Int {})\r\n\tstatic function byteLength(string:Buffer):Int;\r\n\t#end\r\n\r\n\t#if (haxe_ver >= 3.3)\r\n\t@:deprecated(\"In haxe 3.3+, use Buffer.byteLength instead!\")\r\n\t#end\r\n\tinline static function _byteLength(string:String, ?encoding:String):Int\r\n\t\treturn untyped Buffer['byteLength'](string, encoding);\r\n\r\n\t/**\r\n\t\tCompares `buf1` to `buf2` typically for the purpose of sorting arrays of\r\n\t\t`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_compare_buf1_buf2\r\n\t**/\r\n\t@:native(\"compare\")\r\n\tstatic function compareBuffers(buf1:Uint8Array, buf2:Uint8Array):Int;\r\n\r\n\t/**\r\n\t\tReturns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_concat_list_totallength\r\n\t**/\r\n\tstatic function concat<T:Uint8Array>(list:Array<T>, ?totalLength:Int):Buffer;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding\r\n\t**/\r\n\t// it need extern SharedArrayBuffer for node\r\n\t// @:overload(function(arrayBuffer:SharedArrayBuffer, ?byteOffset:Int, ?length:Int):Buffer {})\r\n\t@:overload(function(array:Array<Int>):Buffer {})\r\n\t@:overload(function(arrayBuffer:ArrayBuffer, ?byteOffset:Int, ?length:Int):Buffer {})\r\n\t@:overload(function(buffer:Uint8Array):Buffer {})\r\n\t@:overload(function(object:{}, ?offset:Int, ?length:Int):Buffer {})\r\n\t@:overload(function(object:{}, ?encoding:String, ?length:Int):Buffer {})\r\n\tstatic function from(string:String, ?encoding:String):Buffer;\r\n\r\n\t/**\r\n\t\tReturns `true` if `obj` is a `Buffer`, `false` otherwise.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_isbuffer_obj\r\n\t**/\r\n\tstatic function isBuffer(obj:Dynamic):Bool;\r\n\r\n\t/**\r\n\t\tReturns `true` if `encoding` contains a supported character encoding, or `false` otherwise.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_isencoding_encoding\r\n\t**/\r\n\tstatic function isEncoding(encoding:String):Bool;\r\n\r\n\t/**\r\n\t\tThis is the size (in bytes) of pre-allocated internal `Buffer` instances used for pooling. This value may be modified.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_property_buffer_poolsize\r\n\t**/\r\n\tstatic var poolSize:Int;\r\n\r\n\t// buf[index]\r\n\t// var buffer:ArrayBuffer;\r\n\r\n\t/**\r\n\t\tWhen setting `byteOffset` in `Buffer.from(ArrayBuffer, byteOffset, length)`\r\n\t\tor sometimes when allocating a buffer smaller than `Buffer.poolSize` the\r\n\t\tbuffer doesn't start from a zero offset on the underlying `ArrayBuffer`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_byteoffset\r\n\t**/\r\n\tstatic var byteOffset(default, null):Int;\r\n\r\n\t/**\r\n\t\tCompares `buf` with `target` and returns a number indicating whether `buf` comes before, after,\r\n\t\tor is the same as `target` in sort order. Comparison is based on the actual sequence of bytes in each `Buffer`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend\r\n\t**/\r\n\t@:overload(function(target:Uint8Array):Int {})\r\n\tfunction compare(target:Uint8Array, ?targetStart:Int, ?targetEnd:Int, ?sourceStart:Int, ?sourceEnd:Int):Int;\r\n\r\n\t/**\r\n\t\tCopies data from a region of `buf` to a region in `target` even if the `target` memory region overlaps with `buf`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_copy_target_targetstart_sourcestart_sourceend\r\n\t**/\r\n\t@:overload(function(target:Uint8Array):Void {})\r\n\tfunction copy(target:Uint8Array, ?targetStart:Int, ?sourceStart:Int, ?sourceEnd:Int):Void;\r\n\r\n\t/**\r\n\t\tCreates and returns an iterator of `[index, byte]` pairs from the contents of `buf`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_entries\r\n\t**/\r\n\tfunction entries():js.node.Iterator<js.node.KeyValue<Int, Int>>;\r\n\r\n\t/**\r\n\t\tReturns `true` if both `buf` and `otherBuffer` have exactly the same bytes, `false` otherwise.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_equals_otherbuffer\r\n\t**/\r\n\tfunction equals(otherBuffer:Uint8Array):Bool;\r\n\r\n\t/**\r\n\t\tFills `buf` with the specified `value`. If the `offset` and `end` are not given, the entire `buf` will be filled:\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_fill_value_offset_end_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?offset:Int, ?end:Int):Buffer {})\r\n\t@:overload(function(value:Int, ?offset:Int, ?end:Int):Buffer {})\r\n\tfunction fill(value:String, ?offset:Int, ?end:Int, ?encoding:String):Buffer;\r\n\r\n\t/**\r\n\t\tEquivalent to `buf.indexOf() !== -1`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_includes_value_byteoffset_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?byteOffset:Int):Bool {})\r\n\t@:overload(function(value:Int, ?byteOffset:Int):Bool {})\r\n\tfunction includes(value:String, ?byteOffset:Int, ?encoding:String):Bool;\r\n\r\n\t/**\r\n\t\tIf `value` is:\r\n\r\n\t\t- a string, `value` is interpreted according to the character encoding in `encoding`.\r\n\t\t- a `Buffer` or Uint8Array, `value` will be used in its entirety. To compare a partial `Buffer`, use buf.slice().\r\n\t\t- a number, `value` will be interpreted as an unsigned 8-bit integer value between `0` and `255`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_indexof_value_byteoffset_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?byteOffset:Int):Int {})\r\n\t@:overload(function(value:Int, ?byteOffset:Int):Int {})\r\n\tfunction indexOf(value:String, ?byteOffset:Int, ?encoding:String):Int;\r\n\r\n\t/**\r\n\t\tCreates and returns an iterator of `buf` keys (indices).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_keys\r\n\t**/\r\n\tfunction keys():js.node.Iterator<Int>;\r\n\r\n\t/**\r\n\t\tIdentical to `buf.indexOf()`, except the last occurrence of `value` is found\r\n\t\trather than the first occurrence.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_lastindexof_value_byteoffset_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?byteOffset:Int):Int {})\r\n\t@:overload(function(value:Int, ?byteOffset:Int):Int {})\r\n\tfunction lastIndexOf(value:String, ?byteOffset:Int, ?encoding:String):Int;\r\n\r\n\t// var length(default, null):Int;\r\n\t// these functions need BigInt implementation.\r\n\t// /**\r\n\t// \tReads a signed 64-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t// \t(`readBigInt64BE()` returns big endian, `readBigInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbigint64be_offset\r\n\t// **/\r\n\t// function readBigInt64BE(?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tReads a signed 64-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t// \t(`readBigInt64BE()` returns big endian, `readBigInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbigint64le_offset\r\n\t// **/\r\n\t// function readBigInt64LE(?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tReads an unsigned 64-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t// \t(`readBigUInt64BE()` returns big endian, `readBigUInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbiguint64be_offset\r\n\t// **/\r\n\t// function readBigUInt64BE(?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tReads an unsigned 64-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t// \t(`readBigUInt64BE()` returns big endian, `readBigUInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbiguint64le_offset\r\n\t// **/\r\n\t// function readBigUInt64LE(?offset:Int):BigInt;\r\n\r\n\t/**\r\n\t\tReads a 64-bit double from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readDoubleBE()` returns big endian, `readDoubleLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readdoublebe_offset\r\n\t**/\r\n\tfunction readDoubleBE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a 64-bit double from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readDoubleBE()` returns big endian, `readDoubleLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readdoublele_offset\r\n\t**/\r\n\tfunction readDoubleLE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a 32-bit float from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readFloatBE()` returns big endian, `readFloatLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readfloatbe_offset\r\n\t**/\r\n\tfunction readFloatBE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a 32-bit float from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readFloatBE()` returns big endian, `readFloatLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readfloatle_offset\r\n\t**/\r\n\tfunction readFloatLE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a signed 8-bit integer from `buf` at the specified `offset`.\r\n\r\n\t\thttps://nodejs.org/api/buffer.html#buffer_buf_readint8_offset\r\n\t**/\r\n\tfunction readInt8(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 16-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t\t(`readInt16BE()` returns big endian, `readInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint16be_offset\r\n\t**/\r\n\tfunction readInt16BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 16-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t\t(`readInt16BE()` returns big endian, `readInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint16le_offset\r\n\t**/\r\n\tfunction readInt16LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 32-bit integer from buf at the specified offset with the specified endian format\r\n\t\t(`readInt32BE()` returns big endian, `readInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint32be_offset\r\n\t**/\r\n\tfunction readInt32BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 32-bit integer from buf at the specified offset with the specified endian format\r\n\t\t(`readInt32BE()` returns big endian, `readInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint32be_offset\r\n\t**/\r\n\tfunction readInt32LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result\r\n\t\tas a two's complement signed value. Supports up to 48 bits of accuracy.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readintbe_offset_bytelength\r\n\t**/\r\n\tfunction readIntBE(offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tReads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result\r\n\t\tas a two's complement signed value. Supports up to 48 bits of accuracy.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readintle_offset_bytelength\r\n\t**/\r\n\tfunction readIntLE(offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 8-bit integer from `buf` at the specified `offset`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint8_offset\r\n\t**/\r\n\tfunction readUInt8(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 16-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t`readUInt16BE()` returns big endian, `readUInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint16be_offset\r\n\t**/\r\n\tfunction readUInt16BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 16-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readUInt16BE()` returns big endian, `readUInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint16le_offset\r\n\t**/\r\n\tfunction readUInt16LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 32-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readUInt32BE()` returns big endian, `readUInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint32be_offset\r\n\t**/\r\n\tfunction readUInt32BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 32-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readUInt32BE()` returns big endian, `readUInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint32be_offset\r\n\t**/\r\n\tfunction readUInt32LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReturns a new `Buffer` that references the same memory as the original,\r\n\t\tbut offset and cropped by the `start` and `end` indices.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_subarray_start_end\r\n\t**/\r\n\t#if haxe4\r\n\tfunction subarray(?start:Int, ?end:Int):Buffer;\r\n\t#else\r\n\toverride function subarray(start:Int, ?end:Int):Buffer;\r\n\t#end\r\n\r\n\t/**\r\n\t\tReturns a new `Buffer` that references the same memory as the original,\r\n\t\tbut offset and cropped by the `start` and `end` indices.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_slice_start_end\r\n\t**/\r\n\tfunction slice(?start:Int, ?end:Int):Buffer;\r\n\r\n\t/**\r\n\t\tInterprets `buf` as an array of unsigned 16-bit integers and swaps the\r\n\t\tbyte order in-place. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length`\r\n\t\tis not a multiple of 2.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_swap16\r\n\t**/\r\n\tfunction swap16():Buffer;\r\n\r\n\t/**\r\n\t\tInterprets `buf` as an array of unsigned 32-bit integers and swaps the\r\n\t\tbyte order in-place. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length`\r\n\t\tis not a multiple of 4.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_swap32\r\n\t**/\r\n\tfunction swap32():Buffer;\r\n\r\n\t/**\r\n\t\tInterprets `buf` as an array of 64-bit numbers and swaps byte order in-place.\r\n\t\tThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_swap64\r\n\t**/\r\n\tfunction swap64():Buffer;\r\n\r\n\t/**\r\n\t\tReturns a JSON representation of `buf`. `JSON.stringify()` implicitly calls\r\n\t\tthis function when stringifying a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_tojson\r\n\t**/\r\n\tfunction toJSON():Dynamic;\r\n\r\n\t/**\r\n\t\tDecodes `buf` to a string according to the specified character encoding in `encoding`.\r\n\t\t`start` and `end` may be passed to decode only a subset of `buf`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end\r\n\t**/\r\n\t@:overload(function(?encoding:String, ?start:Int, ?end:Int):String {})\r\n\tfunction toString():String;\r\n\r\n\t/**\r\n\t\tCreates and returns an iterator for `buf` values (bytes). This function is called automatically\r\n\t\twhen a `Buffer` is used in a `for..of` statement.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_values\r\n\t**/\r\n\tfunction values():js.node.Iterator<Int>;\r\n\r\n\t/**\r\n\t\tWrites `string` to `buf` at `offset` according to the character encoding in `encoding`.\r\n\t\tThe `length` parameter is the number of bytes to write.\r\n\t\tIf `buf` did not contain enough space to fit the entire `string`, only part of string will be written.\r\n\t\tHowever, partially encoded characters will not be written.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_write_string_offset_length_encoding\r\n\t**/\r\n\tfunction write(string:String, ?offset:Int, ?length:Int, ?encoding:String):Int;\r\n\r\n\t// these functions need BigInt Implementation.\r\n\t// /**\r\n\t// \tWrites `value` to `buf` at the specified `offset` with specified endian format (`writeBigInt64BE()` writes big endian, `writeBigInt64LE()` writes little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_writebigint64be_value_offset\r\n\t// **/\r\n\t// function writeBigInt64BE(value:Int, ?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tWrites `value` to `buf` at the specified `offset` with specified endian format (`writeBigInt64BE()` writes big endian, `writeBigInt64LE()` writes little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_writebigint64le_value_offset\r\n\t// **/\r\n\t// function writeBigInt64LE(value:Int, ?offset:Int):BigInt;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little endian).\r\n\t\t`value` should be a valid 64-bit double. Behavior is undefined when `value` is anything other than a 64-bit double.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writedoublebe_value_offset\r\n\t**/\r\n\tfunction writeDoubleBE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little endian).\r\n\t\t`value` should be a valid 64-bit double. Behavior is undefined when `value` is anything other than a 64-bit double.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writedoublele_value_offset\r\n\t**/\r\n\tfunction writeDoubleLE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeFloatBE()` writes big endian, `writeFloatLE()` writes little endian).\r\n\t\t`value` should be a valid 32-bit float. Behavior is undefined when `value` is anything other than a 32-bit float.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writefloatbe_value_offset\r\n\t**/\r\n\tfunction writeFloatBE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeFloatBE()` writes big endian, `writeFloatLE()` writes little endian).\r\n\t\t`value` should be a valid 32-bit float. Behavior is undefined when `value` is anything other than a 32-bit float.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writefloatle_value_offset\r\n\t**/\r\n\tfunction writeFloatLE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset`. `value` should be a valid signed 8-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than a signed 8-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint8_value_offset\r\n\t**/\r\n\tfunction writeInt8(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt16BE()` writes big endian, `writeInt16LE()` writes little endian).\r\n\t\t`value` should be a valid signed 16-bit integer.\r\n\t\tBehavior is undefined when value is anything other than a signed 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint16be_value_offset\r\n\t**/\r\n\tfunction writeInt16BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt16BE()` writes big endian, `writeInt16LE()` writes little endian).\r\n\t\t`value` should be a valid signed 16-bit integer.\r\n\t\tBehavior is undefined when value is anything other than a signed 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint16le_value_offset\r\n\t**/\r\n\tfunction writeInt16LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt32BE()` writes big endian, `writeInt32LE()` writes little endian).\r\n\t\t`value` should be a valid signed 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than a signed 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint32be_value_offset\r\n\t**/\r\n\tfunction writeInt32BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt32BE()` writes big endian, `writeInt32LE()` writes little endian).\r\n\t\t`value` should be a valid signed 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than a signed 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint32le_value_offset\r\n\t**/\r\n\tfunction writeInt32LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `byteLength` bytes of `value` to `buf` at the specified `offset`.\r\n\t\tSupports up to 48 bits of accuracy. Behavior is undefined when `value` is anything other than a signed integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeintbe_value_offset_bytelength\r\n\t**/\r\n\tfunction writeIntBE(value:Int, offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tWrites `byteLength` bytes of `value` to `buf` at the specified `offset`.\r\n\t\tSupports up to 48 bits of accuracy. Behavior is undefined when `value` is anything other than a signed integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeintle_value_offset_bytelength\r\n\t**/\r\n\tfunction writeIntLE(value:Int, offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset`. `value` should be a valid unsigned 8-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 8-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint8_value_offset\r\n\t**/\r\n\tfunction writeUInt8(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 16-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint16be_value_offset\r\n\t**/\r\n\tfunction writeUInt16BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 16-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint16le_value_offset\r\n\t**/\r\n\tfunction writeUInt16LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint32be_value_offset\r\n\t**/\r\n\tfunction writeUInt32BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint32le_value_offset\r\n\t**/\r\n\tfunction writeUInt32LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tDefault: `50`\r\n\r\n\t\tReturns the maximum number of bytes that will be returned when `buf.inspect()` is called.\r\n\t\tThis can be overridden by user modules.\r\n\t\tSee `util.inspect()` for more details on `buf.inspect()` behavior.\r\n\r\n\t\tThis is a property on the `buffer` module returned by `require('buffer')`, not on the `Buffer` global or a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_inspect_max_bytes\r\n\t**/\r\n\tstatic var INSPECT_MAX_BYTES(get, set):Int;\r\n\r\n\tprivate static inline function get_INSPECT_MAX_BYTES():Int {\r\n\t\treturn BufferModule.INSPECT_MAX_BYTES;\r\n\t}\r\n\tprivate static inline function set_INSPECT_MAX_BYTES(bytes:Int):Int {\r\n\t\treturn BufferModule.INSPECT_MAX_BYTES = bytes;\r\n\t}\r\n\r\n\t/**\r\n\t\tAn alias for `buffer.constants.MAX_LENGTH`.\r\n\r\n\t\tThis is a property on the `buffer` module returned by `require('buffer')`, not on the `Buffer` global or a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_kmaxlength\r\n\t**/\r\n\tstatic var kMaxLength(get, never):Int;\r\n\r\n\tprivate static inline function get_kMaxLength():Int {\r\n\t\treturn BufferModule.kMaxLength;\r\n\t}\r\n\r\n\t/**\r\n\t\tRe-encodes the given `Buffer` or `Uint8Array` instance from one character encoding to another.\r\n\t\tReturns a new `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_transcode_source_fromenc_toenc\r\n\t**/\r\n\tstatic inline function transcode(source:Uint8Array, fromEnc:String, toEnc:String):Buffer {\r\n\t\treturn BufferModule.transcode(source, fromEnc, toEnc);\r\n\t};\r\n\r\n\t/**\r\n\t\t`buffer.constants` is a property on the `buffer` module returned by `require('buffer')`,\r\n\t\tnot on the `Buffer` global or a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_constants\r\n\t**/\r\n\tstatic var constants(default, never):BufferConstants;\r\n\r\n\tprivate static inline function get_constants():BufferConstants {\r\n\t\treturn BufferModule.constants;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreate `haxe.io.Bytes` object that uses the same underlying data storage as `this` buffer.\r\n\t\tAny modifications done using the returned object will be reflected in the `this` buffer.\r\n\t**/\r\n\tinline function hxToBytes():Bytes {\r\n\t\treturn Helper.bytesOfBuffer(this);\r\n\t}\r\n\r\n\t/**\r\n\t\tCreate `Buffer` object from `haxe.io.Bytes` using the same underlying data storage.\r\n\t\tAny modifications done using the returned object will be reflected in given `haxe.io.Bytes` object.\r\n\t**/\r\n\tstatic inline function hxFromBytes(b:Bytes):Buffer {\r\n\t\tvar data = @:privateAccess b.b;\r\n\t\treturn Buffer.from(data.buffer, data.byteOffset, b.length);\r\n\t}\r\n}\r\n\r\n@:dce\r\nprivate class Helper {\r\n\tpublic static function bytesOfBuffer(b:Buffer):haxe.io.Bytes untyped {\r\n\t\tvar o = Object.create(haxe.io.Bytes.prototype);\r\n\t\t// the following is basically a haxe.io.Bytes constructor,\r\n\t\t// but using given buffer instead of creating new Uint8Array\r\n\t\to.length = b.byteLength;\r\n\t\to.b = b;\r\n\t\tb.bufferValue = b;\r\n\t\tb.hxBytes = o;\r\n\t\tb.bytes = b;\r\n\t\treturn o;\r\n\t}\r\n}\r\n\r\n@:jsRequire(\"buffer\")\r\nprivate extern class BufferModule {\r\n\tstatic var INSPECT_MAX_BYTES:Int;\r\n\tstatic var kMaxLength(default, never):Int;\r\n\tstatic function transcode(source:Uint8Array, fromEnc:String, toEnc:String):Buffer;\r\n\tstatic var constants(default, never):BufferConstants;\r\n}\r\n\r\ntypedef BufferConstants = {\r\n\t/**\r\n\t\tOn 32-bit architectures, this value is `(2^30)-1` (`~1GB`).\r\n\t\tOn 64-bit architectures, this value is `(2^31)-1` (`~2GB`).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_length\r\n\t**/\r\n\tvar MAX_LENGTH(default, never):Int;\r\n\r\n\t/**\r\n\t\tRepresents the largest `length` that a `string` primitive can have, counted\r\n\t\tin UTF-16 code units.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_string_length\r\n\t**/\r\n\tvar MAX_STRING_LENGTH(default, never):Int;\r\n}\r\n","package sys.io;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.Eof;\r\nimport haxe.io.Error;\r\nimport js.node.Buffer;\r\nimport js.node.Fs;\r\n\r\n@:coreApi\r\nclass FileInput extends haxe.io.Input {\r\n\tvar fd:Int;\r\n\tvar pos:Int;\r\n\r\n\t@:allow(sys.io.File)\r\n\tfunction new(fd:Int) {\r\n\t\tthis.fd = fd;\r\n\t\tpos = 0;\r\n\t}\r\n\r\n\toverride public function readByte():Int {\r\n\t\tvar buf = Buffer.alloc(1);\r\n\t\tvar bytesRead = try {\r\n\t\t\tFs.readSync(fd, buf, 0, 1, pos);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"EOF\")\r\n\t\t\t\tthrow new Eof();\r\n\t\t\telse\r\n\t\t\t\tthrow Error.Custom(e);\r\n\t\t}\r\n\t\tif (bytesRead == 0)\r\n\t\t\tthrow new Eof();\r\n\t\tpos++;\r\n\t\treturn buf[0];\r\n\t}\r\n\r\n\toverride public function readBytes(s:Bytes, pos:Int, len:Int):Int {\r\n\t\tvar buf = Buffer.hxFromBytes(s);\r\n\t\tvar bytesRead = try {\r\n\t\t\tFs.readSync(fd, buf, pos, len, this.pos);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"EOF\")\r\n\t\t\t\tthrow new Eof();\r\n\t\t\telse\r\n\t\t\t\tthrow Error.Custom(e);\r\n\t\t}\r\n\t\tif (bytesRead == 0)\r\n\t\t\tthrow new Eof();\r\n\t\tthis.pos += bytesRead;\r\n\t\treturn bytesRead;\r\n\t}\r\n\r\n\toverride public function close():Void {\r\n\t\tFs.closeSync(fd);\r\n\t}\r\n\r\n\tpublic function seek(p:Int, pos:FileSeek):Void {\r\n\t\tswitch (pos) {\r\n\t\t\tcase SeekBegin:\r\n\t\t\t\tthis.pos = p;\r\n\t\t\tcase SeekEnd:\r\n\t\t\t\tthis.pos = cast Fs.fstatSync(fd).size + p;\r\n\t\t\tcase SeekCur:\r\n\t\t\t\tthis.pos += p;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic function tell():Int {\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tpublic function eof():Bool {\r\n\t\treturn pos >= Fs.fstatSync(fd).size;\r\n\t}\r\n}\r\n"]}