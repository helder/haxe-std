<?php
/**
 * Generated by Haxe 4.2.0
 */

namespace helder\std\haxe;

use \helder\std\haxe\_EntryPoint\Lock;
use \helder\std\php\Boot;
use \helder\std\Array_hx;
use \helder\std\haxe\_EntryPoint\Mutex;
use \helder\std\haxe\_EntryPoint\Thread;

/**
 * If `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.
 * This class can be redefined by custom frameworks so they can handle their own main loop logic.
 */
class EntryPoint {
	/**
	 * @var Mutex
	 */
	static public $mutex;
	/**
	 * @var \Closure[]|Array_hx
	 */
	static public $pending;
	/**
	 * @var Lock
	 */
	static public $sleepLock;
	/**
	 * @var int
	 */
	static public $threadCount = 0;

	/**
	 * @param \Closure $f
	 * 
	 * @return void
	 */
	public static function addThread ($f) {
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:77: characters 3-16
		EntryPoint::$threadCount++;
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:82: lines 82-92
		Thread::create(function () use (&$f) {
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:83: characters 4-7
			$f();
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:85: characters 4-17
			EntryPoint::$threadCount--;
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:86: lines 86-87
			if (EntryPoint::$threadCount === 0) {
				#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:87: characters 5-13
				EntryPoint::wakeup();
			}
		});
	}

	/**
	 * @return float
	 */
	public static function processEvents () {
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:107: lines 107-118
		while (true) {
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:110: characters 12-27
			$_this = EntryPoint::$pending;
			if ($_this->length > 0) {
				$_this->length--;
			}
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:110: characters 4-28
			$f = \array_shift($_this->arr);
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:115: lines 115-116
			if ($f === null) {
				#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:116: characters 5-10
				break;
			}
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:117: characters 4-7
			$f();
		}
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:119: characters 3-46
		$time = MainLoop::tick();
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:120: lines 120-121
		if (!MainLoop::hasEvents() && (EntryPoint::$threadCount === 0)) {
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:121: characters 4-13
			return -1;
		}
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:122: characters 3-14
		return $time;
	}

	/**
	 * Start the main loop. Depending on the platform, this can return immediately or will only return when the application exits.
	 * 
	 * @return void
	 */
	public static function run () {
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:157: lines 157-163
		while (true) {
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:158: characters 4-35
			$nextTick = EntryPoint::processEvents();
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:159: lines 159-160
			if ($nextTick < 0) {
				#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:160: characters 5-10
				break;
			}
			#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:161: characters 8-20
			$tmp = $nextTick > 0;
		}
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return void
	 */
	public static function runInMainThread ($f) {
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:65: characters 5-20
		$_this = EntryPoint::$pending;
		$_this->arr[$_this->length++] = $f;
		#/home/runner/haxe/versions/4.2.0/std/haxe/EntryPoint.hx:67: characters 5-13
		EntryPoint::wakeup();
	}

	/**
	 * Wakeup a sleeping `run()`
	 * 
	 * @return void
	 */
	public static function wakeup () {
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$mutex = new Mutex();
		self::$sleepLock = new Lock();
		self::$pending = new Array_hx();
	}
}

Boot::registerClass(EntryPoint::class, 'haxe.EntryPoint');
EntryPoint::__hx__init();
