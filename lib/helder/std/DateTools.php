<?php
/**
 * Generated by Haxe 4.0.1
 */

namespace helder\std;

use \helder\std\php\_Boot\HxAnon;
use \helder\std\php\Boot;

/**
 * The DateTools class contains some extra functionalities for handling `Date`
 * instances and timestamps.
 * In the context of Haxe dates, a timestamp is defined as the number of
 * milliseconds elapsed since 1st January 1970.
 */
class DateTools {
	/**
	 * @var Array_hx
	 */
	static public $DAYS_OF_MONTH;

	/**
	 * Converts a number of days to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function days ($n) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:212: characters 3-41
		return $n * 24.0 * 60.0 * 60.0 * 1000.0;
	}

	/**
	 * Returns the result of adding timestamp `t` to Date `d`.
	 * This is a convenience function for calling
	 * `Date.fromTime(d.getTime() + t)`.
	 * 
	 * @param Date $d
	 * @param float $t
	 * 
	 * @return Date
	 */
	static public function delta ($d, $t) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:166: characters 3-40
		return Date::fromTime($d->getTime() + $t);
	}

	/**
	 * Format the date `d` according to the format `f`. The format is
	 * compatible with the `strftime` standard format, except that there is no
	 * support in Flash and JS for day and months names (due to lack of proper
	 * internationalization API). On Haxe/Neko/Windows, some formats are not
	 * supported.
	 * ```haxe
	 * var t = DateTools.format(Date.now(), "%Y-%m-%d_%H:%M:%S");
	 * // 2016-07-08_14:44:05
	 * var t = DateTools.format(Date.now(), "%r");
	 * // 02:44:05 PM
	 * var t = DateTools.format(Date.now(), "%T");
	 * // 14:44:05
	 * var t = DateTools.format(Date.now(), "%F");
	 * // 2016-07-08
	 * ```
	 * 
	 * @param Date $d
	 * @param string $f
	 * 
	 * @return string
	 */
	static public function format ($d, $f) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:153: characters 3-71
		return strftime($f, (int)($d->__t));
	}

	/**
	 * Returns the number of days in the month of Date `d`.
	 * This method handles leap years.
	 * 
	 * @param Date $d
	 * 
	 * @return int
	 */
	static public function getMonthDays ($d) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:177: characters 3-28
		$month = $d->getMonth();
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:178: characters 3-30
		$year = $d->getFullYear();
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:180: lines 180-181
		if ($month !== 1) {
			#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:181: characters 4-31
			return (DateTools::$DAYS_OF_MONTH->arr[$month] ?? null);
		}
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:183: characters 3-73
		$isB = ((($year % 4) === 0) && (($year % 100) !== 0)) || (($year % 400) === 0);
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:184: characters 10-29
		if ($isB) {
			#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:184: characters 19-21
			return 29;
		} else {
			#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:184: characters 27-29
			return 28;
		}
	}

	/**
	 * Converts a number of hours to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function hours ($n) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:205: characters 3-34
		return $n * 60.0 * 60.0 * 1000.0;
	}

	/**
	 * Build a date-time from several components
	 * 
	 * @param object $o
	 * 
	 * @return float
	 */
	static public function make ($o) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:241: characters 3-93
		return $o->ms + 1000.0 * ($o->seconds + 60.0 * ($o->minutes + 60.0 * ($o->hours + 24.0 * $o->days)));
	}

	/**
	 * Retrieve Unix timestamp value from Date components. Takes same argument sequence as the Date constructor.
	 * 
	 * @param int $year
	 * @param int $month
	 * @param int $day
	 * @param int $hour
	 * @param int $min
	 * @param int $sec
	 * 
	 * @return float
	 */
	static public function makeUtc ($year, $month, $day, $hour, $min, $sec) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:252: characters 3-74
		return gmmktime($hour, $min, $sec, $month + 1, $day, $year) * 1000;
	}

	/**
	 * Converts a number of minutes to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function minutes ($n) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:198: characters 3-27
		return $n * 60.0 * 1000.0;
	}

	/**
	 * Separate a date-time into several components
	 * 
	 * @param float $t
	 * 
	 * @return object
	 */
	static public function parse ($t) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:219: characters 3-20
		$s = $t / 1000;
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:220: characters 3-18
		$m = $s / 60;
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:221: characters 3-18
		$h = $m / 60;
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:224: characters 13-28
		$tmp = (int)((fmod($s, 60)));
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:225: characters 13-28
		$tmp1 = (int)((fmod($m, 60)));
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:226: characters 11-26
		$tmp2 = (int)((fmod($h, 24)));
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:222: lines 222-228
		return new HxAnon([
			"ms" => fmod($t, 1000),
			"seconds" => $tmp,
			"minutes" => $tmp1,
			"hours" => $tmp2,
			"days" => (int)(($h / 24)),
		]);
	}

	/**
	 * Converts a number of seconds to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function seconds ($n) {
		#/home/runner/haxe/versions/4.0.1/std/DateTools.hx:191: characters 3-20
		return $n * 1000.0;
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$DAYS_OF_MONTH = Array_hx::wrap([
			31,
			28,
			31,
			30,
			31,
			30,
			31,
			31,
			30,
			31,
			30,
			31,
		]);
	}
}

Boot::registerClass(DateTools::class, 'DateTools');
DateTools::__hx__init();
