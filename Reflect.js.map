{"sourceRoot":"","names":[],"mappings":"QAyBA;QCpBA;;;;;;;;;;ACgBU;AAAA;;;;;;;;;;CAET,0BACC;EAAA,AAAO,4CAA4C,GAAG;;;;;;;;;;;;;;CAIvD,uBACC;EAAA,IACC;GAAA,AAAO,SAAE,AAAK;cAEd,CADM;GAAA,gCACN;GAAA,AAAO;;;;;;;;;;;;CAGT,iCACC;EAAA,EAAE,AAAK,SAAS;;;;;;;;;;;;CAGjB,6BACS,CACP;EAAA,QACO;EAAA,GAAI,MAAK,MAAM;GAAA,OACrB;GAAW,OAAI;GAAA;GAAA,sBAAoB;IAAA,AAAC,MAAM,iBAAiB,SAAS,OAArD;IAAA,OAAqB;IAArB;IAAA;KAAJ;GAAA,GAAI,OAA8D;IAAA,SAAE;IAAY;IAAA,SAAE;;;;;;;;;;;;;;CAGhG,oCACS,CACP;EAAA,QACI;EAAA;EAAA,sBAAoB;GAAA,AAAC,MAAM,iBAAiB,SAAS,OAArD;GAAA,OAAqB;GAArB;GAAA;IAAJ;EAAA,GAAI,OACH;GAAA,EAAE,KAAK;GAEP;GAAA,EAAE,SAAS,AAA0C;;;;;;;;;;;;;;;;;CAGxD,iCACC;EAAA,AAAO,OAAM,WAA8B,GAAG;;;;;;;;;;;CAG/C,iBAAuD,CACtD;EAAA,QAAQ,GACR;EAAA,GAAI,MAAK,MACA,CACP;GAAA,qBAAqB,gCACrB;GAAA,oBACA;GAAA,GAAI,MAAK,YAAY,KAAK,oBAAoB,oBAAoB,GAAG,IACpE;IAAA,OAAO;KACR;GAAA;IAEF;EAAA,AAAO;;;;;;;;CAIR,qBACQ;EAAA,WAAiB,MAAM,YAAc;GAAA,QAAC,CAAC,AAAgB,cAAM,AAAe;GAA5E;GAAA;;;;;;;;;;;;;;;;;;;;;;;;;CAGR,qBACQ;EAAA,IAAC,KAAK,GAAK;GAAA;GAAI,SAAC,CAAC,AAAM,IAAK,AAAM,GAAM;GAAA;GAAI;GAAA;;;;;;;;;;;;;;;;CAGpD,8BAAmE,CAClE;EAAA,GAAI,OAAM,IACT;GAAA,AAAO;IACR;EAAA,GAAI,EAAC,mBAAW,OAAO,CAAC,mBAAW,KAClC;GAAA,AAAO;IACD;EAAA,gBAAY,YAAY,aAAa,WAAa;GAAA,oBAAa;GAA/D;GAAA;;;;;;;;;;;;;;;;CAIR,mBAAgD,CAC/C;EAAA,GAAI,MAAK,MACR;GAAA,AAAO;IACR;EAAA,QAAQ,OAAiB,GAClB;EAAA,MAAC,KAAK,YAAY,AAAC,KAAK,YAAY,cAAc,OACrD;GAAA,GAAC,MAAK,YAAc;IAAA,QAAC,AAAgB,cAAM,AAAe,gBAAO;IAAjE;IAAA;;GADG;GAAA;;;;;;;;;;;;CAIR,sBACQ;EAAA,SAAK,MAAQ;GAAA,qBAAc;GAA3B;GAAA;;;;;;;;;;;CAGR,6BAAiE,CAChE;EAAA,GAAI,EAAC,qCAAS,GAAG,QAChB;GAAA,AAAO;IACR;EAAA,OAAiB,EAAG,QACpB;EAAA,AAAO;;;;;;;;;;CAGR,eAAkD,CACjD;EAAA,GAAI,MAAK,MACR;GAAA,AAAO;IACR;EAAA,SAAiB,GACjB;EAAA;EAAA,UAAU,eAAe,GAAzB;EAAA,YAAU,YAAV,CAAK;GAAA,QAAL,AAAU,IAAV;GAAA,KACC;GAAA,AAAiB,GAAjB,AAAqB,KAAG,cAAc,GAAG;IAC1C;EAAA,AAAO;;;;;;;CAIR,sBACC;EAAA,AAAO,mBAAW,CACD;GAAA,8BAA2B;GAAA,mBAA3C;GAAA,SAAgB,OAA2B,IAC3C;GAAA,AAAO,SAAE","version":3,"file":"Reflect.js.map","sources":["../../../../../haxe/versions/4.2.3/std/js/_std/haxe/NativeStackTrace.hx","../../../../../haxe/haxe_libraries/genes/0.4.1/github/179cb495c2d785321879e8afe765aa04d639783d/src/genes/Register.hx","../../../../../haxe/versions/4.2.3/std/js/_std/Reflect.hx"],"sourcesContent":["package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : undefined');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a)) js.Syntax.code('a.iterator()') else\n      untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\t@:pure\n\tpublic inline static function hasField(o:Dynamic, field:String):Bool {\n\t\treturn js.lib.Object.prototype.hasOwnProperty.call(o, field);\n\t}\n\n\t@:pure\n\tpublic static function field(o:Dynamic, field:String):Dynamic {\n\t\ttry\n\t\t\treturn o[cast field]\n\t\tcatch (e:Dynamic)\n\t\t\treturn null;\n\t}\n\n\tpublic inline static function setField(o:Dynamic, field:String, value:Dynamic):Void {\n\t\to[cast field] = value;\n\t}\n\n\tpublic static function getProperty(o:Dynamic, field:String):Dynamic\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\treturn if (o == null) __define_feature__(\"Reflect.getProperty\",\n\t\t\t\tnull) else if (o.__properties__ && (tmp = o.__properties__[\"get_\" + field])) o[tmp]() else o[field];\n\t\t}\n\n\tpublic static function setProperty(o:Dynamic, field:String, value:Dynamic):Void\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\tif (o.__properties__ && (tmp = o.__properties__[\"set_\" + field]))\n\t\t\t\to[tmp](value)\n\t\t\telse\n\t\t\t\to[field] = __define_feature__(\"Reflect.setProperty\", value);\n\t\t}\n\n\tpublic inline static function callMethod(o:Dynamic, func:haxe.Constraints.Function, args:Array<Dynamic>):Dynamic {\n\t\treturn (cast func : js.lib.Function).apply(o, args);\n\t}\n\n\tpublic static function fields(o:Dynamic):Array<String> {\n\t\tvar a = [];\n\t\tif (o != null)\n\t\t\tuntyped {\n\t\t\t\tvar hasOwnProperty = js.lib.Object.prototype.hasOwnProperty;\n\t\t\t\tjs.Syntax.code(\"for( var f in o ) {\");\n\t\t\t\tif (f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f))\n\t\t\t\t\ta.push(f);\n\t\t\t\tjs.Syntax.code(\"}\");\n\t\t\t}\n\t\treturn a;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isFunction(f:Dynamic):Bool {\n\t\treturn js.Syntax.typeof(f) == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>(a:T, b:T):Int {\n\t\treturn (a == b) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods(f1:Dynamic, f2:Dynamic):Bool {\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\t\tif (!isFunction(f1) || !isFunction(f2))\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isObject(v:Dynamic):Bool {\n\t\tif (v == null)\n\t\t\treturn false;\n\t\tvar t = js.Syntax.typeof(v);\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null))\n\t\t\t|| (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue(v:Dynamic):Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField(o:Dynamic, field:String):Bool {\n\t\tif (!hasField(o, field))\n\t\t\treturn false;\n\t\tjs.Syntax.delete(o, field);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>(o:Null<T>):Null<T> {\n\t\tif (o == null)\n\t\t\treturn null;\n\t\tvar o2:Dynamic = {};\n\t\tfor (f in Reflect.fields(o))\n\t\t\tReflect.setField(o2, f, Reflect.field(o, f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function(f:Array<Dynamic>->Void):Dynamic {})\n\tpublic static function makeVarArgs(f:Array<Dynamic>->Dynamic):Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(js.Syntax.code(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n}\n"]}