{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"UnicodeString.js.map","sources":["../../../../../haxe/versions/4.1.1/std/haxe/iterators/StringKeyValueIteratorUnicode.hx","../../../../../haxe/versions/4.1.1/std/haxe/iterators/StringIteratorUnicode.hx","../../../../../haxe/versions/4.1.1/std/js/_std/haxe/Exception.hx","../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../haxe/versions/4.1.1/std/js/_std/HxOverrides.hx","../../../../../haxe/versions/4.1.1/std/UnicodeString.hx","../../../../../haxe/versions/4.1.1/std/StringTools.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator can be used to iterate across strings in a cross-platform\n\tway. It handles surrogate pairs on platforms that require it. On each\n\titeration, it returns the next character offset as key and the next\n\tcharacter code as value.\n\n\tNote that in the general case, because of surrogate pairs, the key values\n\tshould not be used as offsets for various String API operations. For the\n\tsame reason, the last key value returned might be less than `s.length - 1`.\n**/\nclass StringKeyValueIteratorUnicode {\n\tvar byteOffset = 0;\n\tvar charOffset = 0;\n\tvar s:String;\n\n\t/**\n\t\tCreate a new `StringKeyValueIteratorUnicode` over String `s`.\n\t**/\n\tpublic inline function new(s:String) {\n\t\tthis.s = s;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\tpublic inline function hasNext() {\n\t\treturn byteOffset < s.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t@:access(StringTools)\n\tpublic inline function next() {\n\t\t#if utf16\n\t\tvar c = StringTools.utf16CodePointAt(s, byteOffset++);\n\t\tif (c >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\tbyteOffset++;\n\t\t}\n\t\treturn {key: charOffset++, value: c};\n\t\t#else\n\t\treturn {key: charOffset++, value: StringTools.fastCodeAt(s, byteOffset++)};\n\t\t#end\n\t}\n\n\t/**\n\t\tConvenience function which can be used as a static extension.\n\t**/\n\tstatic public inline function unicodeKeyValueIterator(s:String) {\n\t\treturn new StringKeyValueIteratorUnicode(s);\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator can be used to iterate across strings in a cross-platform\n\tway. It handles surrogate pairs on platforms that require it. On each\n\titeration, it returns the next character code.\n\n\tNote that this has different semantics than a standard for-loop over the\n\tString's length due to the fact that it deals with surrogate pairs.\n**/\nclass StringIteratorUnicode {\n\tvar offset = 0;\n\tvar s:String;\n\n\t/**\n\t\tCreate a new `StringIteratorUnicode` over String `s`.\n\t**/\n\tpublic inline function new(s:String) {\n\t\tthis.s = s;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\tpublic inline function hasNext() {\n\t\treturn offset < s.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t@:access(StringTools)\n\tpublic inline function next() {\n\t\t#if utf16\n\t\tvar c = StringTools.utf16CodePointAt(s, offset++);\n\t\tif (c >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\toffset++;\n\t\t}\n\t\treturn c;\n\t\t#else\n\t\treturn StringTools.fastCodeAt(s, offset++);\n\t\t#end\n\t}\n\n\t/**\n\t\tConvenience function which can be used as a static extension.\n\t**/\n\tstatic public inline function unicodeIterator(s:String) {\n\t\treturn new StringIteratorUnicode(s);\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.io.Bytes;\nimport haxe.io.Encoding;\nimport haxe.iterators.StringIteratorUnicode;\nimport haxe.iterators.StringKeyValueIteratorUnicode;\n\n/**\n\tThis abstract provides consistent cross-target unicode support.\n\n\t@see https://haxe.org/manual/std-UnicodeString.html\n**/\n@:forward\n@:access(StringTools)\nabstract UnicodeString(String) from String to String {\n\t/**\n\t\tTells if `b` is a correctly encoded UTF8 byte sequence.\n\t**/\n\tstatic public function validate(b:Bytes, encoding:Encoding):Bool {\n\t\tswitch (encoding) {\n\t\t\tcase RawNative:\n\t\t\t\tthrow \"UnicodeString.validate: RawNative encoding is not supported\";\n\t\t\tcase UTF8:\n\t\t\t\tvar data = b.getData();\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar max = b.length;\n\t\t\t\twhile (pos < max) {\n\t\t\t\t\tvar c:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\tif (c < 0x80) {} else if (c < 0xC2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (c < 0xE0) {\n\t\t\t\t\t\tif (pos + 1 > max) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c2:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\t\tif (c2 < 0x80 || c2 > 0xBF) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c < 0xF0) {\n\t\t\t\t\t\tif (pos + 2 > max) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c2:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\t\tif (c == 0xE0) {\n\t\t\t\t\t\t\tif (c2 < 0xA0 || c2 > 0xBF)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (c2 < 0x80 || c2 > 0xBF)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c3:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\t\tif (c3 < 0x80 || c3 > 0xBF) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc = (c << 16) | (c2 << 8) | c3;\n\t\t\t\t\t\tif (0xEDA080 <= c && c <= 0xEDBFBF) { // surrogate pairs\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c > 0xF4) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pos + 3 > max) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c2:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\t\tif (c == 0xF0) {\n\t\t\t\t\t\t\tif (c2 < 0x90 || c2 > 0xBF)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else if (c == 0xF4) {\n\t\t\t\t\t\t\tif (c2 < 0x80 || c2 > 0x8F)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (c2 < 0x80 || c2 > 0xBF)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c3:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\t\tif (c3 < 0x80 || c3 > 0xBF) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar c4:Int = Bytes.fastGet(data, pos++);\n\t\t\t\t\t\tif (c4 < 0x80 || c4 > 0xBF) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t#if target.unicode\n\t/**\n\t\tCreates an instance of UnicodeString.\n\t**/\n\tpublic inline function new(string:String):Void {\n\t\tthis = string;\n\t}\n\n\t/**\n\t\tReturns an iterator of the unicode code points.\n\t**/\n\tpublic inline function iterator():StringIteratorUnicode {\n\t\treturn new StringIteratorUnicode(this);\n\t}\n\n\t/**\n\t\tReturns an iterator of the code point indices and unicode code points.\n\t**/\n\tpublic inline function keyValueIterator():StringKeyValueIteratorUnicode {\n\t\treturn new StringKeyValueIteratorUnicode(this);\n\t}\n\n\t#if target.utf16\n\t/**\n\t\tThe number of characters in `this` String.\n\t**/\n\tpublic var length(get, never):Int;\n\n\t/**\n\t\tReturns the character at position `index` of `this` String.\n\n\t\tIf `index` is negative or exceeds `this.length`, the empty String `\"\"`\n\t\tis returned.\n\t**/\n\tpublic function charAt(index:Int):String {\n\t\tif (index < 0)\n\t\t\treturn '';\n\t\tvar unicodeOffset = 0;\n\t\tvar nativeOffset = 0;\n\t\twhile (nativeOffset < this.length) {\n\t\t\tvar c = StringTools.utf16CodePointAt(this, nativeOffset++);\n\t\t\tif (unicodeOffset == index) {\n\t\t\t\treturn String.fromCharCode(c);\n\t\t\t}\n\t\t\tif (c >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\t\tnativeOffset++;\n\t\t\t}\n\t\t\tunicodeOffset++;\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of `this` String.\n\n\t\tIf `index` is negative or exceeds `this.length`, `null` is returned.\n\t**/\n\tpublic function charCodeAt(index:Int):Null<Int> {\n\t\tif (index < 0)\n\t\t\treturn null;\n\t\tvar unicodeOffset = 0;\n\t\tvar nativeOffset = 0;\n\t\twhile (nativeOffset < this.length) {\n\t\t\tvar c = StringTools.utf16CodePointAt(this, nativeOffset++);\n\t\t\tif (unicodeOffset == index) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tif (c >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\t\tnativeOffset++;\n\t\t\t}\n\t\t\tunicodeOffset++;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns the position of the leftmost occurrence of `str` within `this`\n\t\tString.\n\n\t\tIf `startIndex` is given, the search is performed within the substring\n\t\tof `this` String starting from `startIndex` (if `startIndex` is posivite\n\t\tor 0) or `max(this.length + startIndex, 0)` (if `startIndex` is negative).\n\n\t\tIf `startIndex` exceeds `this.length`, -1 is returned.\n\n\t\tOtherwise the search is performed within `this` String. In either case,\n\t\tthe returned position is relative to the beginning of `this` String.\n\n\t\tIf `str` cannot be found, -1 is returned.\n\t**/\n\tpublic function indexOf(str:String, ?startIndex:Int):Int {\n\t\tif (startIndex == null) {\n\t\t\tstartIndex = 0;\n\t\t} else {\n\t\t\tif (startIndex < 0) {\n\t\t\t\tstartIndex = (this : UnicodeString).length + startIndex;\n\t\t\t}\n\t\t}\n\n\t\tvar unicodeOffset = 0;\n\t\tvar nativeOffset = 0;\n\t\tvar matchingOffset = 0;\n\t\tvar result = -1;\n\t\twhile (nativeOffset <= this.length) {\n\t\t\tvar c = StringTools.utf16CodePointAt(this, nativeOffset);\n\n\t\t\tif (unicodeOffset >= startIndex) {\n\t\t\t\tvar c2 = StringTools.utf16CodePointAt(str, matchingOffset);\n\t\t\t\tif (c == c2) {\n\t\t\t\t\tif (matchingOffset == 0) {\n\t\t\t\t\t\tresult = unicodeOffset;\n\t\t\t\t\t}\n\t\t\t\t\tmatchingOffset++;\n\t\t\t\t\tif (c2 >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\t\t\t\tmatchingOffset++;\n\t\t\t\t\t}\n\t\t\t\t\tif (matchingOffset == str.length) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else if (matchingOffset != 0) {\n\t\t\t\t\tresult = -1;\n\t\t\t\t\tmatchingOffset = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnativeOffset++;\n\t\t\tif (c >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\t\tnativeOffset++;\n\t\t\t}\n\t\t\tunicodeOffset++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the position of the rightmost occurrence of `str` within `this`\n\t\tString.\n\n\t\tIf `startIndex` is given, the search is performed within the substring\n\t\tof `this` String from 0 to `startIndex + str.length`. Otherwise the search\n\t\tis performed within `this` String. In either case, the returned position\n\t\tis relative to the beginning of `this` String.\n\n\t\tIf `str` cannot be found, -1 is returned.\n\t**/\n\tpublic function lastIndexOf(str:String, ?startIndex:Int):Int {\n\t\tif (startIndex == null) {\n\t\t\tstartIndex = this.length;\n\t\t} else if (startIndex < 0) {\n\t\t\tstartIndex = 0;\n\t\t}\n\n\t\tvar unicodeOffset = 0;\n\t\tvar nativeOffset = 0;\n\t\tvar result = -1;\n\t\tvar lastIndex = -1;\n\t\tvar matchingOffset = 0;\n\t\tvar strUnicodeLength = (str : UnicodeString).length;\n\t\twhile (nativeOffset < this.length && unicodeOffset < startIndex + strUnicodeLength) {\n\t\t\tvar c = StringTools.utf16CodePointAt(this, nativeOffset);\n\n\t\t\tvar c2 = StringTools.utf16CodePointAt(str, matchingOffset);\n\t\t\tif (c == c2) {\n\t\t\t\tif (matchingOffset == 0) {\n\t\t\t\t\tlastIndex = unicodeOffset;\n\t\t\t\t}\n\t\t\t\tmatchingOffset++;\n\t\t\t\tif (c2 >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\t\t\tmatchingOffset++;\n\t\t\t\t}\n\t\t\t\tif (matchingOffset == str.length) {\n\t\t\t\t\tresult = lastIndex;\n\t\t\t\t\tlastIndex = -1;\n\t\t\t\t}\n\t\t\t} else if (matchingOffset != 0) {\n\t\t\t\tlastIndex = -1;\n\t\t\t\tmatchingOffset = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnativeOffset++;\n\t\t\tif (c >= StringTools.MIN_SURROGATE_CODE_POINT) {\n\t\t\t\tnativeOffset++;\n\t\t\t}\n\t\t\tunicodeOffset++;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t\tReturns `len` characters of `this` String, starting at position `pos`.\n\n\t\tIf `len` is omitted, all characters from position `pos` to the end of\n\t\t`this` String are included.\n\n\t\tIf `pos` is negative, its value is calculated from the end of `this`\n\t\tString by `this.length + pos`. If this yields a negative value, 0 is\n\t\tused instead.\n\n\t\tIf the calculated position + `len` exceeds `this.length`, the characters\n\t\tfrom that position to the end of `this` String are returned.\n\n\t\tIf `len` is negative, the result is unspecified.\n\t**/\n\tpublic function substr(pos:Int, ?len:Int):String {\n\t\tif (pos < 0) {\n\t\t\tpos = (this : UnicodeString).length + pos;\n\t\t\tif (pos < 0) {\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t}\n\t\tif (len != null) {\n\t\t\tif (len < 0) {\n\t\t\t\tlen = (this : UnicodeString).length + len;\n\t\t\t}\n\t\t\tif (len <= 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\tvar unicodeOffset = 0;\n\t\tvar nativeOffset = 0;\n\t\tvar fromOffset = -1;\n\t\tvar subLength = 0;\n\t\twhile (nativeOffset < this.length) {\n\t\t\tvar c = StringTools.utf16CodePointAt(this, nativeOffset);\n\n\t\t\tif (unicodeOffset >= pos) {\n\t\t\t\tif (fromOffset < 0) {\n\t\t\t\t\tif (len == null) {\n\t\t\t\t\t\treturn this.substr(nativeOffset);\n\t\t\t\t\t}\n\t\t\t\t\tfromOffset = nativeOffset;\n\t\t\t\t}\n\t\t\t\tsubLength++;\n\t\t\t\tif (subLength >= len) {\n\t\t\t\t\tvar lastOffset = (c < StringTools.MIN_SURROGATE_CODE_POINT ? nativeOffset : nativeOffset + 1);\n\t\t\t\t\treturn this.substr(fromOffset, lastOffset - fromOffset + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnativeOffset += (c >= StringTools.MIN_SURROGATE_CODE_POINT ? 2 : 1);\n\t\t\tunicodeOffset++;\n\t\t}\n\t\treturn (fromOffset < 0 ? \"\" : this.substr(fromOffset));\n\t}\n\n\t/**\n\t\tReturns the part of `this` String from `startIndex` to but not including `endIndex`.\n\n\t\tIf `startIndex` or `endIndex` are negative, 0 is used instead.\n\n\t\tIf `startIndex` exceeds `endIndex`, they are swapped.\n\n\t\tIf the (possibly swapped) `endIndex` is omitted or exceeds\n\t\t`this.length`, `this.length` is used instead.\n\n\t\tIf the (possibly swapped) `startIndex` exceeds `this.length`, the empty\n\t\tString `\"\"` is returned.\n\t**/\n\tpublic function substring(startIndex:Int, ?endIndex:Int):String {\n\t\tif (startIndex < 0) {\n\t\t\tstartIndex = 0;\n\t\t}\n\t\tif (endIndex != null) {\n\t\t\tif (endIndex < 0) {\n\t\t\t\tendIndex = 0;\n\t\t\t}\n\t\t\tif (startIndex == endIndex) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\tif (startIndex > endIndex) {\n\t\t\t\tvar tmp = startIndex;\n\t\t\t\tstartIndex = endIndex;\n\t\t\t\tendIndex = tmp;\n\t\t\t}\n\t\t}\n\n\t\tvar unicodeOffset = 0;\n\t\tvar nativeOffset = 0;\n\t\tvar fromOffset = -1;\n\t\tvar subLength = 0;\n\t\twhile (nativeOffset < this.length) {\n\t\t\tvar c = StringTools.utf16CodePointAt(this, nativeOffset);\n\n\t\t\tif (startIndex <= unicodeOffset) {\n\t\t\t\tif (fromOffset < 0) {\n\t\t\t\t\tif (endIndex == null) {\n\t\t\t\t\t\treturn this.substr(nativeOffset);\n\t\t\t\t\t}\n\t\t\t\t\tfromOffset = nativeOffset;\n\t\t\t\t}\n\t\t\t\tsubLength++;\n\t\t\t\tif (subLength >= endIndex - startIndex) {\n\t\t\t\t\tvar lastOffset = (c < StringTools.MIN_SURROGATE_CODE_POINT ? nativeOffset : nativeOffset + 1);\n\t\t\t\t\treturn this.substr(fromOffset, lastOffset - fromOffset + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnativeOffset += (c >= StringTools.MIN_SURROGATE_CODE_POINT ? 2 : 1);\n\t\t\tunicodeOffset++;\n\t\t}\n\t\treturn (fromOffset < 0 ? \"\" : this.substr(fromOffset));\n\t}\n\n\tfunction get_length():Int {\n\t\tvar l = 0;\n\t\tfor (c in new StringIteratorUnicode(this)) {\n\t\t\tl++;\n\t\t}\n\t\treturn l;\n\t}\n\t#end\n\t#end\n\t@:op(A < B) static function lt(a:UnicodeString, b:UnicodeString):Bool;\n\n\t@:op(A <= B) static function lte(a:UnicodeString, b:UnicodeString):Bool;\n\n\t@:op(A > B) static function gt(a:UnicodeString, b:UnicodeString):Bool;\n\n\t@:op(A >= B) static function gte(a:UnicodeString, b:UnicodeString):Bool;\n\n\t@:op(A == B) static function eq(a:UnicodeString, b:UnicodeString):Bool;\n\n\t@:op(A != B) static function neq(a:UnicodeString, b:UnicodeString):Bool;\n\n\t@:op(A + B) static function add(a:UnicodeString, b:UnicodeString):UnicodeString;\n\n\t@:op(A += B) static function assignAdd(a:UnicodeString, b:UnicodeString):UnicodeString;\n\n\t@:op(A + B) @:commutative static function add(a:UnicodeString, b:String):UnicodeString;\n\n\t@:op(A += B) @:commutative static function assignAdd(a:UnicodeString, b:String):UnicodeString;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.StringIterator;\nimport haxe.iterators.StringKeyValueIterator;\n\n#if cpp\nusing cpp.NativeString;\n#end\n\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlEncode(s:String):String {\n\t\t#if flash\n\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\n\t\t#elseif cs\n\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#elseif hl\n\t\tvar len = 0;\n\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\n\t\treturn @:privateAccess String.__alloc__(b, len);\n\t\t#elseif lua\n\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\n\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function(c) {\n\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\n\t\t});\n\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\n\t\treturn s;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static function postProcessUrlEncode(s:String):String {\n\t\tvar ret = new StringBuf();\n\t\tvar i = 0, len = s.length;\n\t\twhile (i < len) {\n\t\t\tswitch (_charAt(s, i++)) {\n\t\t\t\tcase '+'.code:\n\t\t\t\t\tret.add('%20');\n\t\t\t\tcase '%'.code if (i <= len - 2):\n\t\t\t\t\tvar c1 = _charAt(s, i++), c2 = _charAt(s, i++);\n\t\t\t\t\tswitch [c1, c2] {\n\t\t\t\t\t\tcase ['2'.code, '1'.code]:\n\t\t\t\t\t\t\tret.addChar('!'.code);\n\t\t\t\t\t\tcase ['2'.code, '7'.code]:\n\t\t\t\t\t\t\tret.addChar('\\''.code);\n\t\t\t\t\t\tcase ['2'.code, '8'.code]:\n\t\t\t\t\t\t\tret.addChar('('.code);\n\t\t\t\t\t\tcase ['2'.code, '9'.code]:\n\t\t\t\t\t\t\tret.addChar(')'.code);\n\t\t\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\n\t\t\t\t\t\t\tret.addChar('~'.code);\n\t\t\t\t\t\tcase _:\n\t\t\t\t\t\t\tret.addChar('%'.code);\n\t\t\t\t\t\t\tret.addChar(cast c1);\n\t\t\t\t\t\t\tret.addChar(cast c2);\n\t\t\t\t\t}\n\t\t\t\tcase var chr:\n\t\t\t\t\tret.addChar(cast chr);\n\t\t\t}\n\t\t}\n\t\treturn ret.toString();\n\t}\n\t#end\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlDecode(s:String):String {\n\t\t#if flash\n\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\ttry\n\t\t\treturn java.net.URLDecoder.decode(s, \"UTF-8\")\n\t\tcatch (e:Dynamic)\n\t\t\tthrow e;\n\t\t#elseif cs\n\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#elseif hl\n\t\tvar len = 0;\n\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\n\t\treturn @:privateAccess String.__alloc__(b, len);\n\t\t#elseif lua\n\t\ts = lua.NativeStringTools.gsub(s, \"+\", \" \");\n\t\ts = lua.NativeStringTools.gsub(s, \"%%(%x%x)\", function(h) {\n\t\t\treturn lua.NativeStringTools.char(lua.Lua.tonumber(h, 16));\n\t\t});\n\t\ts = lua.NativeStringTools.gsub(s, \"\\r\\n\", \"\\n\");\n\t\treturn s;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape(s:String, ?quotes:Bool):String {\n\t\tvar buf = new StringBuf();\n\t\tfor (code in #if neko iterator(s) #else new haxe.iterators.StringIteratorUnicode(s) #end) {\n\t\t\tswitch (code) {\n\t\t\t\tcase '&'.code:\n\t\t\t\t\tbuf.add(\"&amp;\");\n\t\t\t\tcase '<'.code:\n\t\t\t\t\tbuf.add(\"&lt;\");\n\t\t\t\tcase '>'.code:\n\t\t\t\t\tbuf.add(\"&gt;\");\n\t\t\t\tcase '\"'.code if (quotes):\n\t\t\t\t\tbuf.add(\"&quot;\");\n\t\t\t\tcase '\\''.code if (quotes):\n\t\t\t\t\tbuf.add(\"&#039;\");\n\t\t\t\tcase _:\n\t\t\t\t\tbuf.addChar(code);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape(s:String):String {\n\t\treturn s.split(\"&gt;\")\n\t\t\t.join(\">\")\n\t\t\t.split(\"&lt;\")\n\t\t\t.join(\"<\")\n\t\t\t.split(\"&quot;\")\n\t\t\t.join('\"')\n\t\t\t.split(\"&#039;\")\n\t\t\t.join(\"'\")\n\t\t\t.split(\"&amp;\")\n\t\t\t.join(\"&\");\n\t}\n\n\t/**\n\t\tReturns `true` if `s` contains `value` and  `false` otherwise.\n\n\t\tWhen `value` is `null`, the result is unspecified.\n\t**/\n\tpublic static inline function contains(s:String, value:String):Bool {\n\t\treturn s.indexOf(value) != -1;\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python) inline #end function startsWith(s:String, start:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length < start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor (i in 0...start.length)\n\t\t\tif (p0.at(i) != p1.at(i))\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.startswith(s, start);\n\t\t#else\n\t\treturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python) inline #end function endsWith(s:String, end:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.endswith(s, end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace(s:String, pos:Int):Bool {\n\t\t#if (python || lua)\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length)\n\t\t\treturn false;\n\t\t#end\n\t\tvar c = s.charCodeAt(pos);\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function ltrim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile (r < l && isSpace(s, r)) {\n\t\t\tr++;\n\t\t}\n\t\tif (r > 0)\n\t\t\treturn s.substr(r, l - r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function rtrim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile (r < l && isSpace(s, l - r - 1)) {\n\t\t\tr++;\n\t\t}\n\t\tif (r > 0) {\n\t\t\treturn s.substr(0, l - r);\n\t\t} else {\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n\t**/\n\tpublic #if (cs || java) inline #end static function trim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn (cast s : java.NativeString).trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad(s:String, c:String, l:Int):String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tl -= s.length;\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\tbuf.add(s);\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad(s:String, c:String, l:Int):String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tbuf.add(s);\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\n\t\tremains unchanged.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace(s:String, sub:String, by:String):String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn (cast s : java.NativeString).replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.\n\t**/\n\tpublic static function hex(n:Int, ?digits:Int) {\n\t\t#if flash\n\t\tvar n:UInt = n;\n\t\tvar s:String = untyped n.toString(16);\n\t\ts = s.toUpperCase();\n\t\t#else\n\t\tvar s = \"\";\n\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\tdo {\n\t\t\ts = hexChars.charAt(n & 15) + s;\n\t\t\tn >>>= 4;\n\t\t} while (n > 0);\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif (digits != null)\n\t\t\twhile (s.length < digits)\n\t\t\t\ts = \"0\" + s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn (cast(index, UInt) < s.length) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (cast s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t#if lua_vanilla\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\n\t\t#else\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an iterator of the char codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.\n\t**/\n\tpublic static inline function iterator(s:String):StringIterator {\n\t\treturn new StringIterator(s);\n\t}\n\n\t/**\n\t\tReturns an iterator of the char indexes and codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different of runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.\n\t**/\n\tpublic static inline function keyValueIterator(s:String):StringKeyValueIterator {\n\t\treturn new StringKeyValueIterator(s);\n\t}\n\n\t/**\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t**/\n\t@:noUsing public static inline function isEof(c:Int):Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua || eval)\n\t\treturn c == null;\n\t\t#elseif (cs || java || python)\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead.')\n\tpublic static function quoteUnixArg(argument:String):String {\n\t\treturn inline haxe.SysTools.quoteUnixArg(argument);\n\t}\n\n\t/**\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\n\tpublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```haxe\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead.')\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\n\t\treturn inline haxe.SysTools.quoteWinArg(argument, escapeMetaCharacters);\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16\n\t\treturn (cast str : java.NativeString).charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\", \"url_encode\", 1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\", \"url_decode\", 1);\n\t#end\n\n\t#if utf16\n\tstatic inline var MIN_SURROGATE_CODE_POINT = 65536;\n\n\tstatic inline function utf16CodePointAt(s:String, index:Int):Int {\n\t\tvar c = StringTools.fastCodeAt(s, index);\n\t\tif (c >= 0xD800 && c <= 0xDBFF) {\n\t\t\tc = ((c - 0xD7C0) << 10) | (StringTools.fastCodeAt(s, index + 1) & 0x3FF);\n\t\t}\n\t\treturn c;\n\t}\n\t#end\n}\n"]}