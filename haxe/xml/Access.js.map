{"sourceRoot":"","names":[],"mappings":"QA4BA;QCDA;QCtBA;QCAA;QC4EA,KAtDK;QCUL;QCXU;;ACFF;AAAA;CAEP,4BAA4C,CAC3C;EAAA,QAAQ,oBAAmB,aAC3B;EAAA,GAAI,MAAK,MAAM,CACd;GAAA,UAAY;GAAA,GAAI,mBAAiB,cAAjC;IAAA,QAA+C;IAAgB;IAAA;KAAA;MAA/D;IAAA,QAA+D;KAC/D;GAAA,uBAAM,QAAQ,yBAAyB;IAEjC;EAAA,IAAW,cAAX,gBAAW,cAAX;GAAA,+CAAW,cAAX,wCAAW;IAAX;EAAA,YAAW,EAAX;EAAA;;;;;;;;;;;AAID;AAAA;CAEP,4BAA4C,CAC3C;EAAA,GAAI,mBAAiB,cACpB;GAAA,uBAAM,sCAAsC;IAC7C;EAAA,QAAQ,UAAS,MACjB;EAAA,GAAI,MAAK,MACR,CAAM;GAAA;IAAA;KAAN;GAAA,uBAAM,iBAAgB,2BAA2B;IAClD;EAAA,AAAO;;CAIR,mCAAmD,CAClD;EAAA,GAAI,mBAAiB,cACpB;GAAA,uBAAM,sCAAsC;IAC7C;EAAA,UAAS,MAAM,OACf;EAAA,AAAO;;;;;;;;;;;AAID;AAAA;CAEP,4BAA0C,CACzC;EAAA,GAAI,mBAAiB,cACpB;GAAA,uBAAM,sCAAsC;IAC7C;EAAA,AAAO,oBAAY;;;;;;;;;;;AAIb;AAAA;CAEP,4BACC;EAAA,AAAO,2BAAmB;;;;;;;;;;;AAIpB;AAAA;CAEP,4BAAmD,CAClD;EAAA,QAAQ,GACR,AAAU;EAAA,4BAAmB,MAAnB;EAAA,qBAAV;GAAA,SAAU,SACF;GAAA,IAAW,eAAX,gBAAW,eAAX;IAAA,+CAAW,eAAX,wCAAW;KAAX;GAAA,YAAW,GAAlB;GAAA,OAAO;IACR;EAAA,AAAO;;;;;;;;;;;AAQT;AAAA;CACC;;;CAEA,oBACC;EAAA,AAAO;;CAKR;;;CAEA,uBACQ;EAAA,GAAI,mBAAiB,cAAc;GAAA;GAAgB;GAAA;IAAA;KAAA;GAAA;;;CAS3D;;;CAKA;;;CAkBA;;;CAEA,uBACC;EAAA,AAAO;;CAmBR;;;CAEA,wBACC;EAAA,AAAO;;CAgBR;;;CAEA,sBACC;EAAA,AAAO;;CAKR;;;CAEA,sBACC;EAAA,AAAO;;CAaR;;;CAEA,0BACC;EAAA,AAAO;;CAKR;;;CAEA,2BACC;EAAA,AAAO,OAAK;;CAEb,gBACC;EAAA,GAAI,eAAc,gBAAgB,cAAc,aAC/C;GAAA,uBAAM,sBAAsB;IAF9B;EAAA,YAGQ,EAHR;EAAA;;CAMA,4BAAyB,CACf;EAAA;GAAA;IAAT;EAAA,SAAS,kCACT;EAAA,GAAI,EAAC,cACJ,CAAM;GAAA;GAAA;IAAA;IAAA;IAAA;KAAA;MAAA;IAAA;KAAN;GAAA,uBAAM,MAAO;IACd;EAAA,QAAQ,UACR;EAAA,GAAI,eAAc,CACjB;GAAA,QAAQ,UAEJ;GAAA;GAAA,kBAAc,cAAc,cAAc,WAA1C,CAAwE;IAAA;KAAA;MAAxE;IAAA,MAAuD,iBAAiB,gBAAgB;IAAxF;IAAA;KAAJ;GAAA,GAAI,MAA4F,CAC/F;IAAA,GAAI,EAAC,cACJ,CAAO;KAAA;MAAA;OAAA;KAAA;MACR;IAAA,SAAS,UACL;IAAA;IAAA,mBAAe,YAAf,CAA8C;KAAA;MAAA;OAA9C;KAAA,MAA6B,iBAAiB,iBAAiB;KAA/D;KAAA;MAAJ;IAAA,GAAI,QAAqE,CAAC,cACzE,CAAO;KAAA;MAAA;OAAA;KAAA;;KAEH;GAAA;GAAA;IAAA;IAAA;IAAA;KAAA;MAAA;IAAA;KAAN;GAAA,uBAAM,OAAO;IAEd;EAAA,GAAI,eAAc,cAAc,cAAc,WAC7C,CAAM;GAAA;GAAA;IAAA;IAAA;IAAA;KAAA;MAAA;IAAA;KAAN;GAAA,uBAAM,MAAO;IACP;EAAA;GAAA;IAAA;EAAA;;CAGR,4BAAyB,CAChB;EAAA,aACR,AAAU;EAAA;GAAA;IAAA;EAAA;EAAA,8BAAV;EAAA;GAAA,+BACC;GAAA,kBAAM;IACP;EAAA,AAAO","version":3,"file":"Access.js.map","sources":["../../../../../../../haxe/versions/4.1.5/std/haxe/xml/Printer.hx","../../../../../../../haxe/versions/4.1.5/std/haxe/iterators/ArrayIterator.hx","../../../../../../../haxe/versions/4.1.5/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.1.5/std/Xml.hx","../../../../../../../haxe/versions/4.1.5/std/StringTools.hx","../../../../../../../haxe/versions/4.1.5/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.1.5/std/haxe/xml/Access.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.xml;\n\n/**\n\tThis class provides utility methods to convert Xml instances to\n\tString representation.\n**/\nclass Printer {\n\t/**\n\t\tConvert `Xml` to string representation.\n\n\t\tSet `pretty` to `true` to prettify the result.\n\t**/\n\tstatic public function print(xml:Xml, ?pretty = false) {\n\t\tvar printer = new Printer(pretty);\n\t\tprinter.writeNode(xml, \"\");\n\t\treturn printer.output.toString();\n\t}\n\n\tvar output:StringBuf;\n\tvar pretty:Bool;\n\n\tfunction new(pretty) {\n\t\toutput = new StringBuf();\n\t\tthis.pretty = pretty;\n\t}\n\n\tfunction writeNode(value:Xml, tabs:String) {\n\t\tswitch (value.nodeType) {\n\t\t\tcase CData:\n\t\t\t\twrite(tabs + \"<![CDATA[\");\n\t\t\t\twrite(value.nodeValue);\n\t\t\t\twrite(\"]]>\");\n\t\t\t\tnewline();\n\t\t\tcase Comment:\n\t\t\t\tvar commentContent:String = value.nodeValue;\n\t\t\t\tcommentContent = ~/[\\n\\r\\t]+/g.replace(commentContent, \"\");\n\t\t\t\tcommentContent = \"<!--\" + commentContent + \"-->\";\n\t\t\t\twrite(tabs);\n\t\t\t\twrite(StringTools.trim(commentContent));\n\t\t\t\tnewline();\n\t\t\tcase Document:\n\t\t\t\tfor (child in value) {\n\t\t\t\t\twriteNode(child, tabs);\n\t\t\t\t}\n\t\t\tcase Element:\n\t\t\t\twrite(tabs + \"<\");\n\t\t\t\twrite(value.nodeName);\n\t\t\t\tfor (attribute in value.attributes()) {\n\t\t\t\t\twrite(\" \" + attribute + \"=\\\"\");\n\t\t\t\t\twrite(StringTools.htmlEscape(value.get(attribute), true));\n\t\t\t\t\twrite(\"\\\"\");\n\t\t\t\t}\n\t\t\t\tif (hasChildren(value)) {\n\t\t\t\t\twrite(\">\");\n\t\t\t\t\tnewline();\n\t\t\t\t\tfor (child in value) {\n\t\t\t\t\t\twriteNode(child, pretty ? tabs + \"\\t\" : tabs);\n\t\t\t\t\t}\n\t\t\t\t\twrite(tabs + \"</\");\n\t\t\t\t\twrite(value.nodeName);\n\t\t\t\t\twrite(\">\");\n\t\t\t\t\tnewline();\n\t\t\t\t} else {\n\t\t\t\t\twrite(\"/>\");\n\t\t\t\t\tnewline();\n\t\t\t\t}\n\t\t\tcase PCData:\n\t\t\t\tvar nodeValue:String = value.nodeValue;\n\t\t\t\tif (nodeValue.length != 0) {\n\t\t\t\t\twrite(tabs + StringTools.htmlEscape(nodeValue));\n\t\t\t\t\tnewline();\n\t\t\t\t}\n\t\t\tcase ProcessingInstruction:\n\t\t\t\twrite(\"<?\" + value.nodeValue + \"?>\");\n\t\t\t\tnewline();\n\t\t\tcase DocType:\n\t\t\t\twrite(\"<!DOCTYPE \" + value.nodeValue + \">\");\n\t\t\t\tnewline();\n\t\t}\n\t}\n\n\tinline function write(input:String) {\n\t\toutput.add(input);\n\t}\n\n\tinline function newline() {\n\t\tif (pretty) {\n\t\t\toutput.add(\"\\n\");\n\t\t}\n\t}\n\n\tfunction hasChildren(value:Xml):Bool {\n\t\tfor (child in value) {\n\t\t\tswitch (child.nodeType) {\n\t\t\t\tcase Element, PCData:\n\t\t\t\t\treturn true;\n\t\t\t\tcase CData, Comment:\n\t\t\t\t\tif (StringTools.ltrim(child.nodeValue).length != 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\tcase _:\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n","/*\n * Copyright (C)2005-2018 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator is used only when `Array<T>` is passed to `Iterable<T>`\n**/\nclass ArrayIterator<T> {\n\tfinal array:Array<T>;\n\tvar current:Int = 0;\n\n\t/**\n\t\tCreate a new `ArrayIterator`.\n\t**/\n\t#if !hl inline #end\n\tpublic function new(array:Array<T>) {\n\t\tthis.array = array;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\t#if !hl inline #end\n\tpublic function hasNext() {\n\t\treturn current < array.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t#if !hl inline #end\n\tpublic function next() {\n\t\treturn array[current++];\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tXml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nenum abstract XmlType(Int) {\n\t/**\n\t\tRepresents an XML element type.\n\t**/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n\t**/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n\t**/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n\t**/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n\t**/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n\t**/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n\t**/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nclass Xml {\n\t/**\n\t\tXML element type.\n\t**/\n\tstatic public var Element(default, never) = XmlType.Element;\n\n\t/**\n\t\tXML parsed character data type.\n\t**/\n\tstatic public var PCData(default, never) = XmlType.PCData;\n\n\t/**\n\t\tXML character data type.\n\t**/\n\tstatic public var CData(default, never) = XmlType.CData;\n\n\t/**\n\t\tXML comment type.\n\t**/\n\tstatic public var Comment(default, never) = XmlType.Comment;\n\n\t/**\n\t\tXML doctype element type.\n\t**/\n\tstatic public var DocType(default, never) = XmlType.DocType;\n\n\t/**\n\t\tXML processing instruction type.\n\t**/\n\tstatic public var ProcessingInstruction(default, never) = XmlType.ProcessingInstruction;\n\n\t/**\n\t\tXML document type.\n\t**/\n\tstatic public var Document(default, never) = XmlType.Document;\n\n\t/**\n\t\tParses the String into an Xml document.\n\t**/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n\t**/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n\t**/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n\t**/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n\t**/\n\tpublic var parent(default, null):Xml;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createElement(name:String):Xml {\n\t\tvar xml = new Xml(Element);\n\t\txml.nodeName = name;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createPCData(data:String):Xml {\n\t\tvar xml = new Xml(PCData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createCData(data:String):Xml {\n\t\tvar xml = new Xml(CData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createComment(data:String):Xml {\n\t\tvar xml = new Xml(Comment);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocType(data:String):Xml {\n\t\tvar xml = new Xml(DocType);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createProcessingInstruction(data:String):Xml {\n\t\tvar xml = new Xml(ProcessingInstruction);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocument():Xml {\n\t\treturn new Xml(Document);\n\t}\n\n\t/**\n\t\tGet the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function get(att:String):String {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap[att];\n\t}\n\n\t/**\n\t\tSet the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function set(att:String, value:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.set(att, value);\n\t}\n\n\t/**\n\t\tRemoves an attribute for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function remove(att:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.remove(att);\n\t}\n\n\t/**\n\t\tTells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function exists(att:String):Bool {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.exists(att);\n\t}\n\n\t/**\n\t\tReturns an `Iterator` on all the attribute names.\n\t**/\n\tpublic function attributes():Iterator<String> {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.keys();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elements():Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [for (child in children) if (child.nodeType == Element) child];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elementsNamed(name:String):Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [\n\t\t\tfor (child in children)\n\t\t\t\tif (child.nodeType == Element && child.nodeName == name) child\n\t\t];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns the first child node.\n\t**/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.\n\t**/\n\tpublic function firstElement():Xml {\n\t\tensureElementType();\n\t\tfor (child in children) {\n\t\t\tif (child.nodeType == Element) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tAdds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function addChild(x:Xml):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.removeChild(x);\n\t\t}\n\t\tchildren.push(x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tRemoves a child from the Document or Element.\n\t\tReturns true if the child was successfuly removed.\n\t**/\n\tpublic function removeChild(x:Xml):Bool {\n\t\tensureElementType();\n\t\tif (children.remove(x)) {\n\t\t\tx.parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tInserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function insertChild(x:Xml, pos:Int):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.children.remove(x);\n\t\t}\n\t\tchildren.insert(pos, x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tReturns a String representation of the Xml node.\n\t**/\n\tpublic #if !cppia inline #end function toString():String {\n\t\treturn haxe.xml.Printer.print(this);\n\t}\n\n\tfunction new(nodeType:XmlType) {\n\t\tthis.nodeType = nodeType;\n\t\tchildren = [];\n\t\tattributeMap = new Map();\n\t}\n\n\tinline function ensureElementType() {\n\t\tif (nodeType != Document && nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element or Document but found $nodeType';\n\t\t}\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.StringIterator;\nimport haxe.iterators.StringKeyValueIterator;\n\n#if cpp\nusing cpp.NativeString;\n#end\n\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlEncode(s:String):String {\n\t\t#if flash\n\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\n\t\t#elseif cs\n\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#elseif hl\n\t\tvar len = 0;\n\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\n\t\treturn @:privateAccess String.__alloc__(b, len);\n\t\t#elseif lua\n\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\n\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function(c) {\n\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\n\t\t});\n\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\n\t\treturn s;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static function postProcessUrlEncode(s:String):String {\n\t\tvar ret = new StringBuf();\n\t\tvar i = 0, len = s.length;\n\t\twhile (i < len) {\n\t\t\tswitch (_charAt(s, i++)) {\n\t\t\t\tcase '+'.code:\n\t\t\t\t\tret.add('%20');\n\t\t\t\tcase '%'.code if (i <= len - 2):\n\t\t\t\t\tvar c1 = _charAt(s, i++), c2 = _charAt(s, i++);\n\t\t\t\t\tswitch [c1, c2] {\n\t\t\t\t\t\tcase ['2'.code, '1'.code]:\n\t\t\t\t\t\t\tret.addChar('!'.code);\n\t\t\t\t\t\tcase ['2'.code, '7'.code]:\n\t\t\t\t\t\t\tret.addChar('\\''.code);\n\t\t\t\t\t\tcase ['2'.code, '8'.code]:\n\t\t\t\t\t\t\tret.addChar('('.code);\n\t\t\t\t\t\tcase ['2'.code, '9'.code]:\n\t\t\t\t\t\t\tret.addChar(')'.code);\n\t\t\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\n\t\t\t\t\t\t\tret.addChar('~'.code);\n\t\t\t\t\t\tcase _:\n\t\t\t\t\t\t\tret.addChar('%'.code);\n\t\t\t\t\t\t\tret.addChar(cast c1);\n\t\t\t\t\t\t\tret.addChar(cast c2);\n\t\t\t\t\t}\n\t\t\t\tcase var chr:\n\t\t\t\t\tret.addChar(cast chr);\n\t\t\t}\n\t\t}\n\t\treturn ret.toString();\n\t}\n\t#end\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua && !eval) inline #end public static function urlDecode(s:String):String {\n\t\t#if flash\n\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\ttry\n\t\t\treturn java.net.URLDecoder.decode(s, \"UTF-8\")\n\t\tcatch (e:Dynamic)\n\t\t\tthrow e;\n\t\t#elseif cs\n\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#elseif hl\n\t\tvar len = 0;\n\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\n\t\treturn @:privateAccess String.__alloc__(b, len);\n\t\t#elseif lua\n\t\ts = lua.NativeStringTools.gsub(s, \"+\", \" \");\n\t\ts = lua.NativeStringTools.gsub(s, \"%%(%x%x)\", function(h) {\n\t\t\treturn lua.NativeStringTools.char(lua.Lua.tonumber(h, 16));\n\t\t});\n\t\ts = lua.NativeStringTools.gsub(s, \"\\r\\n\", \"\\n\");\n\t\treturn s;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape(s:String, ?quotes:Bool):String {\n\t\tvar buf = new StringBuf();\n\t\tfor (code in #if neko iterator(s) #else new haxe.iterators.StringIteratorUnicode(s) #end) {\n\t\t\tswitch (code) {\n\t\t\t\tcase '&'.code:\n\t\t\t\t\tbuf.add(\"&amp;\");\n\t\t\t\tcase '<'.code:\n\t\t\t\t\tbuf.add(\"&lt;\");\n\t\t\t\tcase '>'.code:\n\t\t\t\t\tbuf.add(\"&gt;\");\n\t\t\t\tcase '\"'.code if (quotes):\n\t\t\t\t\tbuf.add(\"&quot;\");\n\t\t\t\tcase '\\''.code if (quotes):\n\t\t\t\t\tbuf.add(\"&#039;\");\n\t\t\t\tcase _:\n\t\t\t\t\tbuf.addChar(code);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape(s:String):String {\n\t\treturn s.split(\"&gt;\")\n\t\t\t.join(\">\")\n\t\t\t.split(\"&lt;\")\n\t\t\t.join(\"<\")\n\t\t\t.split(\"&quot;\")\n\t\t\t.join('\"')\n\t\t\t.split(\"&#039;\")\n\t\t\t.join(\"'\")\n\t\t\t.split(\"&amp;\")\n\t\t\t.join(\"&\");\n\t}\n\n\t/**\n\t\tReturns `true` if `s` contains `value` and  `false` otherwise.\n\n\t\tWhen `value` is `null`, the result is unspecified.\n\t**/\n\tpublic static inline function contains(s:String, value:String):Bool {\n\t\treturn s.indexOf(value) != -1;\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python) inline #end function startsWith(s:String, start:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length < start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor (i in 0...start.length)\n\t\t\tif (p0.at(i) != p1.at(i))\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0, start.bytes, 0, start.length << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.startswith(s, start);\n\t\t#else\n\t\treturn (s.length >= start.length && s.lastIndexOf(start, 0) == 0);\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java || python) inline #end function endsWith(s:String, end:String):Bool {\n\t\t#if java\n\t\treturn (cast s : java.NativeString).endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#elseif python\n\t\treturn python.NativeStringTools.endswith(s, end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn (slen >= elen && s.indexOf(end, (slen - elen)) == (slen - elen));\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace(s:String, pos:Int):Bool {\n\t\t#if (python || lua)\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length)\n\t\t\treturn false;\n\t\t#end\n\t\tvar c = s.charCodeAt(pos);\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function ltrim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile (r < l && isSpace(s, r)) {\n\t\t\tr++;\n\t\t}\n\t\tif (r > 0)\n\t\t\treturn s.substr(r, l - r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function rtrim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile (r < l && isSpace(s, l - r - 1)) {\n\t\t\tr++;\n\t\t}\n\t\tif (r > 0) {\n\t\t\treturn s.substr(0, l - r);\n\t\t} else {\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n\t**/\n\tpublic #if (cs || java) inline #end static function trim(s:String):String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn (cast s : java.NativeString).trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad(s:String, c:String, l:Int):String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tl -= s.length;\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\tbuf.add(s);\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad(s:String, c:String, l:Int):String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\tvar buf = new StringBuf();\n\t\tbuf.add(s);\n\t\twhile (buf.length < l) {\n\t\t\tbuf.add(c);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s` except the last one. If `by` is also the empty String `\"\"`, `s`\n\t\tremains unchanged.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace(s:String, sub:String, by:String):String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn (cast s : java.NativeString).replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.\n\t**/\n\tpublic static function hex(n:Int, ?digits:Int) {\n\t\t#if flash\n\t\tvar n:UInt = n;\n\t\tvar s:String = untyped n.toString(16);\n\t\ts = s.toUpperCase();\n\t\t#else\n\t\tvar s = \"\";\n\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\tdo {\n\t\t\ts = hexChars.charAt(n & 15) + s;\n\t\t\tn >>>= 4;\n\t\t} while (n > 0);\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif (digits != null)\n\t\t\twhile (s.length < digits)\n\t\t\t\ts = \"0\" + s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static #if !eval inline #end function fastCodeAt(s:String, index:Int):Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn (index < s.length) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn (cast(index, UInt) < s.length) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (cast s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\t#if lua_vanilla\n\t\treturn lua.NativeStringTools.byte(s, index + 1);\n\t\t#else\n\t\treturn lua.lib.luautf8.Utf8.byte(s, index + 1);\n\t\t#end\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an iterator of the char codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.\n\t**/\n\tpublic static inline function iterator(s:String):StringIterator {\n\t\treturn new StringIterator(s);\n\t}\n\n\t/**\n\t\tReturns an iterator of the char indexes and codes.\n\n\t\tNote that char codes may differ across platforms because of different\n\t\tinternal encoding of strings in different of runtimes.\n\t\tFor the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.\n\t**/\n\tpublic static inline function keyValueIterator(s:String):StringKeyValueIterator {\n\t\treturn new StringKeyValueIterator(s);\n\t}\n\n\t/**\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t**/\n\t@:noUsing public static inline function isEof(c:Int):Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua || eval)\n\t\treturn c == null;\n\t\t#elseif (cs || java || python)\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead.')\n\tpublic static function quoteUnixArg(argument:String):String {\n\t\treturn inline haxe.SysTools.quoteUnixArg(argument);\n\t}\n\n\t/**\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead.')\n\tpublic static var winMetaCharacters:Array<Int> = cast haxe.SysTools.winMetaCharacters;\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```haxe\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```\n\t**/\n\t@:noCompletion\n\t@:deprecated('StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead.')\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\n\t\treturn inline haxe.SysTools.quoteWinArg(argument, escapeMetaCharacters);\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16\n\t\treturn (cast str : java.NativeString).charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\", \"url_encode\", 1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\", \"url_decode\", 1);\n\t#end\n\n\t#if utf16\n\tstatic inline var MIN_SURROGATE_CODE_POINT = 65536;\n\n\tstatic inline function utf16CodePointAt(s:String, index:Int):Int {\n\t\tvar c = StringTools.fastCodeAt(s, index);\n\t\tif (c >= 0xD800 && c <= 0xDBFF) {\n\t\t\tc = ((c - 0xD7C0) << 10) | (StringTools.fastCodeAt(s, index + 1) & 0x3FF);\n\t\t}\n\t\treturn c;\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.xml;\n\nprivate abstract NodeAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Access {\n\t\tvar x = this.elementsNamed(name).next();\n\t\tif (x == null) {\n\t\t\tvar xname = if (this.nodeType == Xml.Document) \"Document\" else this.nodeName;\n\t\t\tthrow xname + \" is missing element \" + name;\n\t\t}\n\t\treturn new Access(x);\n\t}\n}\n\nprivate abstract AttribAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):String {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\tvar v = this.get(name);\n\t\tif (v == null)\n\t\t\tthrow this.nodeName + \" is missing attribute \" + name;\n\t\treturn v;\n\t}\n\n\t@:op(a.b)\n\tfunction _hx_set(name:String, value:String):String {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\tthis.set(name, value);\n\t\treturn value;\n\t}\n}\n\nprivate abstract HasAttribAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Bool {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\treturn this.exists(name);\n\t}\n}\n\nprivate abstract HasNodeAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Bool {\n\t\treturn this.elementsNamed(name).hasNext();\n\t}\n}\n\nprivate abstract NodeListAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Array<Access> {\n\t\tvar l = [];\n\t\tfor (x in this.elementsNamed(name))\n\t\t\tl.push(new Access(x));\n\t\treturn l;\n\t}\n}\n\n/**\n\tThe `haxe.xml.Access` API helps providing a fast dot-syntax access to the\n\tmost common `Xml` methods.\n**/\nabstract Access(Xml) {\n\tpublic var x(get, never):Xml;\n\n\tpublic inline function get_x()\n\t\treturn this;\n\n\t/**\n\t\tThe name of the current element. This is the same as `Xml.nodeName`.\n\t**/\n\tpublic var name(get, never):String;\n\n\tinline function get_name() {\n\t\treturn if (this.nodeType == Xml.Document) \"Document\" else this.nodeName;\n\t}\n\n\t/**\n\t\tThe inner PCDATA or CDATA of the node.\n\n\t\tAn exception is thrown if there is no data or if there not only data\n\t\tbut also other nodes.\n\t**/\n\tpublic var innerData(get, never):String;\n\n\t/**\n\t\tThe XML string built with all the sub nodes, excluding the current one.\n\t**/\n\tpublic var innerHTML(get, never):String;\n\n\t/**\n\t\tAccess to the first sub element with the given name.\n\n\t\tAn exception is thrown if the element doesn't exists.\n\t\tUse `hasNode` to check the existence of a node.\n\n\t\t```haxe\n\t\tvar access = new haxe.xml.Access(Xml.parse(\"<user><name>John</name></user>\"));\n\t\tvar user = access.node.user;\n\t\tvar name = user.node.name;\n\t\ttrace(name.innerData); // John\n\n\t\t// Uncaught Error: Document is missing element password\n\t\tvar password = user.node.password;\n\t\t```\n\t**/\n\tpublic var node(get, never):NodeAccess;\n\n\tinline function get_node():NodeAccess\n\t\treturn x;\n\n\t/**\n\t\tAccess to the List of elements with the given name.\n\t\t```haxe\n\t\tvar fast = new haxe.xml.Access(Xml.parse(\"\n\t\t\t<users>\n\t\t\t\t<user name='John'/>\n\t\t\t\t<user name='Andy'/>\n\t\t\t\t<user name='Dan'/>\n\t\t\t</users>\"\n\t\t));\n\n\t\tvar users = fast.node.users;\n\t\tfor (user in users.nodes.user) {\n\t\t\ttrace(user.att.name);\n\t\t}\n\t\t```\n\t**/\n\tpublic var nodes(get, never):NodeListAccess;\n\n\tinline function get_nodes():NodeListAccess\n\t\treturn this;\n\n\t/**\n\t\tAccess to a given attribute.\n\n\t\tAn exception is thrown if the attribute doesn't exists.\n\t\tUse `has` to check the existence of an attribute.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user name='Mark'></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.has.name) {\n\t\t\ttrace(user.att.name); // Mark\n\t\t}\n\t\t```\n\t**/\n\tpublic var att(get, never):AttribAccess;\n\n\tinline function get_att():AttribAccess\n\t\treturn this;\n\n\t/**\n\t\tCheck the existence of an attribute with the given name.\n\t**/\n\tpublic var has(get, never):HasAttribAccess;\n\n\tinline function get_has():HasAttribAccess\n\t\treturn this;\n\n\t/**\n\t\tCheck the existence of a sub node with the given name.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user><age>31</age></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.hasNode.age) {\n\t\t\ttrace(user.node.age.innerData); // 31\n\t\t}\n\t\t```\n\t**/\n\tpublic var hasNode(get, never):HasNodeAccess;\n\n\tinline function get_hasNode():HasNodeAccess\n\t\treturn x;\n\n\t/**\n\t\tThe list of all sub-elements which are the nodes with type `Xml.Element`.\n\t**/\n\tpublic var elements(get, never):Iterator<Access>;\n\n\tinline function get_elements():Iterator<Access>\n\t\treturn cast this.elements();\n\n\tpublic inline function new(x:Xml) {\n\t\tif (x.nodeType != Xml.Document && x.nodeType != Xml.Element)\n\t\t\tthrow \"Invalid nodeType \" + x.nodeType;\n\t\tthis = x;\n\t}\n\n\tfunction get_innerData() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext())\n\t\t\tthrow name + \" does not have data\";\n\t\tvar v = it.next();\n\t\tif (it.hasNext()) {\n\t\t\tvar n = it.next();\n\t\t\t// handle <spaces>CDATA<spaces>\n\t\t\tif (v.nodeType == Xml.PCData && n.nodeType == Xml.CData && StringTools.trim(v.nodeValue) == \"\") {\n\t\t\t\tif (!it.hasNext())\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t\tvar n2 = it.next();\n\t\t\t\tif (n2.nodeType == Xml.PCData && StringTools.trim(n2.nodeValue) == \"\" && !it.hasNext())\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t}\n\t\t\tthrow name + \" does not only have data\";\n\t\t}\n\t\tif (v.nodeType != Xml.PCData && v.nodeType != Xml.CData)\n\t\t\tthrow name + \" does not have data\";\n\t\treturn v.nodeValue;\n\t}\n\n\tfunction get_innerHTML() {\n\t\tvar s = new StringBuf();\n\t\tfor (x in this)\n\t\t\ts.add(x.toString());\n\t\treturn s.toString();\n\t}\n}\n"]}