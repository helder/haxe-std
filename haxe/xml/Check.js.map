{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Check.js.map","sources":["../../../../../../../haxe/versions/4.2.0/std/haxe/iterators/ArrayIterator.hx","../../../../../../../haxe/versions/4.2.0/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.2.0/std/Xml.hx","../../../../../../../haxe/versions/4.2.0/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.2.0/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.2.0/std/js/_std/EReg.hx","../../../../../../../haxe/versions/4.2.0/std/haxe/xml/Check.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2018 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator is used only when `Array<T>` is passed to `Iterable<T>`\n**/\nclass ArrayIterator<T> {\n\tfinal array:Array<T>;\n\tvar current:Int = 0;\n\n\t/**\n\t\tCreate a new `ArrayIterator`.\n\t**/\n\t#if !hl inline #end\n\tpublic function new(array:Array<T>) {\n\t\tthis.array = array;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\t#if !hl inline #end\n\tpublic function hasNext() {\n\t\treturn current < array.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t#if !hl inline #end\n\tpublic function next() {\n\t\treturn array[current++];\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tXml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nenum abstract XmlType(Int) {\n\t/**\n\t\tRepresents an XML element type.\n\t**/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n\t**/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n\t**/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n\t**/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n\t**/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n\t**/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n\t**/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nclass Xml {\n\t/**\n\t\tXML element type.\n\t**/\n\tstatic public var Element(default, never) = XmlType.Element;\n\n\t/**\n\t\tXML parsed character data type.\n\t**/\n\tstatic public var PCData(default, never) = XmlType.PCData;\n\n\t/**\n\t\tXML character data type.\n\t**/\n\tstatic public var CData(default, never) = XmlType.CData;\n\n\t/**\n\t\tXML comment type.\n\t**/\n\tstatic public var Comment(default, never) = XmlType.Comment;\n\n\t/**\n\t\tXML doctype element type.\n\t**/\n\tstatic public var DocType(default, never) = XmlType.DocType;\n\n\t/**\n\t\tXML processing instruction type.\n\t**/\n\tstatic public var ProcessingInstruction(default, never) = XmlType.ProcessingInstruction;\n\n\t/**\n\t\tXML document type.\n\t**/\n\tstatic public var Document(default, never) = XmlType.Document;\n\n\t/**\n\t\tParses the String into an Xml document.\n\t**/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n\t**/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n\t**/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n\t**/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n\t**/\n\tpublic var parent(default, null):Xml;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createElement(name:String):Xml {\n\t\tvar xml = new Xml(Element);\n\t\txml.nodeName = name;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createPCData(data:String):Xml {\n\t\tvar xml = new Xml(PCData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createCData(data:String):Xml {\n\t\tvar xml = new Xml(CData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createComment(data:String):Xml {\n\t\tvar xml = new Xml(Comment);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocType(data:String):Xml {\n\t\tvar xml = new Xml(DocType);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createProcessingInstruction(data:String):Xml {\n\t\tvar xml = new Xml(ProcessingInstruction);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocument():Xml {\n\t\treturn new Xml(Document);\n\t}\n\n\t/**\n\t\tGet the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function get(att:String):String {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap[att];\n\t}\n\n\t/**\n\t\tSet the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function set(att:String, value:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.set(att, value);\n\t}\n\n\t/**\n\t\tRemoves an attribute for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function remove(att:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.remove(att);\n\t}\n\n\t/**\n\t\tTells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function exists(att:String):Bool {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.exists(att);\n\t}\n\n\t/**\n\t\tReturns an `Iterator` on all the attribute names.\n\t**/\n\tpublic function attributes():Iterator<String> {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.keys();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elements():Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [for (child in children) if (child.nodeType == Element) child];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elementsNamed(name:String):Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [\n\t\t\tfor (child in children)\n\t\t\t\tif (child.nodeType == Element && child.nodeName == name) child\n\t\t];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns the first child node.\n\t**/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.\n\t**/\n\tpublic function firstElement():Xml {\n\t\tensureElementType();\n\t\tfor (child in children) {\n\t\t\tif (child.nodeType == Element) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tAdds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function addChild(x:Xml):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.removeChild(x);\n\t\t}\n\t\tchildren.push(x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tRemoves a child from the Document or Element.\n\t\tReturns true if the child was successfuly removed.\n\t**/\n\tpublic function removeChild(x:Xml):Bool {\n\t\tensureElementType();\n\t\tif (children.remove(x)) {\n\t\t\tx.parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tInserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function insertChild(x:Xml, pos:Int):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.children.remove(x);\n\t\t}\n\t\tchildren.insert(pos, x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tReturns a String representation of the Xml node.\n\t**/\n\tpublic #if !cppia inline #end function toString():String {\n\t\treturn haxe.xml.Printer.print(this);\n\t}\n\n\tfunction new(nodeType:XmlType) {\n\t\tthis.nodeType = nodeType;\n\t\tchildren = [];\n\t\tattributeMap = new Map();\n\t}\n\n\tinline function ensureElementType() {\n\t\tif (nodeType != Document && nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element or Document but found $nodeType';\n\t\t}\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\t@:deprecated('Std.is is deprecated. Use Std.isOfType instead.')\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\tvar r:HaxeRegExp;\n\n\tpublic inline function new(r:String, opt:String):Void {\n\t\tthis.r = new HaxeRegExp(r, opt.split(\"u\").join(\"\")); // 'u' (utf8) depends on page encoding\n\t}\n\n\tpublic function match(s:String):Bool {\n\t\tif (r.global)\n\t\t\tr.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched(n:Int):String {\n\t\treturn if (r.m != null && n >= 0 && n < r.m.length) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft():String {\n\t\tif (r.m == null)\n\t\t\tthrow \"No string matched\";\n\t\treturn r.s.substr(0, r.m.index);\n\t}\n\n\tpublic function matchedRight():String {\n\t\tif (r.m == null)\n\t\t\tthrow \"No string matched\";\n\t\tvar sz = r.m.index + r.m[0].length;\n\t\treturn r.s.substr(sz, r.s.length - sz);\n\t}\n\n\tpublic function matchedPos():{pos:Int, len:Int} {\n\t\tif (r.m == null)\n\t\t\tthrow \"No string matched\";\n\t\treturn {pos: r.m.index, len: r.m[0].length};\n\t}\n\n\tpublic function matchSub(s:String, pos:Int, len:Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match(len < 0 ? s.substr(pos) : s.substr(pos, len));\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split(s:String):Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn replace(s, d).split(d);\n\t}\n\n\tpublic inline function replace(s:String, by:String):String {\n\t\treturn (cast s).replace(r, by);\n\t}\n\n\tpublic function map(s:String, f:EReg->String):String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t} else\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n\n\tpublic static inline function escape(s:String):String {\n\t\treturn (cast s).replace(escapeRe, \"\\\\$&\");\n\t}\n\n\tstatic var escapeRe = new js.lib.RegExp(\"[.*+?^${}()|[\\\\]\\\\\\\\]\", \"g\");\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.lib.RegExp {\n\tvar m:js.lib.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.xml;\n\nenum Filter {\n\tFInt;\n\tFBool;\n\tFEnum(values:Array<String>);\n\tFReg(matcher:EReg);\n}\n\nenum Attrib {\n\tAtt(name:String, ?filter:Filter, ?defvalue:String);\n}\n\nenum Rule {\n\tRNode(name:String, ?attribs:Array<Attrib>, ?childs:Rule);\n\tRData(?filter:Filter);\n\tRMulti(rule:Rule, ?atLeastOne:Bool);\n\tRList(rules:Array<Rule>, ?ordered:Bool);\n\tRChoice(choices:Array<Rule>);\n\tROptional(rule:Rule);\n}\n\nprivate enum CheckResult {\n\tCMatch;\n\tCMissing(r:Rule);\n\tCExtra(x:Xml);\n\tCElementExpected(name:String, x:Xml);\n\tCDataExpected(x:Xml);\n\tCExtraAttrib(att:String, x:Xml);\n\tCMissingAttrib(att:String, x:Xml);\n\tCInvalidAttrib(att:String, x:Xml, f:Filter);\n\tCInvalidData(x:Xml, f:Filter);\n\tCInElement(x:Xml, r:CheckResult);\n}\n\nclass Check {\n\tstatic var blanks = ~/^[ \\r\\n\\t]*$/;\n\n\tstatic function isBlank(x:Xml) {\n\t\treturn (x.nodeType == Xml.PCData && blanks.match(x.nodeValue)) || x.nodeType == Xml.Comment;\n\t}\n\n\tstatic function filterMatch(s:String, f:Filter) {\n\t\tswitch (f) {\n\t\t\tcase FInt:\n\t\t\t\treturn filterMatch(s, FReg(~/[0-9]+/));\n\t\t\tcase FBool:\n\t\t\t\treturn filterMatch(s, FEnum([\"true\", \"false\", \"0\", \"1\"]));\n\t\t\tcase FEnum(values):\n\t\t\t\tfor (v in values)\n\t\t\t\t\tif (s == v)\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\tcase FReg(r):\n\t\t\t\treturn r.match(s);\n\t\t}\n\t}\n\n\tstatic function isNullable(r:Rule) {\n\t\tswitch (r) {\n\t\t\tcase RMulti(r, one):\n\t\t\t\treturn (one != true || isNullable(r));\n\t\t\tcase RList(rl, _):\n\t\t\t\tfor (r in rl)\n\t\t\t\t\tif (!isNullable(r))\n\t\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\tcase RChoice(rl):\n\t\t\t\tfor (r in rl)\n\t\t\t\t\tif (isNullable(r))\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\tcase RData(_):\n\t\t\t\treturn false;\n\t\t\tcase RNode(_, _, _):\n\t\t\t\treturn false;\n\t\t\tcase ROptional(_):\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic function check(x:Xml, r:Rule) {\n\t\tswitch (r) {\n\t\t\t// check the node validity\n\t\t\tcase RNode(name, attribs, childs):\n\t\t\t\tif (x.nodeType != Xml.Element || x.nodeName != name)\n\t\t\t\t\treturn CElementExpected(name, x);\n\t\t\t\tvar attribs = if (attribs == null) new Array() else attribs.copy();\n\t\t\t\t// check defined attributes\n\t\t\t\tfor (xatt in x.attributes()) {\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (att in attribs)\n\t\t\t\t\t\tswitch (att) {\n\t\t\t\t\t\t\tcase Att(name, filter, _):\n\t\t\t\t\t\t\t\tif (xatt != name)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (filter != null && !filterMatch(x.get(xatt), filter))\n\t\t\t\t\t\t\t\t\treturn CInvalidAttrib(name, x, filter);\n\t\t\t\t\t\t\t\tattribs.remove(att);\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!found)\n\t\t\t\t\t\treturn CExtraAttrib(xatt, x);\n\t\t\t\t}\n\t\t\t\t// check remaining unchecked attributes\n\t\t\t\tfor (att in attribs)\n\t\t\t\t\tswitch (att) {\n\t\t\t\t\t\tcase Att(name, _, defvalue):\n\t\t\t\t\t\t\tif (defvalue == null)\n\t\t\t\t\t\t\t\treturn CMissingAttrib(name, x);\n\t\t\t\t\t}\n\t\t\t\t// check childs\n\t\t\t\tif (childs == null)\n\t\t\t\t\tchilds = RList([]);\n\t\t\t\tvar m = checkList(x.iterator(), childs);\n\t\t\t\tif (m != CMatch)\n\t\t\t\t\treturn CInElement(x, m);\n\t\t\t\t// set default attribs values\n\t\t\t\tfor (att in attribs)\n\t\t\t\t\tswitch (att) {\n\t\t\t\t\t\tcase Att(name, _, defvalue):\n\t\t\t\t\t\t\tx.set(name, defvalue);\n\t\t\t\t\t}\n\t\t\t\treturn CMatch;\n\t\t\t// check the data validity\n\t\t\tcase RData(filter):\n\t\t\t\tif (x.nodeType != Xml.PCData && x.nodeType != Xml.CData)\n\t\t\t\t\treturn CDataExpected(x);\n\t\t\t\tif (filter != null && !filterMatch(x.nodeValue, filter))\n\t\t\t\t\treturn CInvalidData(x, filter);\n\t\t\t\treturn CMatch;\n\t\t\t// several choices\n\t\t\tcase RChoice(choices):\n\t\t\t\tif (choices.length == 0)\n\t\t\t\t\tthrow \"No choice possible\";\n\t\t\t\tfor (c in choices)\n\t\t\t\t\tif (check(x, c) == CMatch)\n\t\t\t\t\t\treturn CMatch;\n\t\t\t\treturn check(x, choices[0]);\n\t\t\tcase ROptional(r):\n\t\t\t\treturn check(x, r);\n\t\t\tdefault:\n\t\t\t\tthrow \"Unexpected \" + Std.string(r);\n\t\t}\n\t}\n\n\tstatic function checkList(it:Iterator<Xml>, r:Rule) {\n\t\tswitch (r) {\n\t\t\tcase RList(rules, ordered):\n\t\t\t\tvar rules = rules.copy();\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (r in rules) {\n\t\t\t\t\t\tvar m = checkList([x].iterator(), r);\n\t\t\t\t\t\tif (m == CMatch) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\tcase RMulti(rsub, one):\n\t\t\t\t\t\t\t\t\tif (one) {\n\t\t\t\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\t\t\t\tfor (i in 0...rules.length)\n\t\t\t\t\t\t\t\t\t\t\tif (rules[i] == r)\n\t\t\t\t\t\t\t\t\t\t\t\trules[i] = RMulti(rsub);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\trules.remove(r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ordered && !isNullable(r))\n\t\t\t\t\t\t\treturn m;\n\t\t\t\t\t}\n\t\t\t\t\tif (!found)\n\t\t\t\t\t\treturn CExtra(x);\n\t\t\t\t}\n\t\t\t\tfor (r in rules)\n\t\t\t\t\tif (!isNullable(r))\n\t\t\t\t\t\treturn CMissing(r);\n\t\t\t\treturn CMatch;\n\t\t\tcase RMulti(r, one):\n\t\t\t\tvar found = false;\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar m = checkList([x].iterator(), r);\n\t\t\t\t\tif (m != CMatch)\n\t\t\t\t\t\treturn m;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tif (one && !found)\n\t\t\t\t\treturn CMissing(r);\n\t\t\t\treturn CMatch;\n\t\t\tdefault:\n\t\t\t\tvar found = false;\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar m = check(x, r);\n\t\t\t\t\tif (m != CMatch)\n\t\t\t\t\t\treturn m;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\tcase ROptional(_):\n\t\t\t\t\t\tdefault: return CMissing(r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treturn CExtra(x);\n\t\t\t\t}\n\t\t\t\treturn CMatch;\n\t\t}\n\t}\n\n\tstatic function makeWhere(path:Array<Xml>) {\n\t\tif (path.length == 0)\n\t\t\treturn \"\";\n\t\tvar s = \"In \";\n\t\tvar first = true;\n\t\tfor (x in path) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts += \".\";\n\t\t\ts += x.nodeName;\n\t\t}\n\t\treturn s + \": \";\n\t}\n\n\tstatic function makeString(x:Xml) {\n\t\tif (x.nodeType == Xml.Element)\n\t\t\treturn \"element \" + x.nodeName;\n\t\tvar s = x.nodeValue.split(\"\\r\").join(\"\\\\r\").split(\"\\n\").join(\"\\\\n\").split(\"\\t\").join(\"\\\\t\");\n\t\tif (s.length > 20)\n\t\t\treturn s.substr(0, 17) + \"...\";\n\t\treturn s;\n\t}\n\n\tstatic function makeRule(r:Rule) {\n\t\tswitch (r) {\n\t\t\tcase RNode(name, _, _):\n\t\t\t\treturn \"element \" + name;\n\t\t\tcase RData(_):\n\t\t\t\treturn \"data\";\n\t\t\tcase RMulti(r, _):\n\t\t\t\treturn makeRule(r);\n\t\t\tcase RList(rules, _):\n\t\t\t\treturn makeRule(rules[0]);\n\t\t\tcase RChoice(choices):\n\t\t\t\treturn makeRule(choices[0]);\n\t\t\tcase ROptional(r):\n\t\t\t\treturn makeRule(r);\n\t\t}\n\t}\n\n\tstatic function makeError(m, ?path) {\n\t\tif (path == null)\n\t\t\tpath = new Array();\n\t\tswitch (m) {\n\t\t\tcase CMatch:\n\t\t\t\tthrow \"assert\";\n\t\t\tcase CMissing(r):\n\t\t\t\treturn makeWhere(path) + \"Missing \" + makeRule(r);\n\t\t\tcase CExtra(x):\n\t\t\t\treturn makeWhere(path) + \"Unexpected \" + makeString(x);\n\t\t\tcase CElementExpected(name, x):\n\t\t\t\treturn makeWhere(path) + makeString(x) + \" while expected element \" + name;\n\t\t\tcase CDataExpected(x):\n\t\t\t\treturn makeWhere(path) + makeString(x) + \" while data expected\";\n\t\t\tcase CExtraAttrib(att, x):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeWhere(path) + \"unexpected attribute \" + att;\n\t\t\tcase CMissingAttrib(att, x):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeWhere(path) + \"missing required attribute \" + att;\n\t\t\tcase CInvalidAttrib(att, x, _):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeWhere(path) + \"invalid attribute value for \" + att;\n\t\t\tcase CInvalidData(x, _):\n\t\t\t\treturn makeWhere(path) + \"invalid data format for \" + makeString(x);\n\t\t\tcase CInElement(x, m):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeError(m, path);\n\t\t}\n\t}\n\n\tpublic static function checkNode(x:Xml, r:Rule) {\n\t\tvar m = checkList([x].iterator(), r);\n\t\tif (m == CMatch)\n\t\t\treturn;\n\t\tthrow makeError(m);\n\t}\n\n\tpublic static function checkDocument(x:Xml, r:Rule) {\n\t\tif (x.nodeType != Xml.Document)\n\t\t\tthrow \"Document expected\";\n\t\tvar m = checkList(x.iterator(), r);\n\t\tif (m == CMatch)\n\t\t\treturn;\n\t\tthrow makeError(m);\n\t}\n}\n"]}