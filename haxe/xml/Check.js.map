{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Check.js.map","sources":["../../../../../../../haxe/versions/4.0.1/std/js/Boot.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.1/std/Xml.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/EReg.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/xml/Check.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tXml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nenum abstract XmlType(Int) {\n\t/**\n\t\tRepresents an XML element type.\n\t**/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n\t**/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n\t**/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n\t**/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n\t**/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n\t**/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n\t**/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nclass Xml {\n\t/**\n\t\tXML element type.\n\t**/\n\tstatic public var Element(default, never) = XmlType.Element;\n\n\t/**\n\t\tXML parsed character data type.\n\t**/\n\tstatic public var PCData(default, never) = XmlType.PCData;\n\n\t/**\n\t\tXML character data type.\n\t**/\n\tstatic public var CData(default, never) = XmlType.CData;\n\n\t/**\n\t\tXML comment type.\n\t**/\n\tstatic public var Comment(default, never) = XmlType.Comment;\n\n\t/**\n\t\tXML doctype element type.\n\t**/\n\tstatic public var DocType(default, never) = XmlType.DocType;\n\n\t/**\n\t\tXML processing instruction type.\n\t**/\n\tstatic public var ProcessingInstruction(default, never) = XmlType.ProcessingInstruction;\n\n\t/**\n\t\tXML document type.\n\t**/\n\tstatic public var Document(default, never) = XmlType.Document;\n\n\t/**\n\t\tParses the String into an Xml document.\n\t**/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n\t**/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n\t**/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n\t**/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n\t**/\n\tpublic var parent(default, null):Xml;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createElement(name:String):Xml {\n\t\tvar xml = new Xml(Element);\n\t\txml.nodeName = name;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createPCData(data:String):Xml {\n\t\tvar xml = new Xml(PCData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createCData(data:String):Xml {\n\t\tvar xml = new Xml(CData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createComment(data:String):Xml {\n\t\tvar xml = new Xml(Comment);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocType(data:String):Xml {\n\t\tvar xml = new Xml(DocType);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createProcessingInstruction(data:String):Xml {\n\t\tvar xml = new Xml(ProcessingInstruction);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocument():Xml {\n\t\treturn new Xml(Document);\n\t}\n\n\t/**\n\t\tGet the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function get(att:String):String {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap[att];\n\t}\n\n\t/**\n\t\tSet the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function set(att:String, value:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.set(att, value);\n\t}\n\n\t/**\n\t\tRemoves an attribute for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function remove(att:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.remove(att);\n\t}\n\n\t/**\n\t\tTells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function exists(att:String):Bool {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.exists(att);\n\t}\n\n\t/**\n\t\tReturns an `Iterator` on all the attribute names.\n\t**/\n\tpublic function attributes():Iterator<String> {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.keys();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elements():Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [for (child in children) if (child.nodeType == Element) child];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elementsNamed(name:String):Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [\n\t\t\tfor (child in children)\n\t\t\t\tif (child.nodeType == Element && child.nodeName == name) child\n\t\t];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns the first child node.\n\t**/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.\n\t**/\n\tpublic function firstElement():Xml {\n\t\tensureElementType();\n\t\tfor (child in children) {\n\t\t\tif (child.nodeType == Element) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tAdds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function addChild(x:Xml):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.removeChild(x);\n\t\t}\n\t\tchildren.push(x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tRemoves a child from the Document or Element.\n\t\tReturns true if the child was successfuly removed.\n\t**/\n\tpublic function removeChild(x:Xml):Bool {\n\t\tensureElementType();\n\t\tif (children.remove(x)) {\n\t\t\tx.parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tInserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function insertChild(x:Xml, pos:Int):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.children.remove(x);\n\t\t}\n\t\tchildren.insert(pos, x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tReturns a String representation of the Xml node.\n\t**/\n\tpublic #if !cppia inline #end function toString():String {\n\t\treturn haxe.xml.Printer.print(this);\n\t}\n\n\tfunction new(nodeType:XmlType) {\n\t\tthis.nodeType = nodeType;\n\t\tchildren = [];\n\t\tattributeMap = new Map();\n\t}\n\n\tinline function ensureElementType() {\n\t\tif (nodeType != Document && nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element or Document but found $nodeType';\n\t\t}\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tvar v = untyped __js__('parseInt({0}, {0} && {0}[0]==\"0\" && ({0}[1]==\"x\" || {0}[1]==\"X\") ? 16 : 10)', x);\n\t\tif (untyped __js__(\"isNaN\")(v))\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\t__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = __js__('Date'), __js__('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", __js__('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", __js__('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", __js__('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", __js__('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", __js__('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", __js__('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", __js__('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) __js__(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) __js__(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\tvar r:HaxeRegExp;\n\n\tpublic inline function new(r:String, opt:String):Void {\n\t\tthis.r = new HaxeRegExp(r, opt.split(\"u\").join(\"\")); // 'u' (utf8) depends on page encoding\n\t}\n\n\tpublic function match(s:String):Bool {\n\t\tif (r.global)\n\t\t\tr.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched(n:Int):String {\n\t\treturn if (r.m != null && n >= 0 && n < r.m.length) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft():String {\n\t\tif (r.m == null)\n\t\t\tthrow \"No string matched\";\n\t\treturn r.s.substr(0, r.m.index);\n\t}\n\n\tpublic function matchedRight():String {\n\t\tif (r.m == null)\n\t\t\tthrow \"No string matched\";\n\t\tvar sz = r.m.index + r.m[0].length;\n\t\treturn r.s.substr(sz, r.s.length - sz);\n\t}\n\n\tpublic function matchedPos():{pos:Int, len:Int} {\n\t\tif (r.m == null)\n\t\t\tthrow \"No string matched\";\n\t\treturn {pos: r.m.index, len: r.m[0].length};\n\t}\n\n\tpublic function matchSub(s:String, pos:Int, len:Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match(len < 0 ? s.substr(pos) : s.substr(pos, len));\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split(s:String):Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn replace(s, d).split(d);\n\t}\n\n\tpublic inline function replace(s:String, by:String):String {\n\t\treturn (cast s).replace(r, by);\n\t}\n\n\tpublic function map(s:String, f:EReg->String):String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t} else\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n\n\tpublic static inline function escape(s:String):String {\n\t\treturn (cast s).replace(escapeRe, \"\\\\$&\");\n\t}\n\n\tstatic var escapeRe = new js.lib.RegExp(\"[.*+?^${}()|[\\\\]\\\\\\\\]\", \"g\");\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.lib.RegExp {\n\tvar m:js.lib.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.xml;\n\nenum Filter {\n\tFInt;\n\tFBool;\n\tFEnum(values:Array<String>);\n\tFReg(matcher:EReg);\n}\n\nenum Attrib {\n\tAtt(name:String, ?filter:Filter, ?defvalue:String);\n}\n\nenum Rule {\n\tRNode(name:String, ?attribs:Array<Attrib>, ?childs:Rule);\n\tRData(?filter:Filter);\n\tRMulti(rule:Rule, ?atLeastOne:Bool);\n\tRList(rules:Array<Rule>, ?ordered:Bool);\n\tRChoice(choices:Array<Rule>);\n\tROptional(rule:Rule);\n}\n\nprivate enum CheckResult {\n\tCMatch;\n\tCMissing(r:Rule);\n\tCExtra(x:Xml);\n\tCElementExpected(name:String, x:Xml);\n\tCDataExpected(x:Xml);\n\tCExtraAttrib(att:String, x:Xml);\n\tCMissingAttrib(att:String, x:Xml);\n\tCInvalidAttrib(att:String, x:Xml, f:Filter);\n\tCInvalidData(x:Xml, f:Filter);\n\tCInElement(x:Xml, r:CheckResult);\n}\n\nclass Check {\n\tstatic var blanks = ~/^[ \\r\\n\\t]*$/;\n\n\tstatic function isBlank(x:Xml) {\n\t\treturn (x.nodeType == Xml.PCData && blanks.match(x.nodeValue)) || x.nodeType == Xml.Comment;\n\t}\n\n\tstatic function filterMatch(s:String, f:Filter) {\n\t\tswitch (f) {\n\t\t\tcase FInt:\n\t\t\t\treturn filterMatch(s, FReg(~/[0-9]+/));\n\t\t\tcase FBool:\n\t\t\t\treturn filterMatch(s, FEnum([\"true\", \"false\", \"0\", \"1\"]));\n\t\t\tcase FEnum(values):\n\t\t\t\tfor (v in values)\n\t\t\t\t\tif (s == v)\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\tcase FReg(r):\n\t\t\t\treturn r.match(s);\n\t\t}\n\t}\n\n\tstatic function isNullable(r:Rule) {\n\t\tswitch (r) {\n\t\t\tcase RMulti(r, one):\n\t\t\t\treturn (one != true || isNullable(r));\n\t\t\tcase RList(rl, _):\n\t\t\t\tfor (r in rl)\n\t\t\t\t\tif (!isNullable(r))\n\t\t\t\t\t\treturn false;\n\t\t\t\treturn true;\n\t\t\tcase RChoice(rl):\n\t\t\t\tfor (r in rl)\n\t\t\t\t\tif (isNullable(r))\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\tcase RData(_):\n\t\t\t\treturn false;\n\t\t\tcase RNode(_, _, _):\n\t\t\t\treturn false;\n\t\t\tcase ROptional(_):\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic function check(x:Xml, r:Rule) {\n\t\tswitch (r) {\n\t\t\t// check the node validity\n\t\t\tcase RNode(name, attribs, childs):\n\t\t\t\tif (x.nodeType != Xml.Element || x.nodeName != name)\n\t\t\t\t\treturn CElementExpected(name, x);\n\t\t\t\tvar attribs = if (attribs == null) new Array() else attribs.copy();\n\t\t\t\t// check defined attributes\n\t\t\t\tfor (xatt in x.attributes()) {\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (att in attribs)\n\t\t\t\t\t\tswitch (att) {\n\t\t\t\t\t\t\tcase Att(name, filter, _):\n\t\t\t\t\t\t\t\tif (xatt != name)\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tif (filter != null && !filterMatch(x.get(xatt), filter))\n\t\t\t\t\t\t\t\t\treturn CInvalidAttrib(name, x, filter);\n\t\t\t\t\t\t\t\tattribs.remove(att);\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!found)\n\t\t\t\t\t\treturn CExtraAttrib(xatt, x);\n\t\t\t\t}\n\t\t\t\t// check remaining unchecked attributes\n\t\t\t\tfor (att in attribs)\n\t\t\t\t\tswitch (att) {\n\t\t\t\t\t\tcase Att(name, _, defvalue):\n\t\t\t\t\t\t\tif (defvalue == null)\n\t\t\t\t\t\t\t\treturn CMissingAttrib(name, x);\n\t\t\t\t\t}\n\t\t\t\t// check childs\n\t\t\t\tif (childs == null)\n\t\t\t\t\tchilds = RList([]);\n\t\t\t\tvar m = checkList(x.iterator(), childs);\n\t\t\t\tif (m != CMatch)\n\t\t\t\t\treturn CInElement(x, m);\n\t\t\t\t// set default attribs values\n\t\t\t\tfor (att in attribs)\n\t\t\t\t\tswitch (att) {\n\t\t\t\t\t\tcase Att(name, _, defvalue):\n\t\t\t\t\t\t\tx.set(name, defvalue);\n\t\t\t\t\t}\n\t\t\t\treturn CMatch;\n\t\t\t// check the data validity\n\t\t\tcase RData(filter):\n\t\t\t\tif (x.nodeType != Xml.PCData && x.nodeType != Xml.CData)\n\t\t\t\t\treturn CDataExpected(x);\n\t\t\t\tif (filter != null && !filterMatch(x.nodeValue, filter))\n\t\t\t\t\treturn CInvalidData(x, filter);\n\t\t\t\treturn CMatch;\n\t\t\t// several choices\n\t\t\tcase RChoice(choices):\n\t\t\t\tif (choices.length == 0)\n\t\t\t\t\tthrow \"No choice possible\";\n\t\t\t\tfor (c in choices)\n\t\t\t\t\tif (check(x, c) == CMatch)\n\t\t\t\t\t\treturn CMatch;\n\t\t\t\treturn check(x, choices[0]);\n\t\t\tcase ROptional(r):\n\t\t\t\treturn check(x, r);\n\t\t\tdefault:\n\t\t\t\tthrow \"Unexpected \" + Std.string(r);\n\t\t}\n\t}\n\n\tstatic function checkList(it:Iterator<Xml>, r:Rule) {\n\t\tswitch (r) {\n\t\t\tcase RList(rules, ordered):\n\t\t\t\tvar rules = rules.copy();\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar found = false;\n\t\t\t\t\tfor (r in rules) {\n\t\t\t\t\t\tvar m = checkList([x].iterator(), r);\n\t\t\t\t\t\tif (m == CMatch) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\t\t\tcase RMulti(rsub, one):\n\t\t\t\t\t\t\t\t\tif (one) {\n\t\t\t\t\t\t\t\t\t\tvar i;\n\t\t\t\t\t\t\t\t\t\tfor (i in 0...rules.length)\n\t\t\t\t\t\t\t\t\t\t\tif (rules[i] == r)\n\t\t\t\t\t\t\t\t\t\t\t\trules[i] = RMulti(rsub);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\trules.remove(r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ordered && !isNullable(r))\n\t\t\t\t\t\t\treturn m;\n\t\t\t\t\t}\n\t\t\t\t\tif (!found)\n\t\t\t\t\t\treturn CExtra(x);\n\t\t\t\t}\n\t\t\t\tfor (r in rules)\n\t\t\t\t\tif (!isNullable(r))\n\t\t\t\t\t\treturn CMissing(r);\n\t\t\t\treturn CMatch;\n\t\t\tcase RMulti(r, one):\n\t\t\t\tvar found = false;\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar m = checkList([x].iterator(), r);\n\t\t\t\t\tif (m != CMatch)\n\t\t\t\t\t\treturn m;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tif (one && !found)\n\t\t\t\t\treturn CMissing(r);\n\t\t\t\treturn CMatch;\n\t\t\tdefault:\n\t\t\t\tvar found = false;\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar m = check(x, r);\n\t\t\t\t\tif (m != CMatch)\n\t\t\t\t\t\treturn m;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!found) {\n\t\t\t\t\tswitch (r) {\n\t\t\t\t\t\tcase ROptional(_):\n\t\t\t\t\t\tdefault: return CMissing(r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (x in it) {\n\t\t\t\t\tif (isBlank(x))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treturn CExtra(x);\n\t\t\t\t}\n\t\t\t\treturn CMatch;\n\t\t}\n\t}\n\n\tstatic function makeWhere(path:Array<Xml>) {\n\t\tif (path.length == 0)\n\t\t\treturn \"\";\n\t\tvar s = \"In \";\n\t\tvar first = true;\n\t\tfor (x in path) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts += \".\";\n\t\t\ts += x.nodeName;\n\t\t}\n\t\treturn s + \": \";\n\t}\n\n\tstatic function makeString(x:Xml) {\n\t\tif (x.nodeType == Xml.Element)\n\t\t\treturn \"element \" + x.nodeName;\n\t\tvar s = x.nodeValue.split(\"\\r\").join(\"\\\\r\").split(\"\\n\").join(\"\\\\n\").split(\"\\t\").join(\"\\\\t\");\n\t\tif (s.length > 20)\n\t\t\treturn s.substr(0, 17) + \"...\";\n\t\treturn s;\n\t}\n\n\tstatic function makeRule(r:Rule) {\n\t\tswitch (r) {\n\t\t\tcase RNode(name, _, _):\n\t\t\t\treturn \"element \" + name;\n\t\t\tcase RData(_):\n\t\t\t\treturn \"data\";\n\t\t\tcase RMulti(r, _):\n\t\t\t\treturn makeRule(r);\n\t\t\tcase RList(rules, _):\n\t\t\t\treturn makeRule(rules[0]);\n\t\t\tcase RChoice(choices):\n\t\t\t\treturn makeRule(choices[0]);\n\t\t\tcase ROptional(r):\n\t\t\t\treturn makeRule(r);\n\t\t}\n\t}\n\n\tstatic function makeError(m, ?path) {\n\t\tif (path == null)\n\t\t\tpath = new Array();\n\t\tswitch (m) {\n\t\t\tcase CMatch:\n\t\t\t\tthrow \"assert\";\n\t\t\tcase CMissing(r):\n\t\t\t\treturn makeWhere(path) + \"Missing \" + makeRule(r);\n\t\t\tcase CExtra(x):\n\t\t\t\treturn makeWhere(path) + \"Unexpected \" + makeString(x);\n\t\t\tcase CElementExpected(name, x):\n\t\t\t\treturn makeWhere(path) + makeString(x) + \" while expected element \" + name;\n\t\t\tcase CDataExpected(x):\n\t\t\t\treturn makeWhere(path) + makeString(x) + \" while data expected\";\n\t\t\tcase CExtraAttrib(att, x):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeWhere(path) + \"unexpected attribute \" + att;\n\t\t\tcase CMissingAttrib(att, x):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeWhere(path) + \"missing required attribute \" + att;\n\t\t\tcase CInvalidAttrib(att, x, _):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeWhere(path) + \"invalid attribute value for \" + att;\n\t\t\tcase CInvalidData(x, _):\n\t\t\t\treturn makeWhere(path) + \"invalid data format for \" + makeString(x);\n\t\t\tcase CInElement(x, m):\n\t\t\t\tpath.push(x);\n\t\t\t\treturn makeError(m, path);\n\t\t}\n\t}\n\n\tpublic static function checkNode(x:Xml, r:Rule) {\n\t\tvar m = checkList([x].iterator(), r);\n\t\tif (m == CMatch)\n\t\t\treturn;\n\t\tthrow makeError(m);\n\t}\n\n\tpublic static function checkDocument(x:Xml, r:Rule) {\n\t\tif (x.nodeType != Xml.Document)\n\t\t\tthrow \"Document expected\";\n\t\tvar m = checkList(x.iterator(), r);\n\t\tif (m == CMatch)\n\t\t\treturn;\n\t\tthrow makeError(m);\n\t}\n}\n"]}