{"sourceRoot":"","names":[],"mappings":"QAyBA;QCEA;;;QCtBA;ACsBA;;;;;;;;;CACC;CACA;CACA;;;;AAMD;;;;;;CAKC,gBAA2C,CAC1C;gBAAS,WACT;mBACyB,GAEhB;;SAAQ;GAAR,AACH,OADG;UACE;;GADF,AAEH,OAFG;UAEG;;GAFH,AAGH,OAHG;UAGK;;;IAHd;gBAAS;;CAOV,UACgB;;GACJ,AAAL,OAAK;oBAAS;;GACR,AAAN,OAAM;qBAAU;;GACR,AAAR,OAAQ;uBAAY;;;;;CAI3B,qBAA8D,CAC7D;UAAQ,WAAW,AAAC,WAAW,SAC/B;KAAI,MAAK,YAAY,YAAY,GAChC;GAAO;IACR;WAAS,kBACT;SAAO,GACP;WAAU,EAAV;YAAc,EAAd;cAAc,KAAd;gBACC;cAAW;IACZ;EAAO;;CAGR,eAAyE,CACxE;KAAI,cAAa,gBACV;;;KAAN,MAAM,SAAO;;IAAP;KAAN,MAAM,UAAO;;IAAP;KAAN,MAAM,YAAO;;;;IAEd;QAAM,aAAQ,KAAK,gBAEnB;WAAS,kBACT;WAAS,kBACT;WAAU,EAAV;YAAc,WAAd;cAAc,KAAd;gBACC;cAAW,MAAQ,KAAK,IACxB;cAAW,MAAQ,KAAK;IAGzB;SAAO,KACA;UAAO,cAAP;;;;;;;;;;;;;IAAP;SAAO,KACA;WAAO,cAAP","version":3,"file":"Hmac.js.map","sources":["../../../../../../../haxe/versions/4.0.1/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/crypto/Sha256.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/crypto/Hmac.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCreates a Sha256 of a String.\n**/\nclass Sha256 {\n\tpublic static function encode(s:String):String {\n\t\tvar sh = new Sha256();\n\t\tvar h = sh.doEncode(str2blks(s), s.length * 8);\n\t\treturn sh.hex(h);\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\tvar h = new Sha256().doEncode(bytes2blks(b), b.length * 8);\n\t\tvar out = haxe.io.Bytes.alloc(32);\n\t\tvar p = 0;\n\t\tfor (i in 0...8) {\n\t\t\tout.set(p++, h[i] >>> 24);\n\t\t\tout.set(p++, (h[i] >> 16) & 0xFF);\n\t\t\tout.set(p++, (h[i] >> 8) & 0xFF);\n\t\t\tout.set(p++, h[i] & 0xFF);\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic function new() {}\n\n\tfunction doEncode(m:Array<Int>, l:Int):Array<Int> {\n\t\tvar K:Array<Int> = [\n\t\t\t0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n\t\t\t0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n\t\t\t0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n\t\t\t0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n\t\t\t0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n\t\t\t0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n\t\t];\n\t\tvar HASH:Array<Int> = [\n\t\t\t0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n\t\t\t0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n\t\t];\n\n\t\tvar W = new Array<Int>();\n\t\tW[64] = 0;\n\t\tvar a:Int, b:Int, c:Int, d:Int, e:Int, f:Int, g:Int, h:Int;\n\t\tvar T1, T2;\n\t\tm[l >> 5] |= 0x80 << (24 - l % 32);\n\t\tm[((l + 64 >> 9) << 4) + 15] = l;\n\t\tvar i:Int = 0;\n\t\twhile (i < m.length) {\n\t\t\ta = HASH[0];\n\t\t\tb = HASH[1];\n\t\t\tc = HASH[2];\n\t\t\td = HASH[3];\n\t\t\te = HASH[4];\n\t\t\tf = HASH[5];\n\t\t\tg = HASH[6];\n\t\t\th = HASH[7];\n\t\t\tfor (j in 0...64) {\n\t\t\t\tif (j < 16)\n\t\t\t\t\tW[j] = m[j + i];\n\t\t\t\telse\n\t\t\t\t\tW[j] = safeAdd(safeAdd(safeAdd(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n\t\t\t\tT1 = safeAdd(safeAdd(safeAdd(safeAdd(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n\t\t\t\tT2 = safeAdd(Sigma0256(a), Maj(a, b, c));\n\t\t\t\th = g;\n\t\t\t\tg = f;\n\t\t\t\tf = e;\n\t\t\t\te = safeAdd(d, T1);\n\t\t\t\td = c;\n\t\t\t\tc = b;\n\t\t\t\tb = a;\n\t\t\t\ta = safeAdd(T1, T2);\n\t\t\t}\n\t\t\tHASH[0] = safeAdd(a, HASH[0]);\n\t\t\tHASH[1] = safeAdd(b, HASH[1]);\n\t\t\tHASH[2] = safeAdd(c, HASH[2]);\n\t\t\tHASH[3] = safeAdd(d, HASH[3]);\n\t\t\tHASH[4] = safeAdd(e, HASH[4]);\n\t\t\tHASH[5] = safeAdd(f, HASH[5]);\n\t\t\tHASH[6] = safeAdd(g, HASH[6]);\n\t\t\tHASH[7] = safeAdd(h, HASH[7]);\n\t\t\ti += 16;\n\t\t}\n\t\treturn HASH;\n\t}\n\n\t/**\n\t\tConvert a string to a sequence of 16-word blocks, stored as an array.\n\t\tAppend padding bits and the length, as described in the SHA1 standard.\n\t**/\n\tstatic function str2blks(s:String):Array<Int> {\n\t\t#if target.unicode\n\t\tvar s = haxe.io.Bytes.ofString(s);\n\t\t#end\n\t\tvar nblk = ((s.length + 8) >> 6) + 1;\n\t\tvar blks = new Array<Int>();\n\n\t\tfor (i in 0...nblk * 16)\n\t\t\tblks[i] = 0;\n\t\tfor (i in 0...s.length) {\n\t\t\tvar p = i >> 2;\n\t\t\tblks[p] |= #if target.unicode s.get(i) #else s.charCodeAt(i) #end << (24 - ((i & 3) << 3));\n\t\t}\n\t\tvar i = s.length;\n\t\tvar p = i >> 2;\n\t\tblks[p] |= 0x80 << (24 - ((i & 3) << 3));\n\t\tblks[nblk * 16 - 1] = s.length * 8;\n\t\treturn blks;\n\t}\n\n\tstatic function bytes2blks(b:haxe.io.Bytes):Array<Int> {\n\t\tvar nblk = ((b.length + 8) >> 6) + 1;\n\t\tvar blks = new Array<Int>();\n\n\t\tfor (i in 0...nblk * 16)\n\t\t\tblks[i] = 0;\n\t\tfor (i in 0...b.length) {\n\t\t\tvar p = i >> 2;\n\t\t\tblks[p] |= b.get(i) << (24 - ((i & 3) << 3));\n\t\t}\n\t\tvar i = b.length;\n\t\tvar p = i >> 2;\n\t\tblks[p] |= 0x80 << (24 - ((i & 3) << 3));\n\t\tblks[nblk * 16 - 1] = b.length * 8;\n\t\treturn blks;\n\t}\n\n\textern inline function S(X, n) {\n\t\treturn (X >>> n) | (X << (32 - n));\n\t}\n\n\textern inline function R(X, n) {\n\t\treturn (X >>> n);\n\t}\n\n\textern inline function Ch(x, y, z) {\n\t\treturn ((x & y) ^ ((~x) & z));\n\t}\n\n\textern inline function Maj(x, y, z) {\n\t\treturn ((x & y) ^ (x & z) ^ (y & z));\n\t}\n\n\textern inline function Sigma0256(x) {\n\t\treturn (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n\t}\n\n\textern inline function Sigma1256(x) {\n\t\treturn (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n\t}\n\n\textern inline function Gamma0256(x) {\n\t\treturn (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n\t}\n\n\textern inline function Gamma1256(x) {\n\t\treturn (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n\t}\n\n\textern inline function safeAdd(x, y) {\n\t\tvar lsw = (x & 0xFFFF) + (y & 0xFFFF);\n\t\tvar msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t\treturn (msw << 16) | (lsw & 0xFFFF);\n\t}\n\n\tfunction hex(a:Array<Int>) {\n\t\tvar str = \"\";\n\t\tfor (num in a) {\n\t\t\tstr += StringTools.hex(num, 8);\n\t\t}\n\t\treturn str.toLowerCase();\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tHash methods for Hmac calculation.\n**/\nenum HashMethod {\n\tMD5;\n\tSHA1;\n\tSHA256;\n}\n\n/**\n\tCalculates a Hmac of the given Bytes using a HashMethod.\n**/\nclass Hmac {\n\tvar method:HashMethod;\n\tvar blockSize:Int;\n\tvar length:Int;\n\n\tpublic function new(hashMethod:HashMethod) {\n\t\tmethod = hashMethod;\n\t\tblockSize = switch (hashMethod) {\n\t\t\tcase MD5, SHA1, SHA256: 64;\n\t\t}\n\t\tlength = switch (hashMethod) {\n\t\t\tcase MD5: 16;\n\t\t\tcase SHA1: 20;\n\t\t\tcase SHA256: 32;\n\t\t}\n\t}\n\n\tinline function doHash(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\treturn switch (method) {\n\t\t\tcase MD5: Md5.make(b);\n\t\t\tcase SHA1: Sha1.make(b);\n\t\t\tcase SHA256: Sha256.make(b);\n\t\t}\n\t}\n\n\tfunction nullPad(s:haxe.io.Bytes, chunkLen:Int):haxe.io.Bytes {\n\t\tvar r = chunkLen - (s.length % chunkLen);\n\t\tif (r == chunkLen && s.length != 0)\n\t\t\treturn s;\n\t\tvar sb = new haxe.io.BytesBuffer();\n\t\tsb.add(s);\n\t\tfor (x in 0...r)\n\t\t\tsb.addByte(0);\n\t\treturn sb.getBytes();\n\t}\n\n\tpublic function make(key:haxe.io.Bytes, msg:haxe.io.Bytes):haxe.io.Bytes {\n\t\tif (key.length > blockSize) {\n\t\t\tkey = doHash(key);\n\t\t}\n\t\tkey = nullPad(key, blockSize);\n\n\t\tvar Ki = new haxe.io.BytesBuffer();\n\t\tvar Ko = new haxe.io.BytesBuffer();\n\t\tfor (i in 0...key.length) {\n\t\t\tKo.addByte(key.get(i) ^ 0x5c);\n\t\t\tKi.addByte(key.get(i) ^ 0x36);\n\t\t}\n\t\t// hash(Ko + hash(Ki + message))\n\t\tKi.add(msg);\n\t\tKo.add(doHash(Ki.getBytes()));\n\t\treturn doHash(Ko.getBytes());\n\t}\n}\n"]}