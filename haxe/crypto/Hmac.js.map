{"sourceRoot":"","names":[],"mappings":"QAyBA;QCEA;QCAA;QCAA;QCtBA;;;;;ACsBA;;;;;CACC;CACA;CACA;;;;;;;;AAMD;AAAA;CAK4C,iBAC1C;EAAA,cAAS,WACT;EAAA,iBACyB,GAEhB;EAAA;EAAA,OAAQ;GAAR,AACH,OADG;IAAA,MACE;;GADF,AAEH,OAFG;IAAA,MAEG;;GAFH,AAGH,OAHG;IAAA,MAGK;;;IAHd;EAAA,cAAS;;CAOV,UACgB;EAAA;GACJ,AAAL,OAAK;IAAA,gBAAS;;GACR,AAAN,OAAM;IAAA,iBAAU;;GACR,AAAR,OAAQ;IAAA,mBAAY;;;;;CAI3B,qBAA8D,CAC7D;EAAA,QAAQ,WAAW,AAAC,WAAW,SAC/B;EAAA,GAAI,MAAK,YAAY,YAAY,GAChC;GAAA,AAAO;IACR;EAAA,SAAS,kBACT;EAAA,OAAO,GACP,AAAU;EAAA,WAAI;EAAA,YAAd;EAAA,MAAK,CAAK,KAAI,KAAd,CAAU;GAAA,aACT;GAAA,WAAW;IACZ;EAAA,AAAO;;CAGR,eAAyE,CACxE;EAAA,GAAI,cAAa,gBACV;GAAA;IAAA;KAAA,AAAN,MAAM,SAAO;;IAAP;KAAA,AAAN,MAAM,UAAO;;IAAP;KAAA,AAAN,MAAM,YAAO;;;;IAEd;EAAA,MAAM,aAAQ,KAAK,gBAEnB;EAAA,SAAS,kBACT;EAAA,SAAS,kBACT,AAAU;EAAA,WAAI;EAAA,qBAAd;EAAA,MAAK,CAAK,KAAI,KAAd,CAAU;GAAA,aACT;GAAA,WAAW,MAAQ,KAAK,IACxB;GAAA,WAAW,MAAQ,KAAK;IAGzB;EAAA,OAAO,KACA;EAAA,QAAO,cAAP;EAAA;EAAA;GAAA;IAAA;;GAAA;IAAA;;GAAA;IAAA;;;IAAP;EAAA,OAAO,KACA;EAAA,SAAO,cAAP;EAAA;GAAA;IAAA;;GAAA;IAAA;;GAAA;IAAA","version":3,"file":"Hmac.js.map","sources":["../../../../../../../haxe/versions/4.2.1/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.2.1/std/haxe/crypto/Sha256.hx","../../../../../../../haxe/versions/4.2.1/std/haxe/crypto/Sha1.hx","../../../../../../../haxe/versions/4.2.1/std/haxe/crypto/Md5.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.2.1/std/haxe/crypto/Hmac.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCreates a Sha256 of a String.\n**/\nclass Sha256 {\n\tpublic static function encode(s:String):String {\n\t\tvar sh = new Sha256();\n\t\tvar h = sh.doEncode(str2blks(s), s.length * 8);\n\t\treturn sh.hex(h);\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\tvar h = new Sha256().doEncode(bytes2blks(b), b.length * 8);\n\t\tvar out = haxe.io.Bytes.alloc(32);\n\t\tvar p = 0;\n\t\tfor (i in 0...8) {\n\t\t\tout.set(p++, h[i] >>> 24);\n\t\t\tout.set(p++, (h[i] >> 16) & 0xFF);\n\t\t\tout.set(p++, (h[i] >> 8) & 0xFF);\n\t\t\tout.set(p++, h[i] & 0xFF);\n\t\t}\n\t\treturn out;\n\t}\n\n\tfunction new() {}\n\n\tfunction doEncode(m:Array<Int>, l:Int):Array<Int> {\n\t\tvar K:Array<Int> = [\n\t\t\t0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n\t\t\t0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n\t\t\t0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n\t\t\t0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n\t\t\t0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n\t\t\t0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n\t\t];\n\t\tvar HASH:Array<Int> = [\n\t\t\t0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,\n\t\t\t0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19\n\t\t];\n\n\t\tvar W = new Array<Int>();\n\t\tW[64] = 0;\n\t\tvar a:Int, b:Int, c:Int, d:Int, e:Int, f:Int, g:Int, h:Int;\n\t\tvar T1, T2;\n\t\tm[l >> 5] |= 0x80 << (24 - l % 32);\n\t\tm[((l + 64 >> 9) << 4) + 15] = l;\n\t\tvar i:Int = 0;\n\t\twhile (i < m.length) {\n\t\t\ta = HASH[0];\n\t\t\tb = HASH[1];\n\t\t\tc = HASH[2];\n\t\t\td = HASH[3];\n\t\t\te = HASH[4];\n\t\t\tf = HASH[5];\n\t\t\tg = HASH[6];\n\t\t\th = HASH[7];\n\t\t\tfor (j in 0...64) {\n\t\t\t\tif (j < 16)\n\t\t\t\t\tW[j] = m[j + i];\n\t\t\t\telse\n\t\t\t\t\tW[j] = safeAdd(safeAdd(safeAdd(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n\t\t\t\tT1 = safeAdd(safeAdd(safeAdd(safeAdd(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n\t\t\t\tT2 = safeAdd(Sigma0256(a), Maj(a, b, c));\n\t\t\t\th = g;\n\t\t\t\tg = f;\n\t\t\t\tf = e;\n\t\t\t\te = safeAdd(d, T1);\n\t\t\t\td = c;\n\t\t\t\tc = b;\n\t\t\t\tb = a;\n\t\t\t\ta = safeAdd(T1, T2);\n\t\t\t}\n\t\t\tHASH[0] = safeAdd(a, HASH[0]);\n\t\t\tHASH[1] = safeAdd(b, HASH[1]);\n\t\t\tHASH[2] = safeAdd(c, HASH[2]);\n\t\t\tHASH[3] = safeAdd(d, HASH[3]);\n\t\t\tHASH[4] = safeAdd(e, HASH[4]);\n\t\t\tHASH[5] = safeAdd(f, HASH[5]);\n\t\t\tHASH[6] = safeAdd(g, HASH[6]);\n\t\t\tHASH[7] = safeAdd(h, HASH[7]);\n\t\t\ti += 16;\n\t\t}\n\t\treturn HASH;\n\t}\n\n\t/**\n\t\tConvert a string to a sequence of 16-word blocks, stored as an array.\n\t\tAppend padding bits and the length, as described in the SHA1 standard.\n\t**/\n\tstatic function str2blks(s:String):Array<Int> {\n\t\t#if target.unicode\n\t\tvar s = haxe.io.Bytes.ofString(s);\n\t\t#end\n\t\tvar nblk = ((s.length + 8) >> 6) + 1;\n\t\tvar blks = new Array<Int>();\n\n\t\tfor (i in 0...nblk * 16)\n\t\t\tblks[i] = 0;\n\t\tfor (i in 0...s.length) {\n\t\t\tvar p = i >> 2;\n\t\t\tblks[p] |= #if target.unicode s.get(i) #else s.charCodeAt(i) #end << (24 - ((i & 3) << 3));\n\t\t}\n\t\tvar i = s.length;\n\t\tvar p = i >> 2;\n\t\tblks[p] |= 0x80 << (24 - ((i & 3) << 3));\n\t\tblks[nblk * 16 - 1] = s.length * 8;\n\t\treturn blks;\n\t}\n\n\tstatic function bytes2blks(b:haxe.io.Bytes):Array<Int> {\n\t\tvar nblk = ((b.length + 8) >> 6) + 1;\n\t\tvar blks = new Array<Int>();\n\n\t\tfor (i in 0...nblk * 16)\n\t\t\tblks[i] = 0;\n\t\tfor (i in 0...b.length) {\n\t\t\tvar p = i >> 2;\n\t\t\tblks[p] |= b.get(i) << (24 - ((i & 3) << 3));\n\t\t}\n\t\tvar i = b.length;\n\t\tvar p = i >> 2;\n\t\tblks[p] |= 0x80 << (24 - ((i & 3) << 3));\n\t\tblks[nblk * 16 - 1] = b.length * 8;\n\t\treturn blks;\n\t}\n\n\textern inline function S(X, n) {\n\t\treturn (X >>> n) | (X << (32 - n));\n\t}\n\n\textern inline function R(X, n) {\n\t\treturn (X >>> n);\n\t}\n\n\textern inline function Ch(x, y, z) {\n\t\treturn ((x & y) ^ ((~x) & z));\n\t}\n\n\textern inline function Maj(x, y, z) {\n\t\treturn ((x & y) ^ (x & z) ^ (y & z));\n\t}\n\n\textern inline function Sigma0256(x) {\n\t\treturn (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n\t}\n\n\textern inline function Sigma1256(x) {\n\t\treturn (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n\t}\n\n\textern inline function Gamma0256(x) {\n\t\treturn (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n\t}\n\n\textern inline function Gamma1256(x) {\n\t\treturn (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n\t}\n\n\textern inline function safeAdd(x, y) {\n\t\tvar lsw = (x & 0xFFFF) + (y & 0xFFFF);\n\t\tvar msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t\treturn (msw << 16) | (lsw & 0xFFFF);\n\t}\n\n\tfunction hex(a:Array<Int>) {\n\t\tvar str = \"\";\n\t\tfor (num in a) {\n\t\t\tstr += StringTools.hex(num, 8);\n\t\t}\n\t\treturn str.toLowerCase();\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCreates a Sha1 of a String.\n**/\nclass Sha1 {\n\tpublic static function encode(s:String):String {\n\t\tvar sh = new Sha1();\n\t\tvar h = sh.doEncode(str2blks(s));\n\t\treturn sh.hex(h);\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\tvar h = new Sha1().doEncode(bytes2blks(b));\n\t\tvar out = haxe.io.Bytes.alloc(20);\n\t\tvar p = 0;\n\t\tfor (i in 0...5) {\n\t\t\tout.set(p++, h[i] >>> 24);\n\t\t\tout.set(p++, (h[i] >> 16) & 0xFF);\n\t\t\tout.set(p++, (h[i] >> 8) & 0xFF);\n\t\t\tout.set(p++, h[i] & 0xFF);\n\t\t}\n\t\treturn out;\n\t}\n\n\tfunction new() {}\n\n\tfunction doEncode(x:Array<Int>):Array<Int> {\n\t\tvar w = new Array<Int>();\n\n\t\tvar a = 0x67452301;\n\t\tvar b = 0xEFCDAB89;\n\t\tvar c = 0x98BADCFE;\n\t\tvar d = 0x10325476;\n\t\tvar e = 0xC3D2E1F0;\n\n\t\tvar i = 0;\n\t\twhile (i < x.length) {\n\t\t\tvar olda = a;\n\t\t\tvar oldb = b;\n\t\t\tvar oldc = c;\n\t\t\tvar oldd = d;\n\t\t\tvar olde = e;\n\n\t\t\tvar j = 0;\n\t\t\twhile (j < 80) {\n\t\t\t\tif (j < 16)\n\t\t\t\t\tw[j] = x[i + j];\n\t\t\t\telse\n\t\t\t\t\tw[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n\t\t\t\tvar t = rol(a, 5) + ft(j, b, c, d) + e + w[j] + kt(j);\n\t\t\t\te = d;\n\t\t\t\td = c;\n\t\t\t\tc = rol(b, 30);\n\t\t\t\tb = a;\n\t\t\t\ta = t;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ta += olda;\n\t\t\tb += oldb;\n\t\t\tc += oldc;\n\t\t\td += oldd;\n\t\t\te += olde;\n\t\t\ti += 16;\n\t\t}\n\t\treturn [a, b, c, d, e];\n\t}\n\n\t/**\n\t\tConvert a string to a sequence of 16-word blocks, stored as an array.\n\t\tAppend padding bits and the length, as described in the SHA1 standard.\n\t**/\n\tstatic function str2blks(s:String):Array<Int> {\n\t\t#if target.unicode\n\t\tvar s = haxe.io.Bytes.ofString(s);\n\t\t#end\n\t\tvar nblk = ((s.length + 8) >> 6) + 1;\n\t\tvar blks = new Array<Int>();\n\n\t\tfor (i in 0...nblk * 16)\n\t\t\tblks[i] = 0;\n\t\tfor (i in 0...s.length) {\n\t\t\tvar p = i >> 2;\n\t\t\tblks[p] |= #if target.unicode s.get(i) #else StringTools.fastCodeAt(s, i) #end << (24 - ((i & 3) << 3));\n\t\t}\n\t\tvar i = s.length;\n\t\tvar p = i >> 2;\n\t\tblks[p] |= 0x80 << (24 - ((i & 3) << 3));\n\t\tblks[nblk * 16 - 1] = s.length * 8;\n\t\treturn blks;\n\t}\n\n\tstatic function bytes2blks(b:haxe.io.Bytes):Array<Int> {\n\t\tvar nblk = ((b.length + 8) >> 6) + 1;\n\t\tvar blks = new Array<Int>();\n\n\t\tfor (i in 0...nblk * 16)\n\t\t\tblks[i] = 0;\n\t\tfor (i in 0...b.length) {\n\t\t\tvar p = i >> 2;\n\t\t\tblks[p] |= b.get(i) << (24 - ((i & 3) << 3));\n\t\t}\n\t\tvar i = b.length;\n\t\tvar p = i >> 2;\n\t\tblks[p] |= 0x80 << (24 - ((i & 3) << 3));\n\t\tblks[nblk * 16 - 1] = b.length * 8;\n\t\treturn blks;\n\t}\n\n\t/**\n\t\tBitwise rotate a 32-bit number to the left\n\t**/\n\tinline function rol(num:Int, cnt:Int):Int {\n\t\treturn (num << cnt) | (num >>> (32 - cnt));\n\t}\n\n\t/**\n\t\tPerform the appropriate triplet combination function for the current iteration\n\t**/\n\tfunction ft(t:Int, b:Int, c:Int, d:Int):Int {\n\t\tif (t < 20)\n\t\t\treturn (b & c) | ((~b) & d);\n\t\tif (t < 40)\n\t\t\treturn b ^ c ^ d;\n\t\tif (t < 60)\n\t\t\treturn (b & c) | (b & d) | (c & d);\n\t\treturn b ^ c ^ d;\n\t}\n\n\t/**\n\t\tDetermine the appropriate additive constant for the current iteration\n\t**/\n\tfunction kt(t:Int):Int {\n\t\tif (t < 20)\n\t\t\treturn 0x5A827999;\n\t\tif (t < 40)\n\t\t\treturn 0x6ED9EBA1;\n\t\tif (t < 60)\n\t\t\treturn 0x8F1BBCDC;\n\t\treturn 0xCA62C1D6;\n\t}\n\n\tfunction hex(a:Array<Int>) {\n\t\tvar str = \"\";\n\t\tfor (num in a) {\n\t\t\tstr += StringTools.hex(num, 8);\n\t\t}\n\t\treturn str.toLowerCase();\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCreates a MD5 of a String.\n**/\nclass Md5 {\n\tpublic static function encode(s:String):String {\n\t\tvar m = new Md5();\n\t\tvar h = m.doEncode(str2blks(s));\n\t\treturn m.hex(h);\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\tvar h = new Md5().doEncode(bytes2blks(b));\n\t\tvar out = haxe.io.Bytes.alloc(16);\n\t\tvar p = 0;\n\t\tfor (i in 0...4) {\n\t\t\tout.set(p++, h[i] & 0xFF);\n\t\t\tout.set(p++, (h[i] >> 8) & 0xFF);\n\t\t\tout.set(p++, (h[i] >> 16) & 0xFF);\n\t\t\tout.set(p++, h[i] >>> 24);\n\t\t}\n\t\treturn out;\n\t}\n\n\t/*\n\t * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n\t * Digest Algorithm, as defined in RFC 1321.\n\t * Copyright (C) Paul Johnston 1999 - 2000.\n\t * Updated by Greg Holt 2000 - 2001.\n\t * See http://pajhome.org.uk/site/legal.html for details.\n\t */\n\tfunction new() {}\n\n\tfunction bitOR(a, b) {\n\t\tvar lsb = (a & 0x1) | (b & 0x1);\n\t\tvar msb31 = (a >>> 1) | (b >>> 1);\n\t\treturn (msb31 << 1) | lsb;\n\t}\n\n\tfunction bitXOR(a, b) {\n\t\tvar lsb = (a & 0x1) ^ (b & 0x1);\n\t\tvar msb31 = (a >>> 1) ^ (b >>> 1);\n\t\treturn (msb31 << 1) | lsb;\n\t}\n\n\tfunction bitAND(a, b) {\n\t\tvar lsb = (a & 0x1) & (b & 0x1);\n\t\tvar msb31 = (a >>> 1) & (b >>> 1);\n\t\treturn (msb31 << 1) | lsb;\n\t}\n\n\tfunction addme(x, y) {\n\t\tvar lsw = (x & 0xFFFF) + (y & 0xFFFF);\n\t\tvar msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t\treturn (msw << 16) | (lsw & 0xFFFF);\n\t}\n\n\tfunction hex(a:Array<Int>) {\n\t\tvar str = \"\";\n\t\tvar hex_chr = \"0123456789abcdef\";\n\t\tfor (num in a)\n\t\t\tfor (j in 0...4)\n\t\t\t\tstr += hex_chr.charAt((num >> (j * 8 + 4)) & 0x0F) + hex_chr.charAt((num >> (j * 8)) & 0x0F);\n\t\treturn str;\n\t}\n\n\tstatic function bytes2blks(b:haxe.io.Bytes) {\n\t\tvar nblk = ((b.length + 8) >> 6) + 1;\n\t\tvar blks = new Array();\n\n\t\t// preallocate size\n\t\tvar blksSize = nblk * 16;\n\t\t#if (neko || cs || cpp || java || hl)\n\t\tblks[blksSize - 1] = 0;\n\t\t#end\n\n\t\t#if !(cpp || cs || hl) // C++ and C# will already initialize them with zeroes.\n\t\tfor (i in 0...blksSize)\n\t\t\tblks[i] = 0;\n\t\t#end\n\n\t\tvar i = 0;\n\t\twhile (i < b.length) {\n\t\t\tblks[i >> 2] |= b.get(i) << ((((b.length << 3) + i) & 3) << 3);\n\t\t\ti++;\n\t\t}\n\t\tblks[i >> 2] |= 0x80 << (((b.length * 8 + i) % 4) * 8);\n\t\tvar l = b.length * 8;\n\t\tvar k = nblk * 16 - 2;\n\t\tblks[k] = (l & 0xFF);\n\t\tblks[k] |= ((l >>> 8) & 0xFF) << 8;\n\t\tblks[k] |= ((l >>> 16) & 0xFF) << 16;\n\t\tblks[k] |= ((l >>> 24) & 0xFF) << 24;\n\t\treturn blks;\n\t}\n\n\tstatic function str2blks(str:String) {\n\t\t#if target.unicode\n\t\tvar str = haxe.io.Bytes.ofString(str);\n\t\t#end\n\t\tvar nblk = ((str.length + 8) >> 6) + 1;\n\t\tvar blks = new Array();\n\n\t\t// preallocate size\n\t\tvar blksSize = nblk * 16;\n\t\t#if (neko || eval || cs || cpp || java || hl)\n\t\tblks[blksSize - 1] = 0;\n\t\t#end\n\n\t\t#if !(cpp || cs || hl) // C++ and C# will already initialize them with zeroes.\n\t\tfor (i in 0...blksSize)\n\t\t\tblks[i] = 0;\n\t\t#end\n\n\t\tvar i = 0;\n\t\tvar max = str.length;\n\t\tvar l = max * 8;\n\t\twhile (i < max) {\n\t\t\tblks[i >> 2] |= #if target.unicode str.get(i) #else StringTools.fastCodeAt(str, i) #end << (((l + i) % 4) * 8);\n\t\t\ti++;\n\t\t}\n\t\tblks[i >> 2] |= 0x80 << (((l + i) % 4) * 8);\n\t\tvar k = nblk * 16 - 2;\n\t\tblks[k] = (l & 0xFF);\n\t\tblks[k] |= ((l >>> 8) & 0xFF) << 8;\n\t\tblks[k] |= ((l >>> 16) & 0xFF) << 16;\n\t\tblks[k] |= ((l >>> 24) & 0xFF) << 24;\n\t\treturn blks;\n\t}\n\n\tfunction rol(num, cnt) {\n\t\treturn (num << cnt) | (num >>> (32 - cnt));\n\t}\n\n\tfunction cmn(q, a, b, x, s, t) {\n\t\treturn addme(rol((addme(addme(a, q), addme(x, t))), s), b);\n\t}\n\n\tfunction ff(a, b, c, d, x, s, t) {\n\t\treturn cmn(bitOR(bitAND(b, c), bitAND((~b), d)), a, b, x, s, t);\n\t}\n\n\tfunction gg(a, b, c, d, x, s, t) {\n\t\treturn cmn(bitOR(bitAND(b, d), bitAND(c, (~d))), a, b, x, s, t);\n\t}\n\n\tfunction hh(a, b, c, d, x, s, t) {\n\t\treturn cmn(bitXOR(bitXOR(b, c), d), a, b, x, s, t);\n\t}\n\n\tfunction ii(a, b, c, d, x, s, t) {\n\t\treturn cmn(bitXOR(c, bitOR(b, (~d))), a, b, x, s, t);\n\t}\n\n\tfunction doEncode(x:Array<Int>):Array<Int> {\n\t\tvar a = 1732584193;\n\t\tvar b = -271733879;\n\t\tvar c = -1732584194;\n\t\tvar d = 271733878;\n\n\t\tvar step;\n\n\t\tvar i = 0;\n\t\twhile (i < x.length) {\n\t\t\tvar olda = a;\n\t\t\tvar oldb = b;\n\t\t\tvar oldc = c;\n\t\t\tvar oldd = d;\n\n\t\t\tstep = 0;\n\t\t\ta = ff(a, b, c, d, x[i + 0], 7, -680876936);\n\t\t\td = ff(d, a, b, c, x[i + 1], 12, -389564586);\n\t\t\tc = ff(c, d, a, b, x[i + 2], 17, 606105819);\n\t\t\tb = ff(b, c, d, a, x[i + 3], 22, -1044525330);\n\t\t\ta = ff(a, b, c, d, x[i + 4], 7, -176418897);\n\t\t\td = ff(d, a, b, c, x[i + 5], 12, 1200080426);\n\t\t\tc = ff(c, d, a, b, x[i + 6], 17, -1473231341);\n\t\t\tb = ff(b, c, d, a, x[i + 7], 22, -45705983);\n\t\t\ta = ff(a, b, c, d, x[i + 8], 7, 1770035416);\n\t\t\td = ff(d, a, b, c, x[i + 9], 12, -1958414417);\n\t\t\tc = ff(c, d, a, b, x[i + 10], 17, -42063);\n\t\t\tb = ff(b, c, d, a, x[i + 11], 22, -1990404162);\n\t\t\ta = ff(a, b, c, d, x[i + 12], 7, 1804603682);\n\t\t\td = ff(d, a, b, c, x[i + 13], 12, -40341101);\n\t\t\tc = ff(c, d, a, b, x[i + 14], 17, -1502002290);\n\t\t\tb = ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\t\t\ta = gg(a, b, c, d, x[i + 1], 5, -165796510);\n\t\t\td = gg(d, a, b, c, x[i + 6], 9, -1069501632);\n\t\t\tc = gg(c, d, a, b, x[i + 11], 14, 643717713);\n\t\t\tb = gg(b, c, d, a, x[i + 0], 20, -373897302);\n\t\t\ta = gg(a, b, c, d, x[i + 5], 5, -701558691);\n\t\t\td = gg(d, a, b, c, x[i + 10], 9, 38016083);\n\t\t\tc = gg(c, d, a, b, x[i + 15], 14, -660478335);\n\t\t\tb = gg(b, c, d, a, x[i + 4], 20, -405537848);\n\t\t\ta = gg(a, b, c, d, x[i + 9], 5, 568446438);\n\t\t\td = gg(d, a, b, c, x[i + 14], 9, -1019803690);\n\t\t\tc = gg(c, d, a, b, x[i + 3], 14, -187363961);\n\t\t\tb = gg(b, c, d, a, x[i + 8], 20, 1163531501);\n\t\t\ta = gg(a, b, c, d, x[i + 13], 5, -1444681467);\n\t\t\td = gg(d, a, b, c, x[i + 2], 9, -51403784);\n\t\t\tc = gg(c, d, a, b, x[i + 7], 14, 1735328473);\n\t\t\tb = gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\t\t\ta = hh(a, b, c, d, x[i + 5], 4, -378558);\n\t\t\td = hh(d, a, b, c, x[i + 8], 11, -2022574463);\n\t\t\tc = hh(c, d, a, b, x[i + 11], 16, 1839030562);\n\t\t\tb = hh(b, c, d, a, x[i + 14], 23, -35309556);\n\t\t\ta = hh(a, b, c, d, x[i + 1], 4, -1530992060);\n\t\t\td = hh(d, a, b, c, x[i + 4], 11, 1272893353);\n\t\t\tc = hh(c, d, a, b, x[i + 7], 16, -155497632);\n\t\t\tb = hh(b, c, d, a, x[i + 10], 23, -1094730640);\n\t\t\ta = hh(a, b, c, d, x[i + 13], 4, 681279174);\n\t\t\td = hh(d, a, b, c, x[i + 0], 11, -358537222);\n\t\t\tc = hh(c, d, a, b, x[i + 3], 16, -722521979);\n\t\t\tb = hh(b, c, d, a, x[i + 6], 23, 76029189);\n\t\t\ta = hh(a, b, c, d, x[i + 9], 4, -640364487);\n\t\t\td = hh(d, a, b, c, x[i + 12], 11, -421815835);\n\t\t\tc = hh(c, d, a, b, x[i + 15], 16, 530742520);\n\t\t\tb = hh(b, c, d, a, x[i + 2], 23, -995338651);\n\t\t\ta = ii(a, b, c, d, x[i + 0], 6, -198630844);\n\t\t\td = ii(d, a, b, c, x[i + 7], 10, 1126891415);\n\t\t\tc = ii(c, d, a, b, x[i + 14], 15, -1416354905);\n\t\t\tb = ii(b, c, d, a, x[i + 5], 21, -57434055);\n\t\t\ta = ii(a, b, c, d, x[i + 12], 6, 1700485571);\n\t\t\td = ii(d, a, b, c, x[i + 3], 10, -1894986606);\n\t\t\tc = ii(c, d, a, b, x[i + 10], 15, -1051523);\n\t\t\tb = ii(b, c, d, a, x[i + 1], 21, -2054922799);\n\t\t\ta = ii(a, b, c, d, x[i + 8], 6, 1873313359);\n\t\t\td = ii(d, a, b, c, x[i + 15], 10, -30611744);\n\t\t\tc = ii(c, d, a, b, x[i + 6], 15, -1560198380);\n\t\t\tb = ii(b, c, d, a, x[i + 13], 21, 1309151649);\n\t\t\ta = ii(a, b, c, d, x[i + 4], 6, -145523070);\n\t\t\td = ii(d, a, b, c, x[i + 11], 10, -1120210379);\n\t\t\tc = ii(c, d, a, b, x[i + 2], 15, 718787259);\n\t\t\tb = ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n\t\t\ta = addme(a, olda);\n\t\t\tb = addme(b, oldb);\n\t\t\tc = addme(c, oldc);\n\t\t\td = addme(d, oldd);\n\n\t\t\ti += 16;\n\t\t}\n\t\treturn [a, b, c, d];\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tHash methods for Hmac calculation.\n**/\nenum HashMethod {\n\tMD5;\n\tSHA1;\n\tSHA256;\n}\n\n/**\n\tCalculates a Hmac of the given Bytes using a HashMethod.\n**/\nclass Hmac {\n\tvar method:HashMethod;\n\tvar blockSize:Int;\n\tvar length:Int;\n\n\tpublic function new(hashMethod:HashMethod) {\n\t\tmethod = hashMethod;\n\t\tblockSize = switch (hashMethod) {\n\t\t\tcase MD5, SHA1, SHA256: 64;\n\t\t}\n\t\tlength = switch (hashMethod) {\n\t\t\tcase MD5: 16;\n\t\t\tcase SHA1: 20;\n\t\t\tcase SHA256: 32;\n\t\t}\n\t}\n\n\tinline function doHash(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\treturn switch (method) {\n\t\t\tcase MD5: Md5.make(b);\n\t\t\tcase SHA1: Sha1.make(b);\n\t\t\tcase SHA256: Sha256.make(b);\n\t\t}\n\t}\n\n\tfunction nullPad(s:haxe.io.Bytes, chunkLen:Int):haxe.io.Bytes {\n\t\tvar r = chunkLen - (s.length % chunkLen);\n\t\tif (r == chunkLen && s.length != 0)\n\t\t\treturn s;\n\t\tvar sb = new haxe.io.BytesBuffer();\n\t\tsb.add(s);\n\t\tfor (x in 0...r)\n\t\t\tsb.addByte(0);\n\t\treturn sb.getBytes();\n\t}\n\n\tpublic function make(key:haxe.io.Bytes, msg:haxe.io.Bytes):haxe.io.Bytes {\n\t\tif (key.length > blockSize) {\n\t\t\tkey = doHash(key);\n\t\t}\n\t\tkey = nullPad(key, blockSize);\n\n\t\tvar Ki = new haxe.io.BytesBuffer();\n\t\tvar Ko = new haxe.io.BytesBuffer();\n\t\tfor (i in 0...key.length) {\n\t\t\tKo.addByte(key.get(i) ^ 0x5c);\n\t\t\tKi.addByte(key.get(i) ^ 0x36);\n\t\t}\n\t\t// hash(Ko + hash(Ki + message))\n\t\tKi.add(msg);\n\t\tKo.add(doHash(Ki.getBytes()));\n\t\treturn doHash(Ko.getBytes());\n\t}\n}\n"]}