{"sourceRoot":"","names":[],"mappings":"QAyBA;;ACEA;;;;CAKC,kBDPD;CCkBC,eDlBD;CCuDC,eDvDD;CCsFC,gBC1FgB;CDkGhB,gBClGgB;QD0GhB,UC1GgB;QD+GhB,UC/GgB","version":3,"file":"BaseCode.d.ts.map","sources":["../../../../../../../haxe/versions/4.1.1/std/js/_std/haxe/io/Bytes.hx","../../../../../../../haxe/versions/4.1.1/std/haxe/crypto/BaseCode.hx","../../../../../../../haxe/versions/4.1.1/std/js/_std/String.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tAllows one to encode/decode String and bytes using a power of two base dictionary.\n**/\nclass BaseCode {\n\tvar base:haxe.io.Bytes;\n\tvar nbits:Int;\n\tvar tbl:Array<Int>;\n\n\tpublic function new(base:haxe.io.Bytes) {\n\t\tvar len = base.length;\n\t\tvar nbits = 1;\n\t\twhile (len > 1 << nbits)\n\t\t\tnbits++;\n\t\tif (nbits > 8 || len != 1 << nbits)\n\t\t\tthrow \"BaseCode : base length must be a power of two.\";\n\t\tthis.base = base;\n\t\tthis.nbits = nbits;\n\t}\n\n\tpublic function encodeBytes(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData(base_encode(b.getData(), base.getData()));\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tvar size = Std.int(b.length * 8 / nbits);\n\t\tvar out = haxe.io.Bytes.alloc(size + (((b.length * 8) % nbits == 0) ? 0 : 1));\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar mask = (1 << nbits) - 1;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile (pout < size) {\n\t\t\twhile (curbits < nbits) {\n\t\t\t\tcurbits += 8;\n\t\t\t\tbuf <<= 8;\n\t\t\t\tbuf |= b.get(pin++);\n\t\t\t}\n\t\t\tcurbits -= nbits;\n\t\t\tout.set(pout++, base.get((buf >> curbits) & mask));\n\t\t}\n\t\tif (curbits > 0)\n\t\t\tout.set(pout++, base.get((buf << (nbits - curbits)) & mask));\n\t\treturn out;\n\t\t#end\n\t}\n\n\tfunction initTable() {\n\t\tvar tbl = new Array();\n\t\tfor (i in 0...256)\n\t\t\ttbl[i] = -1;\n\t\tfor (i in 0...base.length)\n\t\t\ttbl[base.get(i)] = i;\n\t\tthis.tbl = tbl;\n\t}\n\n\tpublic function decodeBytes(b:haxe.io.Bytes):haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData(base_decode(b.getData(), base.getData()));\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tif (this.tbl == null)\n\t\t\tinitTable();\n\t\tvar tbl = this.tbl;\n\t\tvar size = (b.length * nbits) >> 3;\n\t\tvar out = haxe.io.Bytes.alloc(size);\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile (pout < size) {\n\t\t\twhile (curbits < 8) {\n\t\t\t\tcurbits += nbits;\n\t\t\t\tbuf <<= nbits;\n\t\t\t\tvar i = tbl[b.get(pin++)];\n\t\t\t\tif (i == -1)\n\t\t\t\t\tthrow \"BaseCode : invalid encoded char\";\n\t\t\t\tbuf |= i;\n\t\t\t}\n\t\t\tcurbits -= 8;\n\t\t\tout.set(pout++, (buf >> curbits) & 0xFF);\n\t\t}\n\t\treturn out;\n\t\t#end\n\t}\n\n\tpublic function encodeString(s:String) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString(base_encode(neko.NativeString.ofString(s), base.getData()));\n\t\t#else\n\t\treturn encodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic function decodeString(s:String) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString(base_decode(neko.NativeString.ofString(s), base.getData()));\n\t\t#else\n\t\treturn decodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic static function encode(s:String, base:String) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.encodeString(s);\n\t}\n\n\tpublic static function decode(s:String, base:String) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.decodeString(s);\n\t}\n\n\t#if neko\n\tprivate static var base_encode = neko.Lib.load(\"std\", \"base_encode\", 2);\n\tprivate static var base_decode = neko.Lib.load(\"std\", \"base_decode\", 2);\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi extern class String {\n\tvar length(default, null):Int;\n\n\t@:pure function new(string:String):Void;\n\t@:pure function toUpperCase():String;\n\t@:pure function toLowerCase():String;\n\t@:pure function charAt(index:Int):String;\n\t@:pure function indexOf(str:String, ?startIndex:Int):Int;\n\t@:pure function lastIndexOf(str:String, ?startIndex:Int):Int;\n\t@:pure function split(delimiter:String):Array<String>;\n\t@:pure function toString():String;\n\t@:pure function substring(startIndex:Int, ?endIndex:Int):String;\n\n\t@:pure inline function charCodeAt(index:Int):Null<Int> {\n\t\treturn @:privateAccess HxOverrides.cca(this, index);\n\t}\n\n\t@:pure inline function substr(pos:Int, ?len:Int):String {\n\t\treturn @:privateAccess HxOverrides.substr(this, pos, len);\n\t}\n\n\t@:pure static inline function fromCharCode(code:Int):String {\n\t\treturn untyped __define_feature__('String.fromCharCode', js.Syntax.code(\"String.fromCodePoint({0})\", code));\n\t}\n\n\tstatic function __init__():Void {\n\t\tuntyped __feature__('String.fromCharCode',\n\t\t\tjs.Syntax.code(\"if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }\"));\n\t}\n}\n"]}