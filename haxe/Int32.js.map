{"sourceRoot":"","names":[],"mappings":"QAKA;;;;ACwBA;AAAA;CACU,qBACR;EAAA,AAAO,OAAM,CAAC,QAAO,IAAd;;CAEE,2BACT,CAAc;EAAA,AAAP,QAAO,AAAM,EAAE,QAAR,EAAd;EAAA,AAAO;;CAEE,4BAA8C,CAC7C;EAAA,kBACV;EAAA,SAAO,EACP;EAAA,AAAO;;CAGE,2BACT,CAAc;EAAA,AAAP,QAAO,AAAM,EAAE,QAAR,EAAd;EAAA,AAAO;;CAEE,4BAA8C,CAC7C;EAAA,kBACV;EAAA,SAAO,EACP;EAAA,AAAO;;CAGI,iBACX;EAAA,AAAO,OAAM,AAAC,IAAW,AAAC,IAAnB;;CAEkB,oBACzB;EAAA,AAAO,OAAM,AAAC,IAAW,IAAlB;;CAII,iBACX;EAAA,AAAO,OAAM,AAAC,IAAW,AAAC,IAAnB;;CAEI,oBACX;EAAA,AAAO,OAAM,AAAC,IAAW,IAAlB;;CAEI,oBACX;EAAA,AAAO,OAAM,IAAY,AAAC,IAAnB;;CAWI,iBACX;EAAA,AAAO,kBAAK,GAAG;;CAWU,oBACzB;EAAA,AAAO,kBAAI,GAAG;;CA6JV,sBACJ;EAAA,AAAO;;;;;;CAKR,sBAAsD,CACrD;EAAA,GAAI,KAAI,GACA;GAAA,QAAI,GAAI;IAAA,OAAC,CAAC,IAAD,AAAK,CAAC,IAAN;IAAW;IAAA;;IACrB;EAAA,QAAI,GAAI;GAAA;GAAK;GAAA,OAAC,IAAI,IAAJ;;;CAQtB,gBAKC;EAAA,AAAO,WAAI;;;;;;;;;;;AA7LZ,aAA8C,AAAI,cAAa,QAC7D,YAEA,gBAAiC;CAAA,AAAO,OAAM,AAAC,IAAW,CAAC,AAAC,IAAW,SAAU,CAAM,AAAC,IAAW,CAAC,AAAC,MAAa,OAAO,KAAxC,KAAzC","version":3,"file":"Int32.js.map","sources":["../../../../../../haxe/haxe_libraries/genes/0.4.1/github/179cb495c2d785321879e8afe765aa04d639783d/src/genes/Register.hx","../../../../../../haxe/versions/4.2.2/std/haxe/Int32.hx"],"sourcesContent":["package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : undefined');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a)) js.Syntax.code('a.iterator()') else\n      untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tInt32 provides a 32-bit integer with consistent overflow behavior across\n\tall platforms.\n**/\n@:transitive\nabstract Int32(Int) from Int to Int {\n\t@:op(-A) private inline function negate():Int32\n\t\treturn clamp(~this + 1);\n\n\t@:op(++A) private inline function preIncrement():Int32\n\t\treturn this = clamp(++this);\n\n\t@:op(A++) private inline function postIncrement():Int32 {\n\t\tvar ret = this++;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int32\n\t\treturn this = clamp(--this);\n\n\t@:op(A--) private inline function postDecrement():Int32 {\n\t\tvar ret = this--;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(A + B) private static inline function add(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static function addFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) private static inline function sub(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function subInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static function subFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) private static function floatSub(a:Float, b:Int32):Float;\n\n\t#if (js || php || python || lua)\n\t#if js\n\t// on JS we want to try using Math.imul, but we have to assign that function to Int32.mul only once,\n\t// or else V8 will deoptimize it, so we need to be a bit funky with this.\n\t// See https://github.com/HaxeFoundation/haxe/issues/5367 for benchmarks.\n\t@:op(A * B) inline static function mul(a:Int32, b:Int32):Int32\n\t\treturn _mul(a, b);\n\n\tstatic var _mul:Int32->Int32->Int32 = untyped if (Math.imul != null)\n\t\t\tMath.imul\n\t\telse\n\t\t\tfunction(a:Int32, b:Int32):Int32 return clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#end\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int32, b:Int):Int32\n\t\treturn mul(a, b);\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32;\n\n\t@:op(A * B) @:commutative private static function mulInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t@:op(A * B) @:commutative private static function mulFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function div(a:Int32, b:Int32):Float;\n\n\t@:op(A / B) private static function divInt(a:Int32, b:Int):Float;\n\n\t@:op(A / B) private static function intDiv(a:Int, b:Int32):Float;\n\n\t@:op(A / B) private static function divFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function floatDiv(a:Float, b:Int32):Float;\n\n\t@:op(A % B) private static function mod(a:Int32, b:Int32):Int32;\n\n\t@:op(A % B) private static function modInt(a:Int32, b:Int):Int;\n\n\t@:op(A % B) private static function intMod(a:Int, b:Int32):Int;\n\n\t@:op(A % B) private static function modFloat(a:Int32, b:Float):Float;\n\n\t@:op(A % B) private static function floatMod(a:Float, b:Int32):Float;\n\n\t@:op(A == B) private static function eq(a:Int32, b:Int32):Bool;\n\n\t@:op(A == B) @:commutative private static function eqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A == B) @:commutative private static function eqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A != B) private static function neq(a:Int32, b:Int32):Bool;\n\n\t@:op(A != B) @:commutative private static function neqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A != B) @:commutative private static function neqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function lt(a:Int32, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltInt(a:Int32, b:Int):Bool;\n\n\t@:op(A < B) private static function intLt(a:Int, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function floatLt(a:Float, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lte(a:Int32, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A <= B) private static function intLte(a:Int, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A <= B) private static function floatLte(a:Float, b:Int32):Bool;\n\n\t@:op(A > B) private static function gt(a:Int32, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtInt(a:Int32, b:Int):Bool;\n\n\t@:op(A > B) private static function intGt(a:Int, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A > B) private static function floatGt(a:Float, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gte(a:Int32, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A >= B) private static function intGte(a:Int, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A >= B) private static function floatGte(a:Float, b:Int32):Bool;\n\n\t#if (lua || python || php)\n\t@:op(~A) private static inline function complement(a:Int32):Int32\n\t\t#if lua return lua.Boot.clampInt32(~a); #else return clamp(~a); #end\n\t#else\n\t@:op(~A) private function complement():Int32;\n\t#end\n\n\t@:op(A & B) private static function and(a:Int32, b:Int32):Int32;\n\n\t@:op(A & B) @:commutative private static function andInt(a:Int32, b:Int):Int32;\n\n\t#if (lua || python || php)\n\t@:op(A | B) private static #if (python || php) inline #end function or(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) | (b : Int));\n\n\t@:op(A | B) @:commutative private #if (python || php) inline #end static function orInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) | b);\n\t#else\n\t@:op(A | B) private static function or(a:Int32, b:Int32):Int32;\n\n\t@:op(A | B) @:commutative private static function orInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A ^ B) private static #if (python || php) inline #end function xor(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) ^ (b : Int));\n\n\t@:op(A ^ B) @:commutative private static #if (python || php) inline #end function xorInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) ^ b);\n\t#else\n\t@:op(A ^ B) private static function xor(a:Int32, b:Int32):Int32;\n\n\t@:op(A ^ B) @:commutative private static function xorInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A >> B) private static #if (python || php) inline #end function shr(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) >> (b : Int));\n\n\t@:op(A >> B) private static #if (python || php) inline #end function shrInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) >> b);\n\n\t@:op(A >> B) private static #if (python || php) inline #end function intShr(a:Int, b:Int32):Int32\n\t\treturn clamp(a >> (b : Int));\n\t#else\n\t@:op(A >> B) private static function shr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >> B) private static function shrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >> B) private static function intShr(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:op(A >>> B) private static function ushr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >>> B) private static function ushrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >>> B) private static function intUshr(a:Int, b:Int32):Int32;\n\n\t#if (php || python || lua)\n\t// PHP may be 64-bit, so shifts must be clamped\n\t@:op(A << B) private static inline function shl(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) << (b : Int));\n\n\t@:op(A << B) private static inline function shlInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) << b);\n\n\t@:op(A << B) private static inline function intShl(a:Int, b:Int32):Int32\n\t\treturn clamp(a << (b : Int));\n\t#else\n\t@:op(A << B) private static function shl(a:Int32, b:Int32):Int32;\n\n\t@:op(A << B) private static function shlInt(a:Int32, b:Int):Int32;\n\n\t@:op(A << B) private static function intShl(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:to private inline function toFloat():Float\n\t\treturn this;\n\n\t/**\n\t\tCompare `a` and `b` in unsigned mode.\n\t**/\n\tpublic static function ucompare(a:Int32, b:Int32):Int {\n\t\tif (a < 0)\n\t\t\treturn b < 0 ? (~b - ~a) : 1;\n\t\treturn b < 0 ? -1 : (a - b);\n\t}\n\n\t#if php\n\tstatic var extraBits:Int = php.Const.PHP_INT_SIZE * 8 - 32;\n\t#end\n\n\t#if !lua\n\tinline\n\t#end\n\tstatic function clamp(x:Int):Int {\n\t\t// force to-int conversion on platforms that require it\n\t\t#if js\n\t\treturn x | 0;\n\t\t#elseif php\n\t\t// we might be on 64-bit php, so sign extend from 32-bit\n\t\treturn (x << extraBits) >> extraBits;\n\t\t#elseif python\n\t\treturn (python.Syntax.code(\"{0} % {1}\", (x + python.Syntax.opPow(2, 31)), python.Syntax.opPow(2, 32)) : Int) - python.Syntax.opPow(2, 31);\n\t\t#elseif lua\n\t\treturn lua.Boot.clampInt32(x);\n\t\t#else\n\t\treturn (x);\n\t\t#end\n\t}\n}\n"]}