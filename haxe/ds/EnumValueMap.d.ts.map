{"sourceRoot":"","names":[],"mappings":"QAkCA;QCgCA;;;;;;;;ACpCA,kCAAmB,GAAa,EAAhC,SFIA,aEJmB,GAAa,cDoChC,KCpCmB,GAAa;CAAhC;CAkCC,QAlCD,aAAmB,GAAa","version":3,"file":"EnumValueMap.d.ts.map","sources":["../../../../../../../haxe/versions/4.1.1/std/haxe/ds/BalancedTree.hx","../../../../../../../haxe/versions/4.1.1/std/haxe/Constraints.hx","../../../../../../../haxe/versions/4.1.1/std/haxe/ds/EnumValueMap.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n/**\n\tBalancedTree allows key-value mapping with arbitrary keys, as long as they\n\tcan be ordered. By default, `Reflect.compare` is used in the `compare`\n\tmethod, which can be overridden in subclasses.\n\n\tOperations have a logarithmic average and worst-case cost.\n\n\tIteration over keys and values, using `keys` and `iterator` respectively,\n\tare in-order.\n**/\nclass BalancedTree<K, V> implements haxe.Constraints.IMap<K, V> {\n\tvar root:TreeNode<K, V>;\n\n\t/**\n\t\tCreates a new BalancedTree, which is initially empty.\n\t**/\n\tpublic function new() {}\n\n\t/**\n\t\tBinds `key` to `value`.\n\n\t\tIf `key` is already bound to a value, that binding disappears.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function set(key:K, value:V) {\n\t\troot = setLoop(key, value, root);\n\t}\n\n\t/**\n\t\tReturns the value `key` is bound to.\n\n\t\tIf `key` is not bound to any value, `null` is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function get(key:K):Null<V> {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn node.value;\n\t\t\tif (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tRemoves the current binding of `key`.\n\n\t\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\t\treturned.\n\n\t\tOtherwise the binding of `key` is removed and true is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function remove(key:K) {\n\t\ttry {\n\t\t\troot = removeLoop(key, root);\n\t\t\treturn true;\n\t\t} catch (e:String) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t\tTells if `key` is bound to a value.\n\n\t\tThis method returns true even if `key` is bound to null.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function exists(key:K) {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn true;\n\t\t\telse if (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tIterates over the bound values of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n\t**/\n\tpublic function iterator():Iterator<V> {\n\t\tvar ret = [];\n\t\titeratorLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tSee `Map.keyValueIterator`\n\t**/\n\t@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\t/**\n\t\tIterates over the keys of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n\t**/\n\tpublic function keys():Iterator<K> {\n\t\tvar ret = [];\n\t\tkeysLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\tpublic function copy():BalancedTree<K, V> {\n\t\tvar copied = new BalancedTree<K, V>();\n\t\tcopied.root = root;\n\t\treturn copied;\n\t}\n\n\tfunction setLoop(k:K, v:V, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\treturn new TreeNode<K, V>(null, k, v, null);\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) new TreeNode<K, V>(node.left, k, v, node.right, node.get_height()); else if (c < 0) {\n\t\t\tvar nl = setLoop(k, v, node.left);\n\t\t\tbalance(nl, node.key, node.value, node.right);\n\t\t} else {\n\t\t\tvar nr = setLoop(k, v, node.right);\n\t\t\tbalance(node.left, node.key, node.value, nr);\n\t\t}\n\t}\n\n\tfunction removeLoop(k:K, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\tthrow \"Not_found\";\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) merge(node.left,\n\t\t\tnode.right); else if (c < 0) balance(removeLoop(k, node.left), node.key, node.value,\n\t\t\tnode.right); else balance(node.left, node.key, node.value, removeLoop(k, node.right));\n\t}\n\n\tstatic function iteratorLoop<K,V>(node:TreeNode<K, V>, acc:Array<V>) {\n\t\tif (node != null) {\n\t\t\titeratorLoop(node.left, acc);\n\t\t\tacc.push(node.value);\n\t\t\titeratorLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction keysLoop(node:TreeNode<K, V>, acc:Array<K>) {\n\t\tif (node != null) {\n\t\t\tkeysLoop(node.left, acc);\n\t\t\tacc.push(node.key);\n\t\t\tkeysLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction merge(t1, t2) {\n\t\tif (t1 == null)\n\t\t\treturn t2;\n\t\tif (t2 == null)\n\t\t\treturn t1;\n\t\tvar t = minBinding(t2);\n\t\treturn balance(t1, t.key, t.value, removeMinBinding(t2));\n\t}\n\n\tfunction minBinding(t:TreeNode<K, V>) {\n\t\treturn if (t == null) throw \"Not_found\"; else if (t.left == null) t; else minBinding(t.left);\n\t}\n\n\tfunction removeMinBinding(t:TreeNode<K, V>) {\n\t\treturn if (t.left == null) t.right; else balance(removeMinBinding(t.left), t.key, t.value, t.right);\n\t}\n\n\tfunction balance(l:TreeNode<K, V>, k:K, v:V, r:TreeNode<K, V>):TreeNode<K, V> {\n\t\tvar hl = l.get_height();\n\t\tvar hr = r.get_height();\n\t\treturn if (hl > hr + 2) {\n\t\t\tif (l.left.get_height() >= l.right.get_height())\n\t\t\t\tnew TreeNode<K, V>(l.left, l.key, l.value, new TreeNode<K, V>(l.right, k, v, r));\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value,\n\t\t\t\t\tnew TreeNode<K, V>(l.right.right, k, v, r));\n\t\t} else if (hr > hl + 2) {\n\t\t\tif (r.right.get_height() > r.left.get_height())\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left), r.key, r.value, r.right);\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left.left), r.left.key, r.left.value,\n\t\t\t\t\tnew TreeNode<K, V>(r.left.right, r.key, r.value, r.right));\n\t\t} else {\n\t\t\tnew TreeNode<K, V>(l, k, v, r, (hl > hr ? hl : hr) + 1);\n\t\t}\n\t}\n\n\tfunction compare(k1:K, k2:K) {\n\t\treturn Reflect.compare(k1, k2);\n\t}\n\n\tpublic function toString() {\n\t\treturn root == null ? '{}' : '{${root.toString()}}';\n\t}\n\n\t/**\n\t\tRemoves all keys from `this` BalancedTree.\n\t**/\n\tpublic function clear():Void {\n\t\troot = null;\n\t}\n}\n\n/**\n\tA tree node of `haxe.ds.BalancedTree`.\n**/\nclass TreeNode<K, V> {\n\tpublic var left:TreeNode<K, V>;\n\tpublic var right:TreeNode<K, V>;\n\tpublic var key:K;\n\tpublic var value:V;\n\n\tvar _height:Int;\n\n\tpublic function new(l, k, v, r, h = -1) {\n\t\tleft = l;\n\t\tkey = k;\n\t\tvalue = v;\n\t\tright = r;\n\t\tif (h == -1)\n\t\t\t_height = (left.get_height() > right.get_height() ? left.get_height() : right.get_height()) + 1;\n\t\telse\n\t\t\t_height = h;\n\t}\n\n\textern public inline function get_height()\n\t\treturn this == null ? 0 : _height;\n\n\tpublic function toString() {\n\t\treturn (left == null ? \"\" : left.toString() + \", \") + '$key=$value' + (right == null ? \"\" : \", \" + right.toString());\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tThis type unifies with any function type.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\n@:callable\nabstract Function(Dynamic) {}\n\n/**\n\tThis type unifies with an enum instance if all constructors of the enum\n\trequire no arguments.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract FlatEnum(Dynamic) {}\n\n/**\n\tThis type unifies with anything but `Void`.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract NotVoid(Dynamic) { }\n\n/**\n\tThis type unifies with any instance of classes that have a constructor\n\twhich\n\n\t  * is `public` and\n\t  * unifies with the type used for type parameter `T`.\n\n\tIf a type parameter `A` is assigned to a type parameter `B` which is constrained\n\tto `Constructible<T>`, A must be explicitly constrained to\n\t`Constructible<T>` as well.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract Constructible<T>(Dynamic) {}\n\ninterface IMap<K, V> {\n\tfunction get(k:K):Null<V>;\n\tfunction set(k:K, v:V):Void;\n\tfunction exists(k:K):Bool;\n\tfunction remove(k:K):Bool;\n\tfunction keys():Iterator<K>;\n\tfunction iterator():Iterator<V>;\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n\tfunction copy():IMap<K, V>;\n\tfunction toString():String;\n\tfunction clear():Void;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n/**\n\tEnumValueMap allows mapping of enum value keys to arbitrary values.\n\n\tKeys are compared by value and recursively over their parameters. If any\n\tparameter is not an enum value, `Reflect.compare` is used to compare them.\n**/\nclass EnumValueMap<K:EnumValue, V> extends haxe.ds.BalancedTree<K, V> implements haxe.Constraints.IMap<K, V> {\n\toverride function compare(k1:EnumValue, k2:EnumValue):Int {\n\t\tvar d = k1.getIndex() - k2.getIndex();\n\t\tif (d != 0)\n\t\t\treturn d;\n\t\tvar p1 = k1.getParameters();\n\t\tvar p2 = k2.getParameters();\n\t\tif (p1.length == 0 && p2.length == 0)\n\t\t\treturn 0;\n\t\treturn compareArgs(p1, p2);\n\t}\n\n\tfunction compareArgs(a1:Array<Dynamic>, a2:Array<Dynamic>):Int {\n\t\tvar ld = a1.length - a2.length;\n\t\tif (ld != 0)\n\t\t\treturn ld;\n\t\tfor (i in 0...a1.length) {\n\t\t\tvar d = compareArg(a1[i], a2[i]);\n\t\t\tif (d != 0)\n\t\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction compareArg(v1:Dynamic, v2:Dynamic):Int {\n\t\treturn if (Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {\n\t\t\tcompare(v1, v2);\n\t\t} else if (Std.isOfType(v1, Array) && Std.isOfType(v2, Array)) {\n\t\t\tcompareArgs(v1, v2);\n\t\t} else {\n\t\t\tReflect.compare(v1, v2);\n\t\t}\n\t}\n\n\toverride function copy():EnumValueMap<K, V> {\n\t\tvar copied = new EnumValueMap<K, V>();\n\t\tcopied.root = root;\n\t\treturn copied;\n\t}\n}\n"]}