{"sourceRoot":"","names":[],"mappings":"QA8BA;QCHA;QCFA;QCpBA;QC6DA;QC7DA;QCqBU;QCLA;;;;;;;;;;;;ACaV;AAAA;CAMC,MAAsB;;;;;;;;;;CAStB,gBACC;EAAA,YAAO,aAAQ,KAAK,OAAO;;;;;;;;;;CAU5B,SAAmC,CAClC;EAAA,WAAW,UACX;EAAA,MAAO,SAAQ,MAAf,CACC;GAAA,QAAQ,aAAQ,KAAK,UACrB;GAAA,GAAI,MAAK,GACR;IAAA,AAAO;KACR;GAAA,GAAI,KAAI,GACP;IAAA,OAAO;IAEP;IAAA,OAAO;;IAET;EAAA,AAAO;;;;;;;;;;;;;CAaR,YACC;EAAA,IAAI,CACH;GAAA,YAAO,gBAAW,KAAK,WACvB;GAAA,AAAO;cAFR;mCAAA;GAAA,GAGS,oDACR;IAAA,AAAO;IAJR;IAAA;;;;;;;;;;;;CAeD,YAA8B,CAC7B;EAAA,WAAW,UACX;EAAA,MAAO,SAAQ,MAAf,CACC;GAAA,QAAQ,aAAQ,KAAK,UACrB;GAAA,GAAI,MAAK,GACR;IAAA,AAAO;IACH,SAAI,KAAI,GACZ;IAAA,OAAO;IAEP;IAAA,OAAO;;IAET;EAAA,AAAO;;;;;;;;CAQR,WAAuC,CACtC;EAAA,UAAU,GACV;EAAA,0BAAa,WAAM,KACnB;EAAA,AAAO;;;;;;CAME,mBACT;EAAA,AAAO,+BAAuC;;;;;;;;CAQ/C,OAAmC,CAClC;EAAA,UAAU,GACV;EAAA,cAAS,WAAM,KACf;EAAA,AAAO;;CAGR,OAA0C,CACzC;EAAA,aAAa,mBACb;EAAA,cAAc,UACd;EAAA,AAAO;;CAGR,oBAAgD,CAC/C;EAAA,GAAI,SAAQ,MACX;GAAA,AAAO,oBAAmB,MAAM,GAAG,GAAG;IACvC;EAAA,QAAQ,aAAQ,GAAG,UACZ;EAAA,GAAI,MAAK,GAAG;GAAA,oBAAmB,WAAW,GAAG,GAAG,YAAY;GAAyB,SAAI,KAAI,GAAG,CACtG;GAAA,SAAS,aAAQ,GAAG,GAAG,WACvB;GAAA,oBAAQ,IAAI,UAAU,YAAY;GAC5B,OACN;GAAA,SAAS,aAAQ,GAAG,GAAG,YACvB;GAAA,oBAAQ,WAAW,UAAU,YAAY;;;CAI3C,oBAA8C,CAC7C;EAAA,GAAI,SAAQ,MACX;GAAA,uBAAM;IACP;EAAA,QAAQ,aAAQ,GAAG,UACZ;EAAA,GAAI,MAAK,GAAG;GAAA,kBAAM,WACxB;GAAkB,SAAI,KAAI,GAAG;GAAA,oBAAQ,gBAAW,GAAG,YAAY,UAAU,YACzE;GAAkB;GAAA,oBAAQ,WAAW,UAAU,YAAY,gBAAW,GAAG;;;CAW3E,oBACC;EAAA,GAAI,SAAQ,MAAM,CACjB;GAAA,cAAS,WAAW,KACpB;GAAA,SAAS,UACT;GAAA,cAAS,YAAY;;;CAIvB,cAAuB,CACtB;EAAA,GAAI,OAAM,MACT;GAAA,AAAO;IACR;EAAA,GAAI,OAAM,MACT;GAAA,AAAO;IACR;EAAA,QAAQ,gBAAW,IACnB;EAAA,AAAO,oBAAQ,IAAI,OAAO,SAAS,sBAAiB;;CAGrD,cACQ;EAAA,GAAI,MAAK,MAAM;GAAA,uBAAM;GAAkB,SAAI,WAAU,MAAM;GAAA;GAAQ;GAAA,uBAAW;;;CAGtF,oBACQ;EAAA,GAAI,WAAU,MAAM;GAAA;GAAc;GAAA,oBAAQ,sBAAiB,SAAS,OAAO,SAAS;;;CAG5F,oBAA8E,CAC7E;EAAA,SAAS,4BACT;EAAA,SAAS,4BACF;EAAA,GAAI,MAAK,KAAK,GACpB,CAAI;GAAA,mBAAuB;GAAA,qBAA3B;GAAA,GAAI,0CAAuB,yCAC1B;IAAA,oBAAmB,QAAQ,OAAO,SAAS,aAAmB,SAAS,GAAG,GAAG;IAE7E;IAAA,oBAAmB,aAAmB,QAAQ,OAAO,SAAS,eAAe,aAAa,eACzF,aAAmB,eAAe,GAAG,GAAG;;GACpC,SAAI,MAAK,KAAK,GACpB,CAAI;GAAA,oBAAuB;GAAA,oBAA3B;GAAA,GAAI,yCAAuB,yCAC1B;IAAA,oBAAmB,aAAmB,GAAG,GAAG,GAAG,SAAS,OAAO,SAAS;IAExE;IAAA,oBAAmB,aAAmB,GAAG,GAAG,GAAG,cAAc,YAAY,cACxE,aAAmB,cAAc,OAAO,SAAS;;GAEnD;GAAA,oBAAmB,GAAG,GAAG,GAAG,GAAG,CAAC,MAAK,MAAK,KAAK,MAAM;;;CAIvD,gBACC;EAAA,AAAO,uBAAgB,IAAI;;CAG5B,WACQ;EAAA,iBAAQ,MAAQ;GAAA;GAAO;GAAA,aAAG,uBAAgB;;;;;;;CAMlD,QACC;EAAA,YAAO;;CAjER,+BACC;EAAA,GAAI,SAAQ,MAAM,CACjB;GAAA,0BAAa,WAAW,KACxB;GAAA,SAAS,YACT;GAAA,0BAAa,YAAY;;;;;;;;;;;;;;;;;;AAoE5B;AAAA;CAQC,oBAAoC,IAAI,CACvC;EAAA,YAAO,EACP;EAAA,WAAM,EACN;EAAA,aAAQ,EACR;EAAA,aAAQ,EACR;EAAA,GAAI,MAAK,IACR,CAAU;GAAA,QAAC;GAAA,sBAAoB;GAAA,wBAArB;GAAA,GAAC,yCAAoB,yCAAqB;IAAA,sBAA1C;IAAA,MAA0C;IAAoB;IAAA,uBAA9D;IAAA,MAA8D;KAAxE;GAAA,eAAU,MAAoF;GAE9F;GAAA,eAAU;;;CAMZ,WACC;EAAA,AAAO,QAAC,cAAQ,QAAO,KAAK,uBAAkB,QAAS,MAAC,uBAAG,MAAE,0BAAS,CAAC,eAAS,QAAO,KAAK,OAAO","version":3,"file":"BalancedTree.js.map","sources":["../../../../../../../haxe/versions/4.1.3/std/haxe/iterators/MapKeyValueIterator.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/iterators/ArrayIterator.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/NativeStackTrace.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/Constraints.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/Reflect.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/ds/BalancedTree.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\nimport haxe.ds.IntMap;\n\n/**\n\tThis Key/Value iterator can be used to iterate across maps.\n**/\n@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\")\nclass MapKeyValueIterator<K, V> {\n\tvar map:haxe.Constraints.IMap<K, V>;\n\tvar keys:Iterator<K>;\n\n\tpublic inline function new(map:haxe.Constraints.IMap<K, V>) {\n\t\tthis.map = map;\n\t\tthis.keys = map.keys();\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\tpublic inline function hasNext():Bool {\n\t\treturn keys.hasNext();\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\tpublic inline function next():{key:K, value:V} {\n\t\tvar key = keys.next();\n\t\treturn {value: map.get(key), key: key};\n\t}\n}\n","/*\n * Copyright (C)2005-2018 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator is used only when `Array<T>` is passed to `Iterable<T>`\n**/\nclass ArrayIterator<T> {\n\tfinal array:Array<T>;\n\tvar current:Int = 0;\n\n\t/**\n\t\tCreate a new `ArrayIterator`.\n\t**/\n\t#if !hl inline #end\n\tpublic function new(array:Array<T>) {\n\t\tthis.array = array;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\t#if !hl inline #end\n\tpublic function hasNext() {\n\t\treturn current < array.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t#if !hl inline #end\n\tpublic function next() {\n\t\treturn array[current++];\n\t}\n}\n","package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tThis type unifies with any function type.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\n@:callable\nabstract Function(Dynamic) {}\n\n/**\n\tThis type unifies with an enum instance if all constructors of the enum\n\trequire no arguments.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract FlatEnum(Dynamic) {}\n\n/**\n\tThis type unifies with anything but `Void`.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract NotVoid(Dynamic) { }\n\n/**\n\tThis type unifies with any instance of classes that have a constructor\n\twhich\n\n\t  * is `public` and\n\t  * unifies with the type used for type parameter `T`.\n\n\tIf a type parameter `A` is assigned to a type parameter `B` which is constrained\n\tto `Constructible<T>`, A must be explicitly constrained to\n\t`Constructible<T>` as well.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract Constructible<T>(Dynamic) {}\n\ninterface IMap<K, V> {\n\tfunction get(k:K):Null<V>;\n\tfunction set(k:K, v:V):Void;\n\tfunction exists(k:K):Bool;\n\tfunction remove(k:K):Bool;\n\tfunction keys():Iterator<K>;\n\tfunction iterator():Iterator<V>;\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n\tfunction copy():IMap<K, V>;\n\tfunction toString():String;\n\tfunction clear():Void;\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\t@:pure\n\tpublic inline static function hasField(o:Dynamic, field:String):Bool {\n\t\treturn js.lib.Object.prototype.hasOwnProperty.call(o, field);\n\t}\n\n\t@:pure\n\tpublic static function field(o:Dynamic, field:String):Dynamic {\n\t\ttry\n\t\t\treturn o[cast field]\n\t\tcatch (e:Dynamic)\n\t\t\treturn null;\n\t}\n\n\tpublic inline static function setField(o:Dynamic, field:String, value:Dynamic):Void {\n\t\to[cast field] = value;\n\t}\n\n\tpublic static function getProperty(o:Dynamic, field:String):Dynamic\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\treturn if (o == null) __define_feature__(\"Reflect.getProperty\",\n\t\t\t\tnull) else if (o.__properties__ && (tmp = o.__properties__[\"get_\" + field])) o[tmp]() else o[field];\n\t\t}\n\n\tpublic static function setProperty(o:Dynamic, field:String, value:Dynamic):Void\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\tif (o.__properties__ && (tmp = o.__properties__[\"set_\" + field]))\n\t\t\t\to[tmp](value)\n\t\t\telse\n\t\t\t\to[field] = __define_feature__(\"Reflect.setProperty\", value);\n\t\t}\n\n\tpublic inline static function callMethod(o:Dynamic, func:haxe.Constraints.Function, args:Array<Dynamic>):Dynamic {\n\t\treturn (cast func : js.lib.Function).apply(o, args);\n\t}\n\n\tpublic static function fields(o:Dynamic):Array<String> {\n\t\tvar a = [];\n\t\tif (o != null)\n\t\t\tuntyped {\n\t\t\t\tvar hasOwnProperty = js.lib.Object.prototype.hasOwnProperty;\n\t\t\t\tjs.Syntax.code(\"for( var f in o ) {\");\n\t\t\t\tif (f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f))\n\t\t\t\t\ta.push(f);\n\t\t\t\tjs.Syntax.code(\"}\");\n\t\t\t}\n\t\treturn a;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isFunction(f:Dynamic):Bool {\n\t\treturn js.Syntax.typeof(f) == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>(a:T, b:T):Int {\n\t\treturn (a == b) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods(f1:Dynamic, f2:Dynamic):Bool {\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\t\tif (!isFunction(f1) || !isFunction(f2))\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isObject(v:Dynamic):Bool {\n\t\tif (v == null)\n\t\t\treturn false;\n\t\tvar t = js.Syntax.typeof(v);\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null))\n\t\t\t|| (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue(v:Dynamic):Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField(o:Dynamic, field:String):Bool {\n\t\tif (!hasField(o, field))\n\t\t\treturn false;\n\t\tjs.Syntax.delete(o, field);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>(o:Null<T>):Null<T> {\n\t\tif (o == null)\n\t\t\treturn null;\n\t\tvar o2:Dynamic = {};\n\t\tfor (f in Reflect.fields(o))\n\t\t\tReflect.setField(o2, f, Reflect.field(o, f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function(f:Array<Dynamic>->Void):Dynamic {})\n\tpublic static function makeVarArgs(f:Array<Dynamic>->Dynamic):Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(js.Syntax.code(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n/**\n\tBalancedTree allows key-value mapping with arbitrary keys, as long as they\n\tcan be ordered. By default, `Reflect.compare` is used in the `compare`\n\tmethod, which can be overridden in subclasses.\n\n\tOperations have a logarithmic average and worst-case cost.\n\n\tIteration over keys and values, using `keys` and `iterator` respectively,\n\tare in-order.\n**/\nclass BalancedTree<K, V> implements haxe.Constraints.IMap<K, V> {\n\tvar root:TreeNode<K, V>;\n\n\t/**\n\t\tCreates a new BalancedTree, which is initially empty.\n\t**/\n\tpublic function new() {}\n\n\t/**\n\t\tBinds `key` to `value`.\n\n\t\tIf `key` is already bound to a value, that binding disappears.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function set(key:K, value:V) {\n\t\troot = setLoop(key, value, root);\n\t}\n\n\t/**\n\t\tReturns the value `key` is bound to.\n\n\t\tIf `key` is not bound to any value, `null` is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function get(key:K):Null<V> {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn node.value;\n\t\t\tif (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tRemoves the current binding of `key`.\n\n\t\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\t\treturned.\n\n\t\tOtherwise the binding of `key` is removed and true is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function remove(key:K) {\n\t\ttry {\n\t\t\troot = removeLoop(key, root);\n\t\t\treturn true;\n\t\t} catch (e:String) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t\tTells if `key` is bound to a value.\n\n\t\tThis method returns true even if `key` is bound to null.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function exists(key:K) {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn true;\n\t\t\telse if (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tIterates over the bound values of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n\t**/\n\tpublic function iterator():Iterator<V> {\n\t\tvar ret = [];\n\t\titeratorLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tSee `Map.keyValueIterator`\n\t**/\n\t@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\t/**\n\t\tIterates over the keys of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n\t**/\n\tpublic function keys():Iterator<K> {\n\t\tvar ret = [];\n\t\tkeysLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\tpublic function copy():BalancedTree<K, V> {\n\t\tvar copied = new BalancedTree<K, V>();\n\t\tcopied.root = root;\n\t\treturn copied;\n\t}\n\n\tfunction setLoop(k:K, v:V, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\treturn new TreeNode<K, V>(null, k, v, null);\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) new TreeNode<K, V>(node.left, k, v, node.right, node.get_height()); else if (c < 0) {\n\t\t\tvar nl = setLoop(k, v, node.left);\n\t\t\tbalance(nl, node.key, node.value, node.right);\n\t\t} else {\n\t\t\tvar nr = setLoop(k, v, node.right);\n\t\t\tbalance(node.left, node.key, node.value, nr);\n\t\t}\n\t}\n\n\tfunction removeLoop(k:K, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\tthrow \"Not_found\";\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) merge(node.left,\n\t\t\tnode.right); else if (c < 0) balance(removeLoop(k, node.left), node.key, node.value,\n\t\t\tnode.right); else balance(node.left, node.key, node.value, removeLoop(k, node.right));\n\t}\n\n\tstatic function iteratorLoop<K,V>(node:TreeNode<K, V>, acc:Array<V>) {\n\t\tif (node != null) {\n\t\t\titeratorLoop(node.left, acc);\n\t\t\tacc.push(node.value);\n\t\t\titeratorLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction keysLoop(node:TreeNode<K, V>, acc:Array<K>) {\n\t\tif (node != null) {\n\t\t\tkeysLoop(node.left, acc);\n\t\t\tacc.push(node.key);\n\t\t\tkeysLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction merge(t1, t2) {\n\t\tif (t1 == null)\n\t\t\treturn t2;\n\t\tif (t2 == null)\n\t\t\treturn t1;\n\t\tvar t = minBinding(t2);\n\t\treturn balance(t1, t.key, t.value, removeMinBinding(t2));\n\t}\n\n\tfunction minBinding(t:TreeNode<K, V>) {\n\t\treturn if (t == null) throw \"Not_found\"; else if (t.left == null) t; else minBinding(t.left);\n\t}\n\n\tfunction removeMinBinding(t:TreeNode<K, V>) {\n\t\treturn if (t.left == null) t.right; else balance(removeMinBinding(t.left), t.key, t.value, t.right);\n\t}\n\n\tfunction balance(l:TreeNode<K, V>, k:K, v:V, r:TreeNode<K, V>):TreeNode<K, V> {\n\t\tvar hl = l.get_height();\n\t\tvar hr = r.get_height();\n\t\treturn if (hl > hr + 2) {\n\t\t\tif (l.left.get_height() >= l.right.get_height())\n\t\t\t\tnew TreeNode<K, V>(l.left, l.key, l.value, new TreeNode<K, V>(l.right, k, v, r));\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value,\n\t\t\t\t\tnew TreeNode<K, V>(l.right.right, k, v, r));\n\t\t} else if (hr > hl + 2) {\n\t\t\tif (r.right.get_height() > r.left.get_height())\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left), r.key, r.value, r.right);\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left.left), r.left.key, r.left.value,\n\t\t\t\t\tnew TreeNode<K, V>(r.left.right, r.key, r.value, r.right));\n\t\t} else {\n\t\t\tnew TreeNode<K, V>(l, k, v, r, (hl > hr ? hl : hr) + 1);\n\t\t}\n\t}\n\n\tfunction compare(k1:K, k2:K) {\n\t\treturn Reflect.compare(k1, k2);\n\t}\n\n\tpublic function toString() {\n\t\treturn root == null ? '{}' : '{${root.toString()}}';\n\t}\n\n\t/**\n\t\tRemoves all keys from `this` BalancedTree.\n\t**/\n\tpublic function clear():Void {\n\t\troot = null;\n\t}\n}\n\n/**\n\tA tree node of `haxe.ds.BalancedTree`.\n**/\nclass TreeNode<K, V> {\n\tpublic var left:TreeNode<K, V>;\n\tpublic var right:TreeNode<K, V>;\n\tpublic var key:K;\n\tpublic var value:V;\n\n\tvar _height:Int;\n\n\tpublic function new(l, k, v, r, h = -1) {\n\t\tleft = l;\n\t\tkey = k;\n\t\tvalue = v;\n\t\tright = r;\n\t\tif (h == -1)\n\t\t\t_height = (left.get_height() > right.get_height() ? left.get_height() : right.get_height()) + 1;\n\t\telse\n\t\t\t_height = h;\n\t}\n\n\textern public inline function get_height()\n\t\treturn this == null ? 0 : _height;\n\n\tpublic function toString() {\n\t\treturn (left == null ? \"\" : left.toString() + \", \") + '$key=$value' + (right == null ? \"\" : \", \" + right.toString());\n\t}\n}\n"]}