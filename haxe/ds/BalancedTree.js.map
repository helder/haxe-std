{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"BalancedTree.js.map","sources":["../../../../../../../haxe/versions/4.0.5/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/iterators/MapKeyValueIterator.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/Constraints.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/CallStack.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.5/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.0.5/std/js/_std/Reflect.hx","../../../../../../../haxe/versions/4.0.5/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/ds/BalancedTree.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\nimport haxe.ds.IntMap;\n\n/**\n\tThis Key/Value iterator can be used to iterate across maps.\n**/\n@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\")\nclass MapKeyValueIterator<K, V> {\n\tvar map:haxe.Constraints.IMap<K, V>;\n\tvar keys:Iterator<K>;\n\n\tpublic inline function new(map:haxe.Constraints.IMap<K, V>) {\n\t\tthis.map = map;\n\t\tthis.keys = map.keys();\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\tpublic inline function hasNext():Bool {\n\t\treturn keys.hasNext();\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\tpublic inline function next():{key:K, value:V} {\n\t\tvar key = keys.next();\n\t\treturn {value: map.get(key), key: key};\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tThis type unifies with any function type.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\n@:callable\nabstract Function(Dynamic) {}\n\n/**\n\tThis type unifies with an enum instance if all constructors of the enum\n\trequire no arguments.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract FlatEnum(Dynamic) {}\n\n/**\n\tThis type unifies with any instance of classes that have a constructor\n\twhich\n\n\t  * is `public` and\n\t  * unifies with the type used for type parameter `T`.\n\n\tIf a type parameter `A` is assigned to a type parameter `B` which is constrained\n\tto `Constructible<T>`, A must be explicitly constrained to\n\t`Constructible<T>` as well.\n\n\tIt is intended to be used as a type parameter constraint. If used as a real\n\ttype, the underlying type will be `Dynamic`.\n**/\nabstract Constructible<T>(Dynamic) {}\n\ninterface IMap<K, V> {\n\tfunction get(k:K):Null<V>;\n\tfunction set(k:K, v:V):Void;\n\tfunction exists(k:K):Bool;\n\tfunction remove(k:K):Bool;\n\tfunction keys():Iterator<K>;\n\tfunction iterator():Iterator<V>;\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n\tfunction copy():IMap<K, V>;\n\tfunction toString():String;\n\tfunction clear():Void;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule(m:String);\n\tFilePos(s:Null<StackItem>, file:String, line:Int, ?column:Null<Int>);\n\tMethod(classname:Null<String>, method:String);\n\tLocalFunction(?v:Int);\n}\n\n/**\n\tGet information about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.lib.Error;\n\n\tstatic function getStack(e:js.lib.Error):Array<StackItem> {\n\t\tif (e == null)\n\t\t\treturn [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function(error, callsites:Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null)\n\t\t\t\t\tsite = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName:String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx + 1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar fileName:String = site.getFileName();\n\t\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\t\tfileName = fileName.substr(fileAddr + 6);\n\t\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t#if eval\n\tstatic function getCallStack() {\n\t\treturn [];\n\t}\n\n\tstatic function getExceptionStack() {\n\t\treturn [];\n\t}\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack():Array<StackItem> {\n\t\t#if neko\n\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\ta.shift(); // remove Stack.callStack()\n\t\treturn a;\n\t\t#elseif flash\n\t\tvar a = makeStack(new flash.errors.Error().getStackTrace());\n\t\ta.shift(); // remove Stack.callStack()\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\treturn makeStack(s);\n\t\t#elseif js\n\t\ttry {\n\t\t\tthrow new js.lib.Error();\n\t\t} catch (e:Dynamic) {\n\t\t\tvar a = getStack(js.Lib.getOriginalException());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t}\n\t\t#elseif java\n\t\tvar stack = [];\n\t\tfor (el in java.lang.Thread.currentThread().getStackTrace()) {\n\t\t\tvar className = el.getClassName();\n\t\t\tvar methodName = el.getMethodName();\n\t\t\tvar fileName = el.getFileName();\n\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\tvar method = Method(className, methodName);\n\t\t\tif (fileName != null || lineNumber >= 0) {\n\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t} else {\n\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t}\n\t\tstack.shift();\n\t\tstack.shift();\n\t\tstack.pop();\n\t\treturn stack;\n\t\t#elseif cs\n\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\tvar stack = [];\n\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\tinfos.pop();\n\t\tinfos.reverse();\n\t\tfor (elem in infos)\n\t\t\tstack.push(FilePos(Method(null, elem._3), elem._1, elem._2));\n\t\treturn stack;\n\t\t#elseif lua\n\t\tvar stack = [];\n\t\tvar infos = lua.Debug.traceback();\n\t\tvar luastack = infos.split(\"\\n\").slice(2, -1);\n\t\tfor (s in luastack) {\n\t\t\tvar parts = s.split(\":\");\n\t\t\tvar file = parts[0];\n\t\t\tvar line = parts[1];\n\t\t\tvar method = if(parts.length <= 2) {\n\t\t\t\tnull;\n\t\t\t} else {\n\t\t\t\tvar methodPos = parts[2].indexOf(\"'\");\n\t\t\t\tif(methodPos < 0) {\n\t\t\t\t\tnull;\n\t\t\t\t} else {\n\t\t\t\t\tMethod(null, parts[2].substring(methodPos + 1, parts[2].length - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.push(FilePos(method, file, Std.parseInt(line)));\n\t\t}\n\t\treturn stack;\n\t\t#elseif hl\n\t\ttry {\n\t\t\tthrow null;\n\t\t} catch (e:Dynamic) {\n\t\t\tvar st = _getExceptionStack();\n\t\t\treturn makeStack(st.length > 2 ? st.sub(2, st.length - 2) : st);\n\t\t}\n\t\t#elseif eval\n\t\treturn getCallStack();\n\t\t#else\n\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t#if hl\n\t@:hlNative(\"std\", \"exception_stack\") static function _getExceptionStack():hl.NativeArray<hl.Bytes> {\n\t\treturn null;\n\t}\n\t#end\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp\n\t@:noDebug /* Do not mess up the exception stack */\n\t#end\n\tpublic static function exceptionStack():Array<StackItem> {\n\t\t#if neko\n\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\treturn new Array();\n\t\t#elseif hl\n\t\treturn makeStack(_getExceptionStack());\n\t\t#elseif flash\n\t\tvar err:flash.errors.Error = untyped flash.Boot.lastError;\n\t\tif (err == null)\n\t\t\treturn new Array();\n\t\tvar a = makeStack(err.getStackTrace());\n\t\tvar c = callStack();\n\t\tvar i = c.length - 1;\n\t\twhile (i > 0) {\n\t\t\tif (Std.string(a[a.length - 1]) == Std.string(c[i]))\n\t\t\t\ta.pop();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\treturn makeStack(s);\n\t\t#elseif java\n\t\tvar stack = [];\n\t\tswitch (#if jvm jvm.Exception #else java.internal.Exceptions #end.currentException()) {\n\t\t\tcase null:\n\t\t\tcase current:\n\t\t\t\tfor (el in current.getStackTrace()) {\n\t\t\t\t\tvar className = el.getClassName();\n\t\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\t\tvar method = Method(className, methodName);\n\t\t\t\t\tif (fileName != null || lineNumber >= 0) {\n\t\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack.push(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn stack;\n\t\t#elseif cs\n\t\treturn cs.internal.Exceptions.exception == null ? [] : makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\tvar stack = [];\n\t\tvar exc = python.lib.Sys.exc_info();\n\t\tif (exc._3 != null) {\n\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(Method(null, elem._3), elem._1, elem._2));\n\t\t}\n\t\treturn stack;\n\t\t#elseif js\n\t\treturn getStack(lastException);\n\t\t#elseif eval\n\t\treturn getExceptionStack();\n\t\t#else\n\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString(stack:Array<StackItem>) {\n\t\tvar b = new StringBuf();\n\t\tfor (s in stack) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b, s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString(b:StringBuf, s) {\n\t\tswitch (s) {\n\t\t\tcase CFunction:\n\t\t\t\tb.add(\"a C function\");\n\t\t\tcase Module(m):\n\t\t\t\tb.add(\"module \");\n\t\t\t\tb.add(m);\n\t\t\tcase FilePos(s, file, line, col):\n\t\t\t\tif (s != null) {\n\t\t\t\t\titemToString(b, s);\n\t\t\t\t\tb.add(\" (\");\n\t\t\t\t}\n\t\t\t\tb.add(file);\n\t\t\t\tb.add(\" line \");\n\t\t\t\tb.add(line);\n\t\t\t\tif (col != null) {\n\t\t\t\t\tb.add(\" column \");\n\t\t\t\t\tb.add(col);\n\t\t\t\t}\n\t\t\t\tif (s != null)\n\t\t\t\t\tb.add(\")\");\n\t\t\tcase Method(cname, meth):\n\t\t\t\tb.add(cname == null ? \"<unknown>\" : cname);\n\t\t\t\tb.add(\".\");\n\t\t\t\tb.add(meth);\n\t\t\tcase LocalFunction(n):\n\t\t\t\tb.add(\"local function #\");\n\t\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp\n\t@:noDebug /* Do not mess up the exception stack */\n\t#end\n\tprivate static function makeStack(s #if cs:cs.system.diagnostics.StackTrace #elseif hl:hl.NativeArray<hl.Bytes> #else:Dynamic #end) {\n\t\t#if neko\n\t\tvar a = new Array();\n\t\tvar l = untyped __dollar__asize(s);\n\t\tvar i = 0;\n\t\twhile (i < l) {\n\t\t\tvar x = s[i++];\n\t\t\tif (x == null)\n\t\t\t\ta.unshift(CFunction);\n\t\t\telse if (untyped __dollar__typeof(x) == __dollar__tstring)\n\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\telse\n\t\t\t\ta.unshift(FilePos(null, new String(untyped x[0]), untyped x[1]));\n\t\t}\n\t\treturn a;\n\t\t#elseif flash\n\t\tvar a = new Array();\n\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\twhile (r.match(s)) {\n\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\tvar meth = r.matched(2);\n\t\t\tvar item;\n\t\t\tif (meth == null) {\n\t\t\t\tif (rlambda.match(cl))\n\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\telse\n\t\t\t\t\titem = Method(cl, \"new\");\n\t\t\t} else\n\t\t\t\titem = Method(cl, meth.substr(1));\n\t\t\tif (r.matched(3) != null)\n\t\t\t\titem = FilePos(item, r.matched(4), Std.parseInt(r.matched(5)));\n\t\t\ta.push(item);\n\t\t\ts = r.matchedRight();\n\t\t}\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar stack:Array<String> = s;\n\t\tvar m = new Array<StackItem>();\n\t\tfor (func in stack) {\n\t\t\tvar words = func.split(\"::\");\n\t\t\tif (words.length == 0)\n\t\t\t\tm.push(CFunction)\n\t\t\telse if (words.length == 2)\n\t\t\t\tm.push(Method(words[0], words[1]));\n\t\t\telse if (words.length == 4)\n\t\t\t\tm.push(FilePos(Method(words[0], words[1]), words[2], Std.parseInt(words[3])));\n\t\t}\n\t\treturn m;\n\t\t#elseif js\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (js.Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = s.split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\tfor (line in stack) {\n\t\t\t\tif (rie10.match(line)) {\n\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\tvar column = Std.parseInt(rie10.matched(4));\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t}\n\t\t\treturn m;\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t\t#elseif cs\n\t\tvar stack = [];\n\t\tfor (i in 0...s.FrameCount) {\n\t\t\tvar frame = s.GetFrame(i);\n\t\t\tvar m = frame.GetMethod();\n\n\t\t\tif (m == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\tvar fileName = frame.GetFileName();\n\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\telse\n\t\t\t\tstack.push(method);\n\t\t}\n\t\treturn stack;\n\t\t#elseif hl\n\t\tvar stack = [];\n\t\tvar r = ~/^([A-Za-z0-9.$_]+)\\.([~A-Za-z0-9_]+(\\.[0-9]+)?)\\((.+):([0-9]+)\\)$/;\n\t\tvar r_fun = ~/^fun\\$([0-9]+)\\((.+):([0-9]+)\\)$/;\n\t\tfor (i in 0...s.length - 1) {\n\t\t\tvar str = @:privateAccess String.fromUCS2(s[i]);\n\t\t\tif (r.match(str))\n\t\t\t\tstack.push(FilePos(Method(r.matched(1), r.matched(2)), r.matched(4), Std.parseInt(r.matched(5))));\n\t\t\telse if (r_fun.match(str))\n\t\t\t\tstack.push(FilePos(LocalFunction(Std.parseInt(r_fun.matched(1))), r_fun.matched(2), Std.parseInt(r_fun.matched(3))));\n\t\t\telse\n\t\t\t\tstack.push(Module(str));\n\t\t}\n\t\treturn stack;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar v:Int = Syntax.code('parseInt({0}, ({0}[{1}]==\"x\" || {0}[{1}]==\"X\") ? 16 : 10)', x, i + 1);\n\t\t\t\t\treturn Math.isNaN(v) ? null : v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\t__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = __js__('Date'), __js__('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", __js__('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", __js__('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", __js__('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", __js__('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", __js__('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", __js__('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", __js__('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\t@:pure\n\tpublic inline static function hasField(o:Dynamic, field:String):Bool {\n\t\treturn js.lib.Object.prototype.hasOwnProperty.call(o, field);\n\t}\n\n\t@:pure\n\tpublic static function field(o:Dynamic, field:String):Dynamic {\n\t\ttry\n\t\t\treturn o[cast field]\n\t\tcatch (e:Dynamic)\n\t\t\treturn null;\n\t}\n\n\tpublic inline static function setField(o:Dynamic, field:String, value:Dynamic):Void {\n\t\to[cast field] = value;\n\t}\n\n\tpublic static function getProperty(o:Dynamic, field:String):Dynamic\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\treturn if (o == null) __define_feature__(\"Reflect.getProperty\",\n\t\t\t\tnull) else if (o.__properties__ && (tmp = o.__properties__[\"get_\" + field])) o[tmp]() else o[field];\n\t\t}\n\n\tpublic static function setProperty(o:Dynamic, field:String, value:Dynamic):Void\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\tif (o.__properties__ && (tmp = o.__properties__[\"set_\" + field]))\n\t\t\t\to[tmp](value)\n\t\t\telse\n\t\t\t\to[field] = __define_feature__(\"Reflect.setProperty\", value);\n\t\t}\n\n\tpublic inline static function callMethod(o:Dynamic, func:haxe.Constraints.Function, args:Array<Dynamic>):Dynamic {\n\t\treturn (cast func : js.lib.Function).apply(o, args);\n\t}\n\n\tpublic static function fields(o:Dynamic):Array<String> {\n\t\tvar a = [];\n\t\tif (o != null)\n\t\t\tuntyped {\n\t\t\t\tvar hasOwnProperty = js.lib.Object.prototype.hasOwnProperty;\n\t\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\t\tif (f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f))\n\t\t\t\t\ta.push(f);\n\t\t\t\t__js__(\"}\");\n\t\t\t}\n\t\treturn a;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isFunction(f:Dynamic):Bool {\n\t\treturn js.Syntax.typeof(f) == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>(a:T, b:T):Int {\n\t\treturn (a == b) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods(f1:Dynamic, f2:Dynamic):Bool {\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\t\tif (!isFunction(f1) || !isFunction(f2))\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isObject(v:Dynamic):Bool {\n\t\tif (v == null)\n\t\t\treturn false;\n\t\tvar t = js.Syntax.typeof(v);\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null))\n\t\t\t|| (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue(v:Dynamic):Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField(o:Dynamic, field:String):Bool {\n\t\tif (!hasField(o, field))\n\t\t\treturn false;\n\t\tjs.Syntax.delete(o, field);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>(o:Null<T>):Null<T> {\n\t\tif (o == null)\n\t\t\treturn null;\n\t\tvar o2:Dynamic = {};\n\t\tfor (f in Reflect.fields(o))\n\t\t\tReflect.setField(o2, f, Reflect.field(o, f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function(f:Array<Dynamic>->Void):Dynamic {})\n\tpublic static function makeVarArgs(f:Array<Dynamic>->Dynamic):Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) __js__(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) __js__(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n/**\n\tBalancedTree allows key-value mapping with arbitrary keys, as long as they\n\tcan be ordered. By default, `Reflect.compare` is used in the `compare`\n\tmethod, which can be overridden in subclasses.\n\n\tOperations have a logarithmic average and worst-case cost.\n\n\tIteration over keys and values, using `keys` and `iterator` respectively,\n\tare in-order.\n**/\nclass BalancedTree<K, V> implements haxe.Constraints.IMap<K, V> {\n\tvar root:TreeNode<K, V>;\n\n\t/**\n\t\tCreates a new BalancedTree, which is initially empty.\n\t**/\n\tpublic function new() {}\n\n\t/**\n\t\tBinds `key` to `value`.\n\n\t\tIf `key` is already bound to a value, that binding disappears.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function set(key:K, value:V) {\n\t\troot = setLoop(key, value, root);\n\t}\n\n\t/**\n\t\tReturns the value `key` is bound to.\n\n\t\tIf `key` is not bound to any value, `null` is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function get(key:K):Null<V> {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn node.value;\n\t\t\tif (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tRemoves the current binding of `key`.\n\n\t\tIf `key` has no binding, `this` BalancedTree is unchanged and false is\n\t\treturned.\n\n\t\tOtherwise the binding of `key` is removed and true is returned.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function remove(key:K) {\n\t\ttry {\n\t\t\troot = removeLoop(key, root);\n\t\t\treturn true;\n\t\t} catch (e:String) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t\tTells if `key` is bound to a value.\n\n\t\tThis method returns true even if `key` is bound to null.\n\n\t\tIf `key` is null, the result is unspecified.\n\t**/\n\tpublic function exists(key:K) {\n\t\tvar node = root;\n\t\twhile (node != null) {\n\t\t\tvar c = compare(key, node.key);\n\t\t\tif (c == 0)\n\t\t\t\treturn true;\n\t\t\telse if (c < 0)\n\t\t\t\tnode = node.left;\n\t\t\telse\n\t\t\t\tnode = node.right;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tIterates over the bound values of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n\t**/\n\tpublic function iterator():Iterator<V> {\n\t\tvar ret = [];\n\t\titeratorLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tSee `Map.keyValueIterator`\n\t**/\n\t@:runtime public inline function keyValueIterator():KeyValueIterator<K, V> {\n\t\treturn new haxe.iterators.MapKeyValueIterator(this);\n\t}\n\n\t/**\n\t\tIterates over the keys of `this` BalancedTree.\n\n\t\tThis operation is performed in-order.\n\t**/\n\tpublic function keys():Iterator<K> {\n\t\tvar ret = [];\n\t\tkeysLoop(root, ret);\n\t\treturn ret.iterator();\n\t}\n\n\tpublic function copy():BalancedTree<K, V> {\n\t\tvar copied = new BalancedTree<K, V>();\n\t\tcopied.root = root;\n\t\treturn copied;\n\t}\n\n\tfunction setLoop(k:K, v:V, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\treturn new TreeNode<K, V>(null, k, v, null);\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) new TreeNode<K, V>(node.left, k, v, node.right, node.get_height()); else if (c < 0) {\n\t\t\tvar nl = setLoop(k, v, node.left);\n\t\t\tbalance(nl, node.key, node.value, node.right);\n\t\t} else {\n\t\t\tvar nr = setLoop(k, v, node.right);\n\t\t\tbalance(node.left, node.key, node.value, nr);\n\t\t}\n\t}\n\n\tfunction removeLoop(k:K, node:TreeNode<K, V>) {\n\t\tif (node == null)\n\t\t\tthrow \"Not_found\";\n\t\tvar c = compare(k, node.key);\n\t\treturn if (c == 0) merge(node.left,\n\t\t\tnode.right); else if (c < 0) balance(removeLoop(k, node.left), node.key, node.value,\n\t\t\tnode.right); else balance(node.left, node.key, node.value, removeLoop(k, node.right));\n\t}\n\n\tfunction iteratorLoop(node:TreeNode<K, V>, acc:Array<V>) {\n\t\tif (node != null) {\n\t\t\titeratorLoop(node.left, acc);\n\t\t\tacc.push(node.value);\n\t\t\titeratorLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction keysLoop(node:TreeNode<K, V>, acc:Array<K>) {\n\t\tif (node != null) {\n\t\t\tkeysLoop(node.left, acc);\n\t\t\tacc.push(node.key);\n\t\t\tkeysLoop(node.right, acc);\n\t\t}\n\t}\n\n\tfunction merge(t1, t2) {\n\t\tif (t1 == null)\n\t\t\treturn t2;\n\t\tif (t2 == null)\n\t\t\treturn t1;\n\t\tvar t = minBinding(t2);\n\t\treturn balance(t1, t.key, t.value, removeMinBinding(t2));\n\t}\n\n\tfunction minBinding(t:TreeNode<K, V>) {\n\t\treturn if (t == null) throw \"Not_found\"; else if (t.left == null) t; else minBinding(t.left);\n\t}\n\n\tfunction removeMinBinding(t:TreeNode<K, V>) {\n\t\treturn if (t.left == null) t.right; else balance(removeMinBinding(t.left), t.key, t.value, t.right);\n\t}\n\n\tfunction balance(l:TreeNode<K, V>, k:K, v:V, r:TreeNode<K, V>):TreeNode<K, V> {\n\t\tvar hl = l.get_height();\n\t\tvar hr = r.get_height();\n\t\treturn if (hl > hr + 2) {\n\t\t\tif (l.left.get_height() >= l.right.get_height())\n\t\t\t\tnew TreeNode<K, V>(l.left, l.key, l.value, new TreeNode<K, V>(l.right, k, v, r));\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value,\n\t\t\t\t\tnew TreeNode<K, V>(l.right.right, k, v, r));\n\t\t} else if (hr > hl + 2) {\n\t\t\tif (r.right.get_height() > r.left.get_height())\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left), r.key, r.value, r.right);\n\t\t\telse\n\t\t\t\tnew TreeNode<K, V>(new TreeNode<K, V>(l, k, v, r.left.left), r.left.key, r.left.value,\n\t\t\t\t\tnew TreeNode<K, V>(r.left.right, r.key, r.value, r.right));\n\t\t} else {\n\t\t\tnew TreeNode<K, V>(l, k, v, r, (hl > hr ? hl : hr) + 1);\n\t\t}\n\t}\n\n\tfunction compare(k1:K, k2:K) {\n\t\treturn Reflect.compare(k1, k2);\n\t}\n\n\tpublic function toString() {\n\t\treturn root == null ? '{}' : '{${root.toString()}}';\n\t}\n\n\t/**\n\t\tRemoves all keys from `this` BalancedTree.\n\t**/\n\tpublic function clear():Void {\n\t\troot = null;\n\t}\n}\n\n/**\n\tA tree node of `haxe.ds.BalancedTree`.\n**/\nclass TreeNode<K, V> {\n\tpublic var left:TreeNode<K, V>;\n\tpublic var right:TreeNode<K, V>;\n\tpublic var key:K;\n\tpublic var value:V;\n\n\t#if as3\n\tpublic\n\t#end\n\tvar _height:Int;\n\n\tpublic function new(l, k, v, r, h = -1) {\n\t\tleft = l;\n\t\tkey = k;\n\t\tvalue = v;\n\t\tright = r;\n\t\tif (h == -1)\n\t\t\t_height = (left.get_height() > right.get_height() ? left.get_height() : right.get_height()) + 1;\n\t\telse\n\t\t\t_height = h;\n\t}\n\n\textern public inline function get_height()\n\t\treturn this == null ? 0 : _height;\n\n\tpublic function toString() {\n\t\treturn (left == null ? \"\" : left.toString() + \", \") + '$key=$value' + (right == null ? \"\" : \", \" + right.toString());\n\t}\n}\n"]}