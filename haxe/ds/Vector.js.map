{"sourceRoot":"","names":[],"mappings":"QAKA;QCqBU;;ACyBV;AAAA;;;;;;;;;;;;;CAYC;EAAA,YAMQ,IAAoB,MAAO,QANnC;EAAA;;;;;;;;;CA+BS,yBAQR;EAAA,AAAO,aAAK;;;;;;;;;CAUJ,8BAQR;EAAA,AAAO,aAAK,SAAS;;CAOtB;;;CAEA,yBAUC;EAAA,AAAe;;;;;;;;;;CAWhB,6CAYC;EAAA,GAAI,QAAO,MACV;GAAA,GAAI,UAAS,SAAS,CACrB;IAAA,QAAQ,SAAS,IACjB;IAAA,QAAQ,UAAU,IAClB,AAAU;IAAA,WAAI;IAAA,cAAd;IAAA,MAAK,CAAK,KAAI,KAAd,CAAU;KAAA,aACT;KAAA,IACA;KAAA,IACA;KAAA,IAAI,KAAK,IAAI;;IAER,SAAI,UAAS,SAAS,CAC5B;IAAA,QAAQ,OACR;IAAA,QAAQ,QACR,AAAU;IAAA,WAAI;IAAA,cAAd;IAAA,MAAK,CAAK,KAAI,KAAd,CAAU;KAAA,aACT;KAAA,IAAI,KAAK,IAAI,GACb;KAAA,IACA;KAAA;;;GAIF,OAAU;GAAA,WAAI;GAAA,cAAd;GAAA,MAAK,CAAK,KAAI,KAAd,CAAU;IAAA,aACT;IAAA,KAAK,UAAU,KAAK,IAAI,SAAS;;;;;;;;CASpC,sBAMC;EAAA,AAAO,mBAAW;;;;;;;;CAsBnB,qBACC;EAAA,AAAY;;;;;;;;;;CASb,sBACC;EAAA,AAAO,OAAK;;;;;;;;;;;;;;CAab,4BAYQ;EAAA,OAAS,YAAY;;;;;;;;;;CAmBV,mBAA2C,CAIrD;EAAA,sBAAc,cAAtB;EAAA,QAAQ,MACR;EAAA,kBAAY,AAAK,OAAM,GAAG,GAAG,GAAG,cAChC;EAAA,AAAO;;;;;;;;;;;;;;;;CAiBW,wBAAkD,CAI5D;EAAA,aACR;EAAA,UAAU,aACV,AAAU;EAAA,WAAI;EAAA,cAAd;EAAA,MAAK,CAAK,KAAI,KAAd,CAAU;GAAA,aACT;GAAA,kBAAM,WAAW,MAAI,KACrB;GAAA,GAAI,KAAI,MAAM,GACb;IAAA,OAAM;;IAGR;EAAA,AAAO;;;;;;;;;;CAWW,qBAAgD,CAIlE;EAAA,aAAa,aACL;EAAA,sBAAc,QAAtB;EAAA,QAAQ,MACR;EAAA,UAAU,OACV,AAAU;EAAA,WAAI;EAAA,cAAd;EAAA,MAAK,CAAK,KAAI,KAAd,CAAU;GAAA,aACT;GAAA,QAAQ,EAAE,MAAI,IACd;GAAA,EAAM,KAAG;IAEV;EAAA,AAAO;;;;;;;;;;;;;;;CAgBR,sBAMC;EAAA,WAAU","version":3,"file":"Vector.js.map","sources":["../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.2.2/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.2.2/std/haxe/ds/Vector.hx"],"sourcesContent":["package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\t@:deprecated('Std.is is deprecated. Use Std.isOfType instead.')\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n#if cpp\nusing cpp.NativeArray;\n#end\n\nprivate typedef VectorData<T> =\n\t#if flash10\n\tflash.Vector<T>\n\t#elseif neko\n\tneko.NativeArray<T>\n\t#elseif cs\n\tcs.NativeArray<T>\n\t#elseif java\n\tjava.NativeArray<T>\n\t#elseif lua\n\tlua.Table<Int, T>\n\t#elseif eval\n\teval.Vector<T>\n\t#else\n\tArray<T>\n\t#end\n\n/**\n\tA Vector is a storage of fixed size. It can be faster than Array on some\n\ttargets, and is never slower.\n\n\t@see https://haxe.org/manual/std-vector.html\n**/\nabstract Vector<T>(VectorData<T>) {\n\t/**\n\t\tCreates a new Vector of length `length`.\n\n\t\tInitially `this` Vector contains `length` neutral elements:\n\n\t\t- always null on dynamic targets\n\t\t- 0, 0.0 or false for Int, Float and Bool respectively on static targets\n\t\t- null for other types on static targets\n\n\t\tIf `length` is less than or equal to 0, the result is unspecified.\n\t**/\n\tpublic inline function new(length:Int) {\n\t\t#if flash10\n\t\tthis = new flash.Vector<T>(length, true);\n\t\t#elseif neko\n\t\tthis = untyped __dollar__amake(length);\n\t\t#elseif js\n\t\tthis = js.Syntax.construct(Array, length);\n\t\t#elseif cs\n\t\tthis = new cs.NativeArray(length);\n\t\t#elseif java\n\t\tthis = new java.NativeArray(length);\n\t\t#elseif cpp\n\t\tthis = NativeArray.create(length);\n\t\t#elseif python\n\t\tthis = python.Syntax.code(\"[{0}]*{1}\", null, length);\n\t\t#elseif lua\n\t\tthis = untyped __lua_table__({length: length});\n\t\t#elseif eval\n\t\tthis = new eval.Vector(length);\n\t\t#else\n\t\tthis = [];\n\t\tuntyped this.length = length;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the value at index `index`.\n\n\t\tIf `index` is negative or exceeds `this.length`, the result is\n\t\tunspecified.\n\t**/\n\t@:op([]) public inline function get(index:Int):T {\n\t\t#if cpp\n\t\treturn this.unsafeGet(index);\n\t\t#elseif python\n\t\treturn python.internal.ArrayImpl.unsafeGet(this, index);\n\t\t#elseif eval\n\t\treturn this[index];\n\t\t#else\n\t\treturn this[index];\n\t\t#end\n\t}\n\n\t/**\n\t\tSets the value at index `index` to `val`.\n\n\t\tIf `index` is negative or exceeds `this.length`, the result is\n\t\tunspecified.\n\t**/\n\t@:op([]) public inline function set(index:Int, val:T):T {\n\t\t#if cpp\n\t\treturn this.unsafeSet(index, val);\n\t\t#elseif python\n\t\treturn python.internal.ArrayImpl.unsafeSet(this, index, val);\n\t\t#elseif eval\n\t\treturn this[index] = val;\n\t\t#else\n\t\treturn this[index] = val;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns the length of `this` Vector.\n\t**/\n\tpublic var length(get, never):Int;\n\n\tinline function get_length():Int {\n\t\t#if neko\n\t\treturn untyped __dollar__asize(this);\n\t\t#elseif cs\n\t\treturn this.Length;\n\t\t#elseif java\n\t\treturn this.length;\n\t\t#elseif python\n\t\treturn this.length;\n\t\t#else\n\t\treturn untyped this.length;\n\t\t#end\n\t}\n\n\t/**\n\t\tCopies `length` of elements from `src` Vector, beginning at `srcPos` to\n\t\t`dest` Vector, beginning at `destPos`\n\n\t\tThe results are unspecified if `length` results in out-of-bounds access,\n\t\tor if `src` or `dest` are null\n\t**/\n\tpublic static #if (cs || java || neko || cpp || eval) inline #end function blit<T>(src:Vector<T>, srcPos:Int, dest:Vector<T>, destPos:Int, len:Int):Void {\n\t\t#if neko\n\t\tuntyped __dollar__ablit(dest, destPos, src, srcPos, len);\n\t\t#elseif java\n\t\tjava.lang.System.arraycopy(src, srcPos, dest, destPos, len);\n\t\t#elseif cs\n\t\tcs.system.Array.Copy(cast src, srcPos, cast dest, destPos, len);\n\t\t#elseif cpp\n\t\tdest.toData().blit(destPos, src.toData(), srcPos, len);\n\t\t#elseif eval\n\t\tsrc.toData().blit(srcPos, dest.toData(), destPos, len);\n\t\t#else\n\t\tif (src == dest) {\n\t\t\tif (srcPos < destPos) {\n\t\t\t\tvar i = srcPos + len;\n\t\t\t\tvar j = destPos + len;\n\t\t\t\tfor (k in 0...len) {\n\t\t\t\t\ti--;\n\t\t\t\t\tj--;\n\t\t\t\t\tsrc[j] = src[i];\n\t\t\t\t}\n\t\t\t} else if (srcPos > destPos) {\n\t\t\t\tvar i = srcPos;\n\t\t\t\tvar j = destPos;\n\t\t\t\tfor (k in 0...len) {\n\t\t\t\t\tsrc[j] = src[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i in 0...len) {\n\t\t\t\tdest[destPos + i] = src[srcPos + i];\n\t\t\t}\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tCreates a new Array, copy the content from the Vector to it, and returns it.\n\t**/\n\tpublic #if (flash || cpp || js || java || eval) inline #end function toArray():Array<T> {\n\t\t#if cpp\n\t\treturn this.copy();\n\t\t#elseif python\n\t\treturn this.copy();\n\t\t#elseif js\n\t\treturn this.slice(0);\n\t\t#elseif eval\n\t\treturn this.toArray();\n\t\t#else\n\t\tvar a = new Array();\n\t\tvar len = length;\n\t\t#if (neko)\n\t\t// prealloc good size\n\t\tif (len > 0)\n\t\t\ta[len - 1] = get(0);\n\t\t#end\n\t\tfor (i in 0...len)\n\t\t\ta[i] = get(i);\n\t\treturn a;\n\t\t#end\n\t}\n\n\t/**\n\t\tExtracts the data of `this` Vector.\n\n\t\tThis returns the internal representation type.\n\t**/\n\tpublic inline function toData():VectorData<T>\n\t\treturn cast this;\n\n\t/**\n\t\tInitializes a new Vector from `data`.\n\n\t\tSince `data` is the internal representation of Vector, this is a no-op.\n\n\t\tIf `data` is null, the corresponding Vector is also `null`.\n\t**/\n\tstatic public inline function fromData<T>(data:VectorData<T>):Vector<T>\n\t\treturn cast data;\n\n\t/**\n\t\tCreates a new Vector by copying the elements of `array`.\n\n\t\tThis always creates a copy, even on platforms where the internal\n\t\trepresentation is Array.\n\n\t\tThe elements are not copied and retain their identity, so\n\t\t`a[i] == Vector.fromArrayCopy(a).get(i)` is true for any valid i.\n\n\t\tIf `array` is null, the result is unspecified.\n\t**/\n\tstatic public inline function fromArrayCopy<T>(array:Array<T>):Vector<T> {\n\t\t#if python\n\t\treturn cast array.copy();\n\t\t#elseif flash10\n\t\treturn fromData(flash.Vector.ofArray(array));\n\t\t#elseif java\n\t\treturn fromData(java.Lib.nativeArray(array, false));\n\t\t#elseif cs\n\t\treturn fromData(cs.Lib.nativeArray(array, false));\n\t\t#elseif cpp\n\t\treturn cast array.copy();\n\t\t#elseif js\n\t\treturn fromData(array.slice(0));\n\t\t#elseif eval\n\t\treturn fromData(eval.Vector.fromArrayCopy(array));\n\t\t#else\n\t\t// TODO: Optimize this for others?\n\t\tvar vec = new Vector<T>(array.length);\n\t\tfor (i in 0...array.length)\n\t\t\tvec.set(i, array[i]);\n\t\treturn vec;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a shallow copy of `this` Vector.\n\n\t\tThe elements are not copied and retain their identity, so\n\t\t`a[i] == a.copy()[i]` is true for any valid `i`. However,\n\t\t`a == a.copy()` is always false.\n\t**/\n\t#if cs extern #end public inline function copy<T>():Vector<T> {\n\t\t#if eval\n\t\treturn fromData(this.copy());\n\t\t#else\n\t\tvar r = new Vector<T>(length);\n\t\tVector.blit(cast this, 0, r, 0, length);\n\t\treturn r;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` Vector, with `sep` separating\n\t\teach element.\n\n\t\tThe result of this operation is equal to `Std.string(this[0]) + sep +\n\t\tStd.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`\n\n\t\tIf `this` Vector has length 0, the result is the empty String `\"\"`.\n\t\tIf `this` has exactly one element, the result is equal to a call to\n\t\t`Std.string(this[0])`.\n\n\t\tIf `sep` is null, the result is unspecified.\n\t**/\n\t#if cs extern #end public inline function join<T>(sep:String):String {\n\t\t#if (flash10 || cpp || eval)\n\t\treturn this.join(sep);\n\t\t#else\n\t\tvar b = new StringBuf();\n\t\tvar len = length;\n\t\tfor (i in 0...len) {\n\t\t\tb.add(Std.string(get(i)));\n\t\t\tif (i < len - 1) {\n\t\t\t\tb.add(sep);\n\t\t\t}\n\t\t}\n\t\treturn b.toString();\n\t\t#end\n\t}\n\n\t/**\n\t\tCreates a new Vector by applying function `f` to all elements of `this`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\t#if cs extern #end public inline function map<S>(f:T->S):Vector<S> {\n\t\t#if eval\n\t\treturn fromData(this.map(f));\n\t\t#else\n\t\tvar length = length;\n\t\tvar r = new Vector<S>(length);\n\t\tvar len = length;\n\t\tfor (i in 0...len) {\n\t\t\tvar v = f(get(i));\n\t\t\tr.set(i, v);\n\t\t}\n\t\treturn r;\n\t\t#end\n\t}\n\n\t/**\n\t\tSorts `this` Vector according to the comparison function `f`, where\n\t\t`f(x,y)` returns 0 if x == y, a positive Int if x > y and a\n\t\tnegative Int if x < y.\n\n\t\tThis operation modifies `this` Vector in place.\n\n\t\tThe sort operation is not guaranteed to be stable, which means that the\n\t\torder of equal elements may not be retained.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic inline function sort(f:T->T->Int):Void {\n\t\t#if (neko || cs || java || eval)\n\t\tthrow \"not yet supported\";\n\t\t#elseif lua\n\t\thaxe.ds.ArraySort.sort(cast this, f);\n\t\t#else\n\t\tthis.sort(f);\n\t\t#end\n\t}\n}\n"]}