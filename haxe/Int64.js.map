{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Int64.js.map","sources":["../../../../../../haxe/versions/4.1.2/std/haxe/Int64Helper.hx","../../../../../../haxe/versions/4.1.2/std/haxe/Int32.hx","../../../../../../haxe/versions/4.1.2/std/js/_std/haxe/Exception.hx","../../../../../../haxe/versions/4.1.2/std/haxe/Int64.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\nimport StringTools;\n\n/**\n\tHelper for parsing to `Int64` instances.\n**/\nclass Int64Helper {\n\t/**\n\t\tCreate `Int64` from given string.\n\t**/\n\tpublic static function parseString(sParam:String):Int64 {\n\t\tvar base = Int64.ofInt(10);\n\t\tvar current = Int64.ofInt(0);\n\t\tvar multiplier = Int64.ofInt(1);\n\t\tvar sIsNegative = false;\n\n\t\tvar s = StringTools.trim(sParam);\n\t\tif (s.charAt(0) == \"-\") {\n\t\t\tsIsNegative = true;\n\t\t\ts = s.substring(1, s.length);\n\t\t}\n\t\tvar len = s.length;\n\n\t\tfor (i in 0...len) {\n\t\t\tvar digitInt = s.charCodeAt(len - 1 - i) - '0'.code;\n\n\t\t\tif (digitInt < 0 || digitInt > 9) {\n\t\t\t\tthrow \"NumberFormatError\";\n\t\t\t}\n\n\t\t\tif (digitInt != 0) {\n\t\t\t\tvar digit:Int64 = Int64.ofInt(digitInt);\n\t\t\t\tif (sIsNegative) {\n\t\t\t\t\tcurrent = Int64.sub(current, Int64.mul(multiplier, digit));\n\t\t\t\t\tif (!Int64.isNeg(current)) {\n\t\t\t\t\t\tthrow \"NumberFormatError: Underflow\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = Int64.add(current, Int64.mul(multiplier, digit));\n\t\t\t\t\tif (Int64.isNeg(current)) {\n\t\t\t\t\t\tthrow \"NumberFormatError: Overflow\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmultiplier = Int64.mul(multiplier, base);\n\t\t}\n\t\treturn current;\n\t}\n\n\t/**\n\t\tCreate `Int64` from given float.\n\t**/\n\tpublic static function fromFloat(f:Float):Int64 {\n\t\tif (Math.isNaN(f) || !Math.isFinite(f)) {\n\t\t\tthrow \"Number is NaN or Infinite\";\n\t\t}\n\n\t\tvar noFractions = f - (f % 1);\n\n\t\t// 2^53-1 and -2^53+1: these are parseable without loss of precision.\n\t\t// In theory 2^53 and -2^53 are parseable too, but then there's no way to\n\t\t// distinguish 2^53 from 2^53+1\n\t\t// (i.e. trace(9007199254740992. + 1. > 9007199254740992.); // false!)\n\t\tif (noFractions > 9007199254740991) {\n\t\t\tthrow \"Conversion overflow\";\n\t\t}\n\t\tif (noFractions < -9007199254740991) {\n\t\t\tthrow \"Conversion underflow\";\n\t\t}\n\n\t\tvar result = Int64.ofInt(0);\n\t\tvar neg = noFractions < 0;\n\t\tvar rest = neg ? -noFractions : noFractions;\n\n\t\tvar i = 0;\n\t\twhile (rest >= 1) {\n\t\t\tvar curr = rest % 2;\n\t\t\trest = rest / 2;\n\t\t\tif (curr >= 1) {\n\t\t\t\tresult = Int64.add(result, Int64.shl(Int64.ofInt(1), i));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (neg) {\n\t\t\tresult = Int64.neg(result);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tInt32 provides a 32-bit integer with consistent overflow behavior across\n\tall platforms.\n**/\nabstract Int32(Int) from Int to Int {\n\t@:op(-A) private inline function negate():Int32\n\t\treturn clamp(~this + 1);\n\n\t@:op(++A) private inline function preIncrement():Int32\n\t\treturn this = clamp(++this);\n\n\t@:op(A++) private inline function postIncrement():Int32 {\n\t\tvar ret = this++;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int32\n\t\treturn this = clamp(--this);\n\n\t@:op(A--) private inline function postDecrement():Int32 {\n\t\tvar ret = this--;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(A + B) private static inline function add(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static function addFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) private static inline function sub(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function subInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static function subFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) public static function floatSub(a:Float, b:Int32):Float;\n\n\t#if (js || php || python || lua)\n\t#if js\n\t// on JS we want to try using Math.imul, but we have to assign that function to Int32.mul only once,\n\t// or else V8 will deoptimize it, so we need to be a bit funky with this.\n\t// See https://github.com/HaxeFoundation/haxe/issues/5367 for benchmarks.\n\t@:op(A * B) inline static function mul(a:Int32, b:Int32):Int32\n\t\treturn _mul(a, b);\n\n\tstatic var _mul:Int32->Int32->Int32 = untyped if (Math.imul != null)\n\t\t\tMath.imul\n\t\telse\n\t\t\tfunction(a:Int32, b:Int32):Int32 return clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#end\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int32, b:Int):Int32\n\t\treturn mul(a, b);\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32;\n\n\t@:op(A * B) @:commutative private static function mulInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t@:op(A * B) @:commutative private static function mulFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function div(a:Int32, b:Int32):Float;\n\n\t@:op(A / B) private static function divInt(a:Int32, b:Int):Float;\n\n\t@:op(A / B) private static function intDiv(a:Int, b:Int32):Float;\n\n\t@:op(A / B) private static function divFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function floatDiv(a:Float, b:Int32):Float;\n\n\t@:op(A % B) private static function mod(a:Int32, b:Int32):Int32;\n\n\t@:op(A % B) private static function modInt(a:Int32, b:Int):Int;\n\n\t@:op(A % B) private static function intMod(a:Int, b:Int32):Int;\n\n\t@:op(A % B) private static function modFloat(a:Int32, b:Float):Float;\n\n\t@:op(A % B) private static function floatMod(a:Float, b:Int32):Float;\n\n\t@:op(A == B) private static function eq(a:Int32, b:Int32):Bool;\n\n\t@:op(A == B) @:commutative private static function eqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A == B) @:commutative private static function eqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A != B) private static function neq(a:Int32, b:Int32):Bool;\n\n\t@:op(A != B) @:commutative private static function neqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A != B) @:commutative private static function neqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function lt(a:Int32, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltInt(a:Int32, b:Int):Bool;\n\n\t@:op(A < B) private static function intLt(a:Int, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function floatLt(a:Float, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lte(a:Int32, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A <= B) private static function intLte(a:Int, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A <= B) private static function floatLte(a:Float, b:Int32):Bool;\n\n\t@:op(A > B) private static function gt(a:Int32, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtInt(a:Int32, b:Int):Bool;\n\n\t@:op(A > B) private static function intGt(a:Int, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A > B) private static function floatGt(a:Float, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gte(a:Int32, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A >= B) private static function intGte(a:Int, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A >= B) private static function floatGte(a:Float, b:Int32):Bool;\n\n\t#if (lua || python || php)\n\t@:op(~A) private static inline function complement(a:Int32):Int32\n\t\t#if lua return lua.Boot.clampInt32(~a); #else return clamp(~a); #end\n\t#else\n\t@:op(~A) private function complement():Int32;\n\t#end\n\n\t@:op(A & B) private static function and(a:Int32, b:Int32):Int32;\n\n\t@:op(A & B) @:commutative private static function andInt(a:Int32, b:Int):Int32;\n\n\t#if (lua || python || php)\n\t@:op(A | B) private static #if (python || php) inline #end function or(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) | (b : Int));\n\n\t@:op(A | B) @:commutative private #if (python || php) inline #end static function orInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) | b);\n\t#else\n\t@:op(A | B) private static function or(a:Int32, b:Int32):Int32;\n\n\t@:op(A | B) @:commutative private static function orInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A ^ B) private static #if (python || php) inline #end function xor(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) ^ (b : Int));\n\n\t@:op(A ^ B) @:commutative private static #if (python || php) inline #end function xorInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) ^ b);\n\t#else\n\t@:op(A ^ B) private static function xor(a:Int32, b:Int32):Int32;\n\n\t@:op(A ^ B) @:commutative private static function xorInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A >> B) private static #if (python || php) inline #end function shr(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) >> (b : Int));\n\n\t@:op(A >> B) private static #if (python || php) inline #end function shrInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) >> b);\n\n\t@:op(A >> B) private static #if (python || php) inline #end function intShr(a:Int, b:Int32):Int32\n\t\treturn clamp(a >> (b : Int));\n\t#else\n\t@:op(A >> B) private static function shr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >> B) private static function shrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >> B) private static function intShr(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:op(A >>> B) private static function ushr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >>> B) private static function ushrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >>> B) private static function intUshr(a:Int, b:Int32):Int32;\n\n\t#if (php || python || lua)\n\t// PHP may be 64-bit, so shifts must be clamped\n\t@:op(A << B) private static inline function shl(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) << (b : Int));\n\n\t@:op(A << B) private static inline function shlInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) << b);\n\n\t@:op(A << B) private static inline function intShl(a:Int, b:Int32):Int32\n\t\treturn clamp(a << (b : Int));\n\t#else\n\t@:op(A << B) private static function shl(a:Int32, b:Int32):Int32;\n\n\t@:op(A << B) private static function shlInt(a:Int32, b:Int):Int32;\n\n\t@:op(A << B) private static function intShl(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:to private inline function toFloat():Float\n\t\treturn this;\n\n\t/**\n\t\tCompare `a` and `b` in unsigned mode.\n\t**/\n\tpublic static function ucompare(a:Int32, b:Int32):Int {\n\t\tif (a < 0)\n\t\t\treturn b < 0 ? (~b - ~a) : 1;\n\t\treturn b < 0 ? -1 : (a - b);\n\t}\n\n\t#if php\n\tstatic var extraBits:Int = php.Const.PHP_INT_SIZE * 8 - 32;\n\t#end\n\n\t#if !lua\n\tinline\n\t#end\n\tstatic function clamp(x:Int):Int {\n\t\t// force to-int conversion on platforms that require it\n\t\t#if js\n\t\treturn x | 0;\n\t\t#elseif php\n\t\t// we might be on 64-bit php, so sign extend from 32-bit\n\t\treturn (x << extraBits) >> extraBits;\n\t\t#elseif python\n\t\treturn (python.Syntax.code(\"{0} % {1}\", (x + python.Syntax.opPow(2, 31)), python.Syntax.opPow(2, 32)) : Int) - python.Syntax.opPow(2, 31);\n\t\t#elseif lua\n\t\treturn lua.Boot.clampInt32(x);\n\t\t#else\n\t\treturn (x);\n\t\t#end\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\n/**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n**/\n#if flash\n@:notNull\n#end\nabstract Int64(__Int64) from __Int64 to __Int64 {\n\tprivate inline function new(x:__Int64)\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make(high, low);\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make(high:Int32, low:Int32):Int64\n\t\treturn new Int64(new __Int64(high, low));\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt(x:Int):Int64\n\t\t#if lua return make((x : Int32) >> 31, (x : Int32)); #else return make(x >> 31, x); #end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt(x:Int64):Int {\n\t\tif (x.high != x.low >> 31)\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t@:deprecated('haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead')\n\tinline public static function is(val:Dynamic):Bool {\n\t\treturn isInt64(val);\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function isInt64(val:Dynamic):Bool\n\t\treturn Std.isOfType(val, __Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh(x:Int64):Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow(x:Int64):Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg(x:Int64):Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero(x:Int64):Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare(a:Int64, b:Int64):Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare(a:Int64, b:Int64):Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64):String\n\t\treturn x.toString();\n\n\tfunction toString():String {\n\t\tvar i:Int64 = cast this;\n\t\tif (i == 0)\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif (i.isNeg()) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten:Int64 = 10;\n\t\twhile (i != 0) {\n\t\t\tvar r = i.divMod(ten);\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif (neg)\n\t\t\tstr = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString(sParam:String):Int64 {\n\t\treturn Int64Helper.parseString(sParam);\n\t}\n\n\tpublic static inline function fromFloat(f:Float):Int64 {\n\t\treturn Int64Helper.fromFloat(f);\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod(dividend:Int64, divisor:Int64):{quotient:Int64, modulus:Int64} {\n\t\t// Handle special cases of 0 and 1\n\t\tif (divisor.high == 0) {\n\t\t\tswitch (divisor.low) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow \"divide by zero\";\n\t\t\t\tcase 1:\n\t\t\t\t\treturn {quotient: dividend.copy(), modulus: 0};\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient:Int64 = 0;\n\t\tvar mask:Int64 = 1;\n\n\t\twhile (!divisor.isNeg()) {\n\t\t\tvar cmp = ucompare(divisor, modulus);\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif (cmp >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (mask != 0) {\n\t\t\tif (ucompare(modulus, divisor) >= 0) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif (divSign)\n\t\t\tquotient = -quotient;\n\t\tif (dividend.isNeg())\n\t\t\tmodulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient: quotient,\n\t\t\tmodulus: modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg(x:Int64):Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif (low == 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(++A) private inline function preIncrement():Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif (this.low == 0)\n\t\t\tthis.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement():Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int64 {\n\t\tthis = copy();\n\t\tif (this.low == 0)\n\t\t\tthis.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement():Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif (Int32.ucompare(low, a.low) < 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int64, b:Int):Int64\n\t\treturn add(a, b);\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif (Int32.ucompare(a.low, b.low) < 0)\n\t\t\thigh--;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A - B) private static inline function subInt(a:Int64, b:Int):Int64\n\t\treturn sub(a, b);\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int64):Int64\n\t\treturn sub(a, b);\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B)\n\tpublic static #if !lua inline #end function mul(a:Int64, b:Int64):Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif (Int32.ucompare(low, p01) < 0)\n\t\t\thigh++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif (Int32.ucompare(low, p10) < 0)\n\t\t\thigh++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int64, b:Int):Int64\n\t\treturn mul(a, b);\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt(a:Int64, b:Int):Int64\n\t\treturn div(a, b);\n\n\t@:op(A / B) private static inline function intDiv(a:Int, b:Int64):Int64\n\t\treturn div(a, b).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt(a:Int64, b:Int):Int64\n\t\treturn mod(a, b).toInt();\n\n\t@:op(A % B) private static inline function intMod(a:Int, b:Int64):Int64\n\t\treturn mod(a, b).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq(a:Int64, b:Int64):Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt(a:Int64, b:Int):Bool\n\t\treturn eq(a, b);\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq(a:Int64, b:Int64):Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt(a:Int64, b:Int):Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt(a:Int64, b:Int):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt(a:Int, b:Int64):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt(a:Int64, b:Int):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte(a:Int, b:Int64):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt(a:Int64, b:Int):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt(a:Int, b:Int64):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A >= B) private static inline function gte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt(a:Int64, b:Int):Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte(a:Int, b:Int64):Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement(a:Int64):Int64\n\t\treturn make(~a.high, ~a.low);\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and(a:Int64, b:Int64):Int64\n\t\treturn make(a.high & b.high, a.low & b.low);\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or(a:Int64, b:Int64):Int64\n\t\treturn make(a.high | b.high, a.low | b.low);\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor(a:Int64, b:Int64):Int64\n\t\treturn make(a.high ^ b.high, a.low ^ b.low);\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make((a.high << b) | (a.low >>> (32 - b)), a.low << b) else make(a.low << (b - 32), 0);\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >> b, (a.high << (32 - b)) | (a.low >>> b)); else make(a.high >> 31, a.high >> (b - 32));\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >>> b, (a.high << (32 - b)) | (a.low >>> b)); else make(0, a.high >>> (b - 32));\n\t}\n\n\tpublic var high(get, never):Int32;\n\n\tprivate inline function get_high()\n\t\treturn this.high;\n\n\tprivate inline function set_high(x)\n\t\treturn this.high = x;\n\n\tpublic var low(get, never):Int32;\n\n\tprivate inline function get_low()\n\t\treturn this.low;\n\n\tprivate inline function set_low(x)\n\t\treturn this.low = x;\n}\n\n/**\n\tThis typedef will fool `@:coreApi` into thinking that we are using\n\tthe same underlying type, even though it might be different on\n\tspecific platforms.\n**/\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high:Int32;\n\tpublic var low:Int32;\n\n\tpublic inline function new(high, low) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling `Std.string`. This tends not to happen when\n\t\t`toString` is only in the abstract.\n\t**/\n\tpublic function toString():String\n\t\treturn Int64.toStr(cast this);\n}\n"]}