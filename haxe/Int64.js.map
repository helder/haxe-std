{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Int64.js.map","sources":["../../../../../../haxe/versions/4.0.1/std/js/Boot.hx","../../../../../../haxe/versions/4.0.1/std/haxe/Int64Helper.hx","../../../../../../haxe/versions/4.0.1/std/haxe/Int32.hx","../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../haxe/versions/4.0.1/std/haxe/Int64.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\nimport StringTools;\n\n/**\n\tHelper for parsing to `Int64` instances.\n**/\nclass Int64Helper {\n\t/**\n\t\tCreate `Int64` from given string.\n\t**/\n\tpublic static function parseString(sParam:String):Int64 {\n\t\tvar base = Int64.ofInt(10);\n\t\tvar current = Int64.ofInt(0);\n\t\tvar multiplier = Int64.ofInt(1);\n\t\tvar sIsNegative = false;\n\n\t\tvar s = StringTools.trim(sParam);\n\t\tif (s.charAt(0) == \"-\") {\n\t\t\tsIsNegative = true;\n\t\t\ts = s.substring(1, s.length);\n\t\t}\n\t\tvar len = s.length;\n\n\t\tfor (i in 0...len) {\n\t\t\tvar digitInt = s.charCodeAt(len - 1 - i) - '0'.code;\n\n\t\t\tif (digitInt < 0 || digitInt > 9) {\n\t\t\t\tthrow \"NumberFormatError\";\n\t\t\t}\n\n\t\t\tif (digitInt != 0) {\n\t\t\t\tvar digit:Int64 = Int64.ofInt(digitInt);\n\t\t\t\tif (sIsNegative) {\n\t\t\t\t\tcurrent = Int64.sub(current, Int64.mul(multiplier, digit));\n\t\t\t\t\tif (!Int64.isNeg(current)) {\n\t\t\t\t\t\tthrow \"NumberFormatError: Underflow\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = Int64.add(current, Int64.mul(multiplier, digit));\n\t\t\t\t\tif (Int64.isNeg(current)) {\n\t\t\t\t\t\tthrow \"NumberFormatError: Overflow\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmultiplier = Int64.mul(multiplier, base);\n\t\t}\n\t\treturn current;\n\t}\n\n\t/**\n\t\tCreate `Int64` from given float.\n\t**/\n\tpublic static function fromFloat(f:Float):Int64 {\n\t\tif (Math.isNaN(f) || !Math.isFinite(f)) {\n\t\t\tthrow \"Number is NaN or Infinite\";\n\t\t}\n\n\t\tvar noFractions = f - (f % 1);\n\n\t\t// 2^53-1 and -2^53+1: these are parseable without loss of precision.\n\t\t// In theory 2^53 and -2^53 are parseable too, but then there's no way to\n\t\t// distinguish 2^53 from 2^53+1\n\t\t// (i.e. trace(9007199254740992. + 1. > 9007199254740992.); // false!)\n\t\tif (noFractions > 9007199254740991) {\n\t\t\tthrow \"Conversion overflow\";\n\t\t}\n\t\tif (noFractions < -9007199254740991) {\n\t\t\tthrow \"Conversion underflow\";\n\t\t}\n\n\t\tvar result = Int64.ofInt(0);\n\t\tvar neg = noFractions < 0;\n\t\tvar rest = neg ? -noFractions : noFractions;\n\n\t\tvar i = 0;\n\t\twhile (rest >= 1) {\n\t\t\tvar curr = rest % 2;\n\t\t\trest = rest / 2;\n\t\t\tif (curr >= 1) {\n\t\t\t\tresult = Int64.add(result, Int64.shl(Int64.ofInt(1), i));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (neg) {\n\t\t\tresult = Int64.neg(result);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tInt32 provides a 32-bit integer with consistent overflow behavior across\n\tall platforms.\n**/\nabstract Int32(Int) from Int to Int {\n\t@:op(-A) private inline function negate():Int32\n\t\treturn clamp(~this + 1);\n\n\t@:op(++A) private inline function preIncrement():Int32\n\t\treturn this = clamp(++this);\n\n\t@:op(A++) private inline function postIncrement():Int32 {\n\t\tvar ret = this++;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int32\n\t\treturn this = clamp(--this);\n\n\t@:op(A--) private inline function postDecrement():Int32 {\n\t\tvar ret = this--;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(A + B) private static inline function add(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static function addFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) private static inline function sub(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function subInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static function subFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) public static function floatSub(a:Float, b:Int32):Float;\n\n\t#if (as3 || js || php || python || lua)\n\t#if js\n\t// on JS we want to try using Math.imul, but we have to assign that function to Int32.mul only once,\n\t// or else V8 will deoptimize it, so we need to be a bit funky with this.\n\t// See https://github.com/HaxeFoundation/haxe/issues/5367 for benchmarks.\n\t@:op(A * B) inline static function mul(a:Int32, b:Int32):Int32\n\t\treturn _mul(a, b);\n\n\tstatic var _mul:Int32->Int32->Int32 = untyped if (Math.imul != null)\n\t\t\tMath.imul\n\t\telse\n\t\t\tfunction(a:Int32, b:Int32):Int32 return clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#end\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int32, b:Int):Int32\n\t\treturn mul(a, b);\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32;\n\n\t@:op(A * B) @:commutative private static function mulInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t@:op(A * B) @:commutative private static function mulFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function div(a:Int32, b:Int32):Float;\n\n\t@:op(A / B) private static function divInt(a:Int32, b:Int):Float;\n\n\t@:op(A / B) private static function intDiv(a:Int, b:Int32):Float;\n\n\t@:op(A / B) private static function divFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function floatDiv(a:Float, b:Int32):Float;\n\n\t@:op(A % B) private static function mod(a:Int32, b:Int32):Int32;\n\n\t@:op(A % B) private static function modInt(a:Int32, b:Int):Int;\n\n\t@:op(A % B) private static function intMod(a:Int, b:Int32):Int;\n\n\t@:op(A % B) private static function modFloat(a:Int32, b:Float):Float;\n\n\t@:op(A % B) private static function floatMod(a:Float, b:Int32):Float;\n\n\t@:op(A == B) private static function eq(a:Int32, b:Int32):Bool;\n\n\t@:op(A == B) @:commutative private static function eqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A == B) @:commutative private static function eqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A != B) private static function neq(a:Int32, b:Int32):Bool;\n\n\t@:op(A != B) @:commutative private static function neqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A != B) @:commutative private static function neqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function lt(a:Int32, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltInt(a:Int32, b:Int):Bool;\n\n\t@:op(A < B) private static function intLt(a:Int, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function floatLt(a:Float, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lte(a:Int32, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A <= B) private static function intLte(a:Int, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A <= B) private static function floatLte(a:Float, b:Int32):Bool;\n\n\t@:op(A > B) private static function gt(a:Int32, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtInt(a:Int32, b:Int):Bool;\n\n\t@:op(A > B) private static function intGt(a:Int, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A > B) private static function floatGt(a:Float, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gte(a:Int32, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A >= B) private static function intGte(a:Int, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A >= B) private static function floatGte(a:Float, b:Int32):Bool;\n\n\t#if (lua || python || php)\n\t@:op(~A) private static inline function complement(a:Int32):Int32\n\t\t#if lua return lua.Boot.clampInt32(~a); #else return clamp(~a); #end\n\t#else\n\t@:op(~A) private function complement():Int32;\n\t#end\n\n\t@:op(A & B) private static function and(a:Int32, b:Int32):Int32;\n\n\t@:op(A & B) @:commutative private static function andInt(a:Int32, b:Int):Int32;\n\n\t#if (lua || python || php)\n\t@:op(A | B) private static #if (python || php) inline #end function or(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) | (b : Int));\n\n\t@:op(A | B) @:commutative private #if (python || php) inline #end static function orInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) | b);\n\t#else\n\t@:op(A | B) private static function or(a:Int32, b:Int32):Int32;\n\n\t@:op(A | B) @:commutative private static function orInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A ^ B) private static #if (python || php) inline #end function xor(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) ^ (b : Int));\n\n\t@:op(A ^ B) @:commutative private static #if (python || php) inline #end function xorInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) ^ b);\n\t#else\n\t@:op(A ^ B) private static function xor(a:Int32, b:Int32):Int32;\n\n\t@:op(A ^ B) @:commutative private static function xorInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A >> B) private static #if (python || php) inline #end function shr(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) >> (b : Int));\n\n\t@:op(A >> B) private static #if (python || php) inline #end function shrInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) >> b);\n\n\t@:op(A >> B) private static #if (python || php) inline #end function intShr(a:Int, b:Int32):Int32\n\t\treturn clamp(a >> (b : Int));\n\t#else\n\t@:op(A >> B) private static function shr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >> B) private static function shrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >> B) private static function intShr(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:op(A >>> B) private static function ushr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >>> B) private static function ushrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >>> B) private static function intUshr(a:Int, b:Int32):Int32;\n\n\t#if (php || python || lua)\n\t// PHP may be 64-bit, so shifts must be clamped\n\t@:op(A << B) private static inline function shl(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) << (b : Int));\n\n\t@:op(A << B) private static inline function shlInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) << b);\n\n\t@:op(A << B) private static inline function intShl(a:Int, b:Int32):Int32\n\t\treturn clamp(a << (b : Int));\n\t#else\n\t@:op(A << B) private static function shl(a:Int32, b:Int32):Int32;\n\n\t@:op(A << B) private static function shlInt(a:Int32, b:Int):Int32;\n\n\t@:op(A << B) private static function intShl(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:to private inline function toFloat():Float\n\t\treturn this;\n\n\t/**\n\t\tCompare `a` and `b` in unsigned mode.\n\t**/\n\tpublic static function ucompare(a:Int32, b:Int32):Int {\n\t\tif (a < 0)\n\t\t\treturn b < 0 ? (~b - ~a) : 1;\n\t\treturn b < 0 ? -1 : (a - b);\n\t}\n\n\t#if php\n\tstatic var extraBits:Int = php.Const.PHP_INT_SIZE * 8 - 32;\n\t#end\n\n\t#if !lua\n\tinline\n\t#end\n\tstatic function clamp(x:Int):Int {\n\t\t// force to-int conversion on platforms that require it\n\t\t#if (as3 || js)\n\t\treturn x | 0;\n\t\t#elseif php\n\t\t// we might be on 64-bit php, so sign extend from 32-bit\n\t\treturn (x << extraBits) >> extraBits;\n\t\t#elseif python\n\t\treturn (python.Syntax.code(\"{0} % {1}\", (x + python.Syntax.opPow(2, 31)), python.Syntax.opPow(2, 32)) : Int) - python.Syntax.opPow(2, 31);\n\t\t#elseif lua\n\t\treturn lua.Boot.clampInt32(x);\n\t\t#else\n\t\treturn (x);\n\t\t#end\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\n/**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n**/\n#if flash\n@:notNull\n#end\nabstract Int64(__Int64) from __Int64 to __Int64 {\n\tprivate inline function new(x:__Int64)\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make(high, low);\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make(high:Int32, low:Int32):Int64\n\t\treturn new Int64(new __Int64(high, low));\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt(x:Int):Int64\n\t\t#if lua return make((x : Int32) >> 31, (x : Int32)); #else return make(x >> 31, x); #end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt(x:Int64):Int {\n\t\tif (x.high != x.low >> 31)\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function is(val:Dynamic):Bool\n\t\treturn Std.is(val, __Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh(x:Int64):Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow(x:Int64):Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg(x:Int64):Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero(x:Int64):Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare(a:Int64, b:Int64):Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare(a:Int64, b:Int64):Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64):String\n\t\treturn x.toString();\n\n\t#if as3 public #else private #end function toString():String {\n\t\tvar i:Int64 = cast this;\n\t\tif (i == 0)\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif (i.isNeg()) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten:Int64 = 10;\n\t\twhile (i != 0) {\n\t\t\tvar r = i.divMod(ten);\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif (neg)\n\t\t\tstr = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString(sParam:String):Int64 {\n\t\treturn Int64Helper.parseString(sParam);\n\t}\n\n\tpublic static inline function fromFloat(f:Float):Int64 {\n\t\treturn Int64Helper.fromFloat(f);\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod(dividend:Int64, divisor:Int64):{quotient:Int64, modulus:Int64} {\n\t\t// Handle special cases of 0 and 1\n\t\tif (divisor.high == 0) {\n\t\t\tswitch (divisor.low) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow \"divide by zero\";\n\t\t\t\tcase 1:\n\t\t\t\t\treturn {quotient: dividend.copy(), modulus: 0};\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient:Int64 = 0;\n\t\tvar mask:Int64 = 1;\n\n\t\twhile (!divisor.isNeg()) {\n\t\t\tvar cmp = ucompare(divisor, modulus);\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif (cmp >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (mask != 0) {\n\t\t\tif (ucompare(modulus, divisor) >= 0) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif (divSign)\n\t\t\tquotient = -quotient;\n\t\tif (dividend.isNeg())\n\t\t\tmodulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient: quotient,\n\t\t\tmodulus: modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg(x:Int64):Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif (low == 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(++A) private inline function preIncrement():Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif (this.low == 0)\n\t\t\tthis.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement():Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int64 {\n\t\tthis = copy();\n\t\tif (this.low == 0)\n\t\t\tthis.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement():Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif (Int32.ucompare(low, a.low) < 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int64, b:Int):Int64\n\t\treturn add(a, b);\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif (Int32.ucompare(a.low, b.low) < 0)\n\t\t\thigh--;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A - B) private static inline function subInt(a:Int64, b:Int):Int64\n\t\treturn sub(a, b);\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int64):Int64\n\t\treturn sub(a, b);\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B)\n\tpublic static #if !lua inline #end function mul(a:Int64, b:Int64):Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif (Int32.ucompare(low, p01) < 0)\n\t\t\thigh++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif (Int32.ucompare(low, p10) < 0)\n\t\t\thigh++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int64, b:Int):Int64\n\t\treturn mul(a, b);\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt(a:Int64, b:Int):Int64\n\t\treturn div(a, b);\n\n\t@:op(A / B) private static inline function intDiv(a:Int, b:Int64):Int64\n\t\treturn div(a, b).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt(a:Int64, b:Int):Int64\n\t\treturn mod(a, b).toInt();\n\n\t@:op(A % B) private static inline function intMod(a:Int, b:Int64):Int64\n\t\treturn mod(a, b).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq(a:Int64, b:Int64):Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt(a:Int64, b:Int):Bool\n\t\treturn eq(a, b);\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq(a:Int64, b:Int64):Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt(a:Int64, b:Int):Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt(a:Int64, b:Int):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt(a:Int, b:Int64):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt(a:Int64, b:Int):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte(a:Int, b:Int64):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt(a:Int64, b:Int):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt(a:Int, b:Int64):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A >= B) private static inline function gte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt(a:Int64, b:Int):Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte(a:Int, b:Int64):Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement(a:Int64):Int64\n\t\treturn make(~a.high, ~a.low);\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and(a:Int64, b:Int64):Int64\n\t\treturn make(a.high & b.high, a.low & b.low);\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or(a:Int64, b:Int64):Int64\n\t\treturn make(a.high | b.high, a.low | b.low);\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor(a:Int64, b:Int64):Int64\n\t\treturn make(a.high ^ b.high, a.low ^ b.low);\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make((a.high << b) | (a.low >>> (32 - b)), a.low << b) else make(a.low << (b - 32), 0);\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >> b, (a.high << (32 - b)) | (a.low >>> b)); else make(a.high >> 31, a.high >> (b - 32));\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >>> b, (a.high << (32 - b)) | (a.low >>> b)); else make(0, a.high >>> (b - 32));\n\t}\n\n\tpublic var high(get, never):Int32;\n\n\tprivate inline function get_high()\n\t\treturn this.high;\n\n\tprivate inline function set_high(x)\n\t\treturn this.high = x;\n\n\tpublic var low(get, never):Int32;\n\n\tprivate inline function get_low()\n\t\treturn this.low;\n\n\tprivate inline function set_low(x)\n\t\treturn this.low = x;\n}\n\n/**\n\tThis typedef will fool `@:coreApi` into thinking that we are using\n\tthe same underlying type, even though it might be different on\n\tspecific platforms.\n**/\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high:Int32;\n\tpublic var low:Int32;\n\n\tpublic inline function new(high, low) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling `Std.string`. This tends not to happen when\n\t\t`toString` is only in the abstract.\n\t**/\n\tpublic function toString():String\n\t\treturn Int64.toStr(cast this);\n}\n"]}