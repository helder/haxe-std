{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Int64.js.map","sources":["../../../../../../haxe/versions/4.2.1/std/haxe/Int64Helper.hx","../../../../../../haxe/versions/4.2.1/std/haxe/Int32.hx","../../../../../../haxe/versions/4.2.1/std/js/_std/haxe/Exception.hx","../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../haxe/versions/4.2.1/std/haxe/Int64.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\nimport StringTools;\n\n/**\n\tHelper for parsing to `Int64` instances.\n**/\nclass Int64Helper {\n\t/**\n\t\tCreate `Int64` from given string.\n\t**/\n\tpublic static function parseString(sParam:String):Int64 {\n\t\tvar base = Int64.ofInt(10);\n\t\tvar current = Int64.ofInt(0);\n\t\tvar multiplier = Int64.ofInt(1);\n\t\tvar sIsNegative = false;\n\n\t\tvar s = StringTools.trim(sParam);\n\t\tif (s.charAt(0) == \"-\") {\n\t\t\tsIsNegative = true;\n\t\t\ts = s.substring(1, s.length);\n\t\t}\n\t\tvar len = s.length;\n\n\t\tfor (i in 0...len) {\n\t\t\tvar digitInt = s.charCodeAt(len - 1 - i) - '0'.code;\n\n\t\t\tif (digitInt < 0 || digitInt > 9) {\n\t\t\t\tthrow \"NumberFormatError\";\n\t\t\t}\n\n\t\t\tif (digitInt != 0) {\n\t\t\t\tvar digit:Int64 = Int64.ofInt(digitInt);\n\t\t\t\tif (sIsNegative) {\n\t\t\t\t\tcurrent = Int64.sub(current, Int64.mul(multiplier, digit));\n\t\t\t\t\tif (!Int64.isNeg(current)) {\n\t\t\t\t\t\tthrow \"NumberFormatError: Underflow\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurrent = Int64.add(current, Int64.mul(multiplier, digit));\n\t\t\t\t\tif (Int64.isNeg(current)) {\n\t\t\t\t\t\tthrow \"NumberFormatError: Overflow\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmultiplier = Int64.mul(multiplier, base);\n\t\t}\n\t\treturn current;\n\t}\n\n\t/**\n\t\tCreate `Int64` from given float.\n\t**/\n\tpublic static function fromFloat(f:Float):Int64 {\n\t\tif (Math.isNaN(f) || !Math.isFinite(f)) {\n\t\t\tthrow \"Number is NaN or Infinite\";\n\t\t}\n\n\t\tvar noFractions = f - (f % 1);\n\n\t\t// 2^53-1 and -2^53+1: these are parseable without loss of precision.\n\t\t// In theory 2^53 and -2^53 are parseable too, but then there's no way to\n\t\t// distinguish 2^53 from 2^53+1\n\t\t// (i.e. trace(9007199254740992. + 1. > 9007199254740992.); // false!)\n\t\tif (noFractions > 9007199254740991) {\n\t\t\tthrow \"Conversion overflow\";\n\t\t}\n\t\tif (noFractions < -9007199254740991) {\n\t\t\tthrow \"Conversion underflow\";\n\t\t}\n\n\t\tvar result = Int64.ofInt(0);\n\t\tvar neg = noFractions < 0;\n\t\tvar rest = neg ? -noFractions : noFractions;\n\n\t\tvar i = 0;\n\t\twhile (rest >= 1) {\n\t\t\tvar curr = rest % 2;\n\t\t\trest = rest / 2;\n\t\t\tif (curr >= 1) {\n\t\t\t\tresult = Int64.add(result, Int64.shl(Int64.ofInt(1), i));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tif (neg) {\n\t\t\tresult = Int64.neg(result);\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tInt32 provides a 32-bit integer with consistent overflow behavior across\n\tall platforms.\n**/\n@:transitive\nabstract Int32(Int) from Int to Int {\n\t@:op(-A) private inline function negate():Int32\n\t\treturn clamp(~this + 1);\n\n\t@:op(++A) private inline function preIncrement():Int32\n\t\treturn this = clamp(++this);\n\n\t@:op(A++) private inline function postIncrement():Int32 {\n\t\tvar ret = this++;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int32\n\t\treturn this = clamp(--this);\n\n\t@:op(A--) private inline function postDecrement():Int32 {\n\t\tvar ret = this--;\n\t\tthis = clamp(this);\n\t\treturn ret;\n\t}\n\n\t@:op(A + B) private static inline function add(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) + (b : Int));\n\n\t@:op(A + B) @:commutative private static function addFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) private static inline function sub(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function subInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int32):Int32\n\t\treturn clamp((a : Int) - (b : Int));\n\n\t@:op(A - B) private static function subFloat(a:Int32, b:Float):Float;\n\n\t@:op(A - B) private static function floatSub(a:Float, b:Int32):Float;\n\n\t#if (js || php || python || lua)\n\t#if js\n\t// on JS we want to try using Math.imul, but we have to assign that function to Int32.mul only once,\n\t// or else V8 will deoptimize it, so we need to be a bit funky with this.\n\t// See https://github.com/HaxeFoundation/haxe/issues/5367 for benchmarks.\n\t@:op(A * B) inline static function mul(a:Int32, b:Int32):Int32\n\t\treturn _mul(a, b);\n\n\tstatic var _mul:Int32->Int32->Int32 = untyped if (Math.imul != null)\n\t\t\tMath.imul\n\t\telse\n\t\t\tfunction(a:Int32, b:Int32):Int32 return clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) * ((b : Int) & 0xFFFF) + clamp((a : Int) * ((b : Int) >>> 16) << 16));\n\t#end\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int32, b:Int):Int32\n\t\treturn mul(a, b);\n\t#else\n\t@:op(A * B) private static function mul(a:Int32, b:Int32):Int32;\n\n\t@:op(A * B) @:commutative private static function mulInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t@:op(A * B) @:commutative private static function mulFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function div(a:Int32, b:Int32):Float;\n\n\t@:op(A / B) private static function divInt(a:Int32, b:Int):Float;\n\n\t@:op(A / B) private static function intDiv(a:Int, b:Int32):Float;\n\n\t@:op(A / B) private static function divFloat(a:Int32, b:Float):Float;\n\n\t@:op(A / B) private static function floatDiv(a:Float, b:Int32):Float;\n\n\t@:op(A % B) private static function mod(a:Int32, b:Int32):Int32;\n\n\t@:op(A % B) private static function modInt(a:Int32, b:Int):Int;\n\n\t@:op(A % B) private static function intMod(a:Int, b:Int32):Int;\n\n\t@:op(A % B) private static function modFloat(a:Int32, b:Float):Float;\n\n\t@:op(A % B) private static function floatMod(a:Float, b:Int32):Float;\n\n\t@:op(A == B) private static function eq(a:Int32, b:Int32):Bool;\n\n\t@:op(A == B) @:commutative private static function eqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A == B) @:commutative private static function eqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A != B) private static function neq(a:Int32, b:Int32):Bool;\n\n\t@:op(A != B) @:commutative private static function neqInt(a:Int32, b:Int):Bool;\n\n\t@:op(A != B) @:commutative private static function neqFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function lt(a:Int32, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltInt(a:Int32, b:Int):Bool;\n\n\t@:op(A < B) private static function intLt(a:Int, b:Int32):Bool;\n\n\t@:op(A < B) private static function ltFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A < B) private static function floatLt(a:Float, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lte(a:Int32, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A <= B) private static function intLte(a:Int, b:Int32):Bool;\n\n\t@:op(A <= B) private static function lteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A <= B) private static function floatLte(a:Float, b:Int32):Bool;\n\n\t@:op(A > B) private static function gt(a:Int32, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtInt(a:Int32, b:Int):Bool;\n\n\t@:op(A > B) private static function intGt(a:Int, b:Int32):Bool;\n\n\t@:op(A > B) private static function gtFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A > B) private static function floatGt(a:Float, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gte(a:Int32, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteInt(a:Int32, b:Int):Bool;\n\n\t@:op(A >= B) private static function intGte(a:Int, b:Int32):Bool;\n\n\t@:op(A >= B) private static function gteFloat(a:Int32, b:Float):Bool;\n\n\t@:op(A >= B) private static function floatGte(a:Float, b:Int32):Bool;\n\n\t#if (lua || python || php)\n\t@:op(~A) private static inline function complement(a:Int32):Int32\n\t\t#if lua return lua.Boot.clampInt32(~a); #else return clamp(~a); #end\n\t#else\n\t@:op(~A) private function complement():Int32;\n\t#end\n\n\t@:op(A & B) private static function and(a:Int32, b:Int32):Int32;\n\n\t@:op(A & B) @:commutative private static function andInt(a:Int32, b:Int):Int32;\n\n\t#if (lua || python || php)\n\t@:op(A | B) private static #if (python || php) inline #end function or(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) | (b : Int));\n\n\t@:op(A | B) @:commutative private #if (python || php) inline #end static function orInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) | b);\n\t#else\n\t@:op(A | B) private static function or(a:Int32, b:Int32):Int32;\n\n\t@:op(A | B) @:commutative private static function orInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A ^ B) private static #if (python || php) inline #end function xor(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) ^ (b : Int));\n\n\t@:op(A ^ B) @:commutative private static #if (python || php) inline #end function xorInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) ^ b);\n\t#else\n\t@:op(A ^ B) private static function xor(a:Int32, b:Int32):Int32;\n\n\t@:op(A ^ B) @:commutative private static function xorInt(a:Int32, b:Int):Int32;\n\t#end\n\n\t#if (lua || python || php)\n\t@:op(A >> B) private static #if (python || php) inline #end function shr(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) >> (b : Int));\n\n\t@:op(A >> B) private static #if (python || php) inline #end function shrInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) >> b);\n\n\t@:op(A >> B) private static #if (python || php) inline #end function intShr(a:Int, b:Int32):Int32\n\t\treturn clamp(a >> (b : Int));\n\t#else\n\t@:op(A >> B) private static function shr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >> B) private static function shrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >> B) private static function intShr(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:op(A >>> B) private static function ushr(a:Int32, b:Int32):Int32;\n\n\t@:op(A >>> B) private static function ushrInt(a:Int32, b:Int):Int32;\n\n\t@:op(A >>> B) private static function intUshr(a:Int, b:Int32):Int32;\n\n\t#if (php || python || lua)\n\t// PHP may be 64-bit, so shifts must be clamped\n\t@:op(A << B) private static inline function shl(a:Int32, b:Int32):Int32\n\t\treturn clamp((a : Int) << (b : Int));\n\n\t@:op(A << B) private static inline function shlInt(a:Int32, b:Int):Int32\n\t\treturn clamp((a : Int) << b);\n\n\t@:op(A << B) private static inline function intShl(a:Int, b:Int32):Int32\n\t\treturn clamp(a << (b : Int));\n\t#else\n\t@:op(A << B) private static function shl(a:Int32, b:Int32):Int32;\n\n\t@:op(A << B) private static function shlInt(a:Int32, b:Int):Int32;\n\n\t@:op(A << B) private static function intShl(a:Int, b:Int32):Int32;\n\t#end\n\n\t@:to private inline function toFloat():Float\n\t\treturn this;\n\n\t/**\n\t\tCompare `a` and `b` in unsigned mode.\n\t**/\n\tpublic static function ucompare(a:Int32, b:Int32):Int {\n\t\tif (a < 0)\n\t\t\treturn b < 0 ? (~b - ~a) : 1;\n\t\treturn b < 0 ? -1 : (a - b);\n\t}\n\n\t#if php\n\tstatic var extraBits:Int = php.Const.PHP_INT_SIZE * 8 - 32;\n\t#end\n\n\t#if !lua\n\tinline\n\t#end\n\tstatic function clamp(x:Int):Int {\n\t\t// force to-int conversion on platforms that require it\n\t\t#if js\n\t\treturn x | 0;\n\t\t#elseif php\n\t\t// we might be on 64-bit php, so sign extend from 32-bit\n\t\treturn (x << extraBits) >> extraBits;\n\t\t#elseif python\n\t\treturn (python.Syntax.code(\"{0} % {1}\", (x + python.Syntax.opPow(2, 31)), python.Syntax.opPow(2, 32)) : Int) - python.Syntax.opPow(2, 31);\n\t\t#elseif lua\n\t\treturn lua.Boot.clampInt32(x);\n\t\t#else\n\t\treturn (x);\n\t\t#end\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\n/**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n**/\n#if flash\n@:notNull\n#end\n@:transitive\nabstract Int64(__Int64) from __Int64 to __Int64 {\n\tprivate inline function new(x:__Int64)\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make(high, low);\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make(high:Int32, low:Int32):Int64\n\t\treturn new Int64(new __Int64(high, low));\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt(x:Int):Int64\n\t\t#if lua return make((x : Int32) >> 31, (x : Int32)); #else return make(x >> 31, x); #end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt(x:Int64):Int {\n\t\tif (x.high != x.low >> 31)\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t@:deprecated('haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead')\n\tinline public static function is(val:Dynamic):Bool {\n\t\treturn isInt64(val);\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function isInt64(val:Dynamic):Bool\n\t\treturn Std.isOfType(val, __Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh(x:Int64):Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow(x:Int64):Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg(x:Int64):Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero(x:Int64):Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare(a:Int64, b:Int64):Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare(a:Int64, b:Int64):Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64):String\n\t\treturn x.toString();\n\n\tfunction toString():String {\n\t\tvar i:Int64 = cast this;\n\t\tif (i == 0)\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif (i.isNeg()) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten:Int64 = 10;\n\t\twhile (i != 0) {\n\t\t\tvar r = i.divMod(ten);\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif (neg)\n\t\t\tstr = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString(sParam:String):Int64 {\n\t\treturn Int64Helper.parseString(sParam);\n\t}\n\n\tpublic static inline function fromFloat(f:Float):Int64 {\n\t\treturn Int64Helper.fromFloat(f);\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod(dividend:Int64, divisor:Int64):{quotient:Int64, modulus:Int64} {\n\t\t// Handle special cases of 0 and 1\n\t\tif (divisor.high == 0) {\n\t\t\tswitch (divisor.low) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow \"divide by zero\";\n\t\t\t\tcase 1:\n\t\t\t\t\treturn {quotient: dividend.copy(), modulus: 0};\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient:Int64 = 0;\n\t\tvar mask:Int64 = 1;\n\n\t\twhile (!divisor.isNeg()) {\n\t\t\tvar cmp = ucompare(divisor, modulus);\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif (cmp >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (mask != 0) {\n\t\t\tif (ucompare(modulus, divisor) >= 0) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif (divSign)\n\t\t\tquotient = -quotient;\n\t\tif (dividend.isNeg())\n\t\t\tmodulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient: quotient,\n\t\t\tmodulus: modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg(x:Int64):Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif (low == 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(++A) private inline function preIncrement():Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif (this.low == 0)\n\t\t\tthis.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement():Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int64 {\n\t\tthis = copy();\n\t\tif (this.low == 0)\n\t\t\tthis.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement():Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif (Int32.ucompare(low, a.low) < 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int64, b:Int):Int64\n\t\treturn add(a, b);\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif (Int32.ucompare(a.low, b.low) < 0)\n\t\t\thigh--;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A - B) private static inline function subInt(a:Int64, b:Int):Int64\n\t\treturn sub(a, b);\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int64):Int64\n\t\treturn sub(a, b);\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B)\n\tpublic static #if !lua inline #end function mul(a:Int64, b:Int64):Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif (Int32.ucompare(low, p01) < 0)\n\t\t\thigh++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif (Int32.ucompare(low, p10) < 0)\n\t\t\thigh++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int64, b:Int):Int64\n\t\treturn mul(a, b);\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt(a:Int64, b:Int):Int64\n\t\treturn div(a, b);\n\n\t@:op(A / B) private static inline function intDiv(a:Int, b:Int64):Int64\n\t\treturn div(a, b).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt(a:Int64, b:Int):Int64\n\t\treturn mod(a, b).toInt();\n\n\t@:op(A % B) private static inline function intMod(a:Int, b:Int64):Int64\n\t\treturn mod(a, b).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq(a:Int64, b:Int64):Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt(a:Int64, b:Int):Bool\n\t\treturn eq(a, b);\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq(a:Int64, b:Int64):Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt(a:Int64, b:Int):Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt(a:Int64, b:Int):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt(a:Int, b:Int64):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt(a:Int64, b:Int):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte(a:Int, b:Int64):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt(a:Int64, b:Int):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt(a:Int, b:Int64):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A >= B) private static inline function gte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt(a:Int64, b:Int):Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte(a:Int, b:Int64):Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement(a:Int64):Int64\n\t\treturn make(~a.high, ~a.low);\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and(a:Int64, b:Int64):Int64\n\t\treturn make(a.high & b.high, a.low & b.low);\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or(a:Int64, b:Int64):Int64\n\t\treturn make(a.high | b.high, a.low | b.low);\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor(a:Int64, b:Int64):Int64\n\t\treturn make(a.high ^ b.high, a.low ^ b.low);\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make((a.high << b) | (a.low >>> (32 - b)), a.low << b) else make(a.low << (b - 32), 0);\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >> b, (a.high << (32 - b)) | (a.low >>> b)); else make(a.high >> 31, a.high >> (b - 32));\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >>> b, (a.high << (32 - b)) | (a.low >>> b)); else make(0, a.high >>> (b - 32));\n\t}\n\n\tpublic var high(get, never):Int32;\n\n\tprivate inline function get_high()\n\t\treturn this.high;\n\n\tprivate inline function set_high(x)\n\t\treturn this.high = x;\n\n\tpublic var low(get, never):Int32;\n\n\tprivate inline function get_low()\n\t\treturn this.low;\n\n\tprivate inline function set_low(x)\n\t\treturn this.low = x;\n}\n\n/**\n\tThis typedef will fool `@:coreApi` into thinking that we are using\n\tthe same underlying type, even though it might be different on\n\tspecific platforms.\n**/\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high:Int32;\n\tpublic var low:Int32;\n\n\tpublic inline function new(high, low) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling `Std.string`. This tends not to happen when\n\t\t`toString` is only in the abstract.\n\t**/\n\tpublic function toString():String\n\t\treturn Int64.toStr(cast this);\n}\n"]}