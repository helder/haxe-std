{"sourceRoot":"","names":[],"mappings":"QAEA;QCAA;QCGA;;ACyBA;AAAA;CAEC;;;CACA,yBACC;EAAA,AAAO;;;;;;;;;;;CAUD,iBACN,CAAO;EAAA,YAAS,MAAT;EAAA;;CAER;EAAA,YACQ,MADR;EAAA;;CAGc,yBACb;EAAA,AAAO,aAAK;;;;;;CAKR,sBACJ;EAAA,AAAO;;CAER,uBACC;EAAA,AAAO,wBAAoB;;CAE5B,+BACC;EAAA,AAAO,gCAA4B;;;;;;CAKpC,2BAAuC,CACtC;EAAA,aAAa,cACb;EAAA,YAAY,MACL;EAAA,YAAS,OAAT;EAAA;;;;;;CAMR,4BAAwC,CACvC;EAAA,aAAa,cACb;EAAA,eAAe,MACR;EAAA,YAAS,OAAT;EAAA;;CAGR,uBAEE;EAAA,AAAQ,aAAG,mBAAgB","version":3,"file":"Rest.js.map","sources":["../../../../../../haxe/versions/4.2.1/std/haxe/iterators/RestKeyValueIterator.hx","../../../../../../haxe/versions/4.2.1/std/haxe/iterators/RestIterator.hx","../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../haxe/versions/4.2.1/std/haxe/Rest.hx"],"sourcesContent":["package haxe.iterators;\n\nclass RestKeyValueIterator<T> {\n\tfinal args:Rest<T>;\n\tvar current:Int = 0;\n\n\t@:allow(haxe.Rest)\n\tinline function new(args:Any) {\n\t\tthis.args = args;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn current < args.length;\n\t}\n\n\tpublic inline function next():{key:Int, value:T} {\n\t\treturn {key:current, value:args[current++]};\n\t}\n}","package haxe.iterators;\n\nclass RestIterator<T> {\n\tfinal args:Rest<T>;\n\tvar current:Int = 0;\n\n\t@:allow(haxe.Rest)\n\tinline function new(args:Any) {\n\t\tthis.args = args;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn current < args.length;\n\t}\n\n\tpublic inline function next():T {\n\t\treturn args[current++];\n\t}\n}","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","package haxe;\n\nimport haxe.iterators.RestIterator;\nimport haxe.iterators.RestKeyValueIterator;\n\nprivate typedef NativeRest<T> = Array<T>;\n\n/**\n\tA special type that represents a \"rest\" function argument.\n\t\n\tThe special `...` syntax can be used for convenience and improved readability:\n\n\t```haxe\n\tfunction f(...rest:Int) {\n\t\t$type(rest); // haxe.Rest<Int>\n\t}\n\n\tf(1, 2, 3);\n\n\tfinal array = [1, 2, 3];\n\tf(...array);\n\t```\n\n\tShould be used as a type for the last argument of a method, indicating that\n\tan arbitrary number of arguments of the given type can be passed to that method.\n\n\tAllows to use array access by index to get values of rest arguments.\n\tIf the index exceeds the amount of rest arguments passed, the result is unspecified.\n**/\n@:coreApi\nabstract Rest<T>(NativeRest<T>) {\n\t/** Amount of arguments passed as rest arguments */\n\tpublic var length(get,never):Int;\n\tinline function get_length():Int\n\t\treturn this.length;\n\n\t/**\n\t\tCreate rest arguments using contents of `array`.\n\n\t\tWARNING:\n\t\tDepending on a target platform modifying `array` after using this method\n\t\tmay affect the created `Rest` instance.\n\t\tUse `Rest.of(array.copy())` to avoid that.\n\t**/\n\t@:from static public inline function of<T>(array:Array<T>):Rest<T>\n\t\treturn new Rest(array);\n\n\tinline function new(array:Array<T>):Void\n\t\tthis = array;\n\n\t@:arrayAccess inline function get(index:Int):T\n\t\treturn this[index];\n\n\t/**\n\t\tCreates an array containing all the values of rest arguments.\n\t**/\n\t@:to public #if !cppia inline #end function toArray():Array<T>\n\t\treturn this.copy();\n\n\tpublic inline function iterator():RestIterator<T>\n\t\treturn new RestIterator<T>(this);\n\n\tpublic inline function keyValueIterator():RestKeyValueIterator<T>\n\t\treturn new RestKeyValueIterator<T>(this);\n\n\t/**\n\t\tCreate a new rest arguments collection by appending `item` to this one.\n\t**/\n\tpublic function append(item:T):Rest<T> {\n\t\tvar result = this.copy();\n\t\tresult.push(item);\n\t\treturn new Rest(result);\n\t}\n\n\t/**\n\t\tCreate a new rest arguments collection by prepending this one with `item`.\n\t**/\n\tpublic function prepend(item:T):Rest<T> {\n\t\tvar result = this.copy();\n\t\tresult.unshift(item);\n\t\treturn new Rest(result);\n\t}\n\n\tpublic inline function toString():String {\n\t\t#if (flash || js)\n\t\t\treturn '[${this.toString()}]';\n\t\t#else\n\t\t\treturn this.toString();\n\t\t#end\n\t}\n}"]}