{"sourceRoot":"","names":[],"mappings":"QA0BQ;QCQR;QC7BA;;ACDA;AAAA;CAaC,UAbD,CAQ8B;EAAA,AAA7B,kBAA6B,KAM5B;EAAA,SAAS,EACT;EAAA,gBAAgB,EAChB;EAAA,eAAU;;;;;;;CAOX,SACC;EAAA,eAAU,MAAK,QAAO,YAAyB,oBAAqB;;;;;;CAMrE,OACC;EAAA,GAAI,WAAK,MACR;GAAA;;;;;;;CAMF,OAAuB,CACtB;EAAA,GAAI,WAAK,MACR;GAAA;IACD;EAAA,SAAI,KACJ;EAAA,eAAU,UACV;EAAA,GAAI,cAAQ,MACK;GAAA,mBAAmB;GAEnC;GAAA,iBAAY;IACb;EAAA,GAAI,cAAQ,MACX;GAAA,iBAAY;;;;;;;;;;;;AAKf;AAAA;CAGC;;;CAEA,yBACC;EAAA,AAAO;;CAER,mBAAmC,CAClC;EAAA,QAAQ,iBACR;EAAA,MAAO,MAAK,MAAZ,CACC;GAAA,GAAI,eACH;IAAA,AAAO;KACR;GAAA,IAAI;IAEL;EAAA,AAAO;;CAGR,oBACC;EAAA,qBAAqB;;CAGtB,0BACC;EAAA,2BAA2B;;;;;;CAM5B,yBAAoD,GAA4B,CAC/E;EAAA,GAAI,MAAK,MACR;GAAA,MAAM;IACP;EAAA,QAAQ,cAAc,GAAG,UACzB;EAAA,WAAW,iBACX;EAAA,GAAI,SAAQ,MACX;GAAA,YAAY;IACb;EAAA,SAAS,KACT;EAAA,mBAAU,EACV;EAAA,AAAO;;CAGR,oBAA6B,CAI5B;EAAA,WAAW,iBAEX;EAAA,GAAI,SAAQ,MACX;GAAA;IAED;EAAA,aAAa,EAAb;EAAA;EAAA,YAAiC,EAAjC;EAAA,YAA4C,EAC5C;EAAA;EAAA;EAAA;EAAA,SAEA;EAAA,MAAO,OAAM,CACZ;GAAA,IAAI,KACJ;GAAA,OAAO,KACP;GAAA,OAAO,KACP;GAAA,UAAU,EACV;GAAA,MAAO,MAAK,MAAZ,CACC;IAAA,UACA;IAAA,IAAI,EACJ;IAAA,QAAQ,EACR;IAAA,SAAU,EAAV;IAAA,UAAc,OAAd;IAAA,YAAc,KAAd;KAAA,aACC;KAAA,QACA;KAAA,IAAI,OACJ;KAAA,GAAI,MAAK,MACR;MAAA;;MAEF;IAAA,QAAQ,OACR;IAAA,MAAO,SAAQ,KAAK,AAAC,QAAQ,KAAK,KAAK,MAAvC,CACC;KAAA,GAAI,UAAS,GAAG,CACf;MAAA,IAAI,EACJ;MAAA,IAAI,OACJ;MAAA;MACM,SAAI,UAAS,KAChB,KAAK,QACL,CAAC,aAAa,cAAc,AAAC,cAAc,cAAc,aAAa,YAAa,CACtF;MAAA,IAAI,EACJ;MAAA,IAAI,OACJ;MAAA;MACM,OACN;MAAA,IAAI,EACJ;MAAA,IAAI,OACJ;MAAA;OAED;KAAA,GAAI,SAAQ,MACX;MAAA,YAAY;MAEZ;MAAA,OAAO;OACR;KAAA,SAAS,KACT;KAAA,OAAO;MAER;IAAA,IAAI;KAEL;GAAA,YAAY,KACZ;GAAA,GAAI,YAAW,GACd;IAAA;KACD;GAAA,UAAU;IAEX;EAAA,YAAY,KACZ;EAAA,mBAAU;;;;;;CAMX,cAAuB,CACtB;EAAA,sBACA;EAAA,QAAQ,iBACR;EAAA,UAAU,kBACV;EAAA,WAAW,IACX;EAAA,MAAO,MAAK,MAAZ,CACC;GAAA,WAAW,OACX;GAAA,SAAS,YAAY,IACrB;GAAA,GAAI,OAAM,GAAG,CACZ;IAAA,OAAO,EACP;IAAA;KAAA;;IACM,SAAI,QAAO,IACjB;IAAA,OAAO;KACR;GAAA,IAAI;IAEL;EAAA,AAAO","version":3,"file":"MainLoop.js.map","sources":["../../../../../../haxe/versions/4.0.0/std/js/Boot.hx","../../../../../../haxe/versions/4.0.0/std/haxe/EntryPoint.hx","../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../haxe/versions/4.0.0/std/haxe/MainLoop.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","package haxe;\n\n#if target.threaded\nimport sys.thread.Lock;\nimport sys.thread.Mutex;\nimport sys.thread.Thread;\n#elseif sys\nprivate class Lock {\n\tpublic function new() {}\n\n\tpublic inline function release() {}\n\n\tpublic inline function wait(?t:Float) {}\n}\n\nprivate class Mutex {\n\tpublic function new() {}\n\n\tpublic inline function acquire() {}\n\n\tpublic inline function release() {}\n}\n\nprivate class Thread {\n\tpublic static function create(f:Void->Void) {\n\t\tf();\n\t}\n}\n#end\n\n/**\n\tIf `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.\n\tThis class can be redefined by custom frameworks so they can handle their own main loop logic.\n**/\nclass EntryPoint {\n\t#if sys\n\tstatic var sleepLock = new Lock();\n\tstatic var mutex = new Mutex();\n\t#end\n\tstatic var pending = new Array<Void->Void>();\n\tpublic static var threadCount(default, null):Int = 0;\n\n\t/**\n\t\tWakeup a sleeping `run()`\n\t**/\n\tpublic static function wakeup() {\n\t\t#if sys\n\t\tsleepLock.release();\n\t\t#end\n\t}\n\n\tpublic static function runInMainThread(f:Void->Void) {\n\t\t#if sys\n\t\tmutex.acquire();\n\t\tpending.push(f);\n\t\tmutex.release();\n\t\twakeup();\n\t\t#else\n\t\tpending.push(f);\n\t\t#end\n\t}\n\n\tpublic static function addThread(f:Void->Void) {\n\t\t#if sys\n\t\tmutex.acquire();\n\t\tthreadCount++;\n\t\tmutex.release();\n\t\tThread.create(function() {\n\t\t\tf();\n\t\t\tmutex.acquire();\n\t\t\tthreadCount--;\n\t\t\tif (threadCount == 0)\n\t\t\t\twakeup();\n\t\t\tmutex.release();\n\t\t});\n\t\t#else\n\t\tthreadCount++;\n\t\tpending.push(function() {\n\t\t\tf();\n\t\t\tthreadCount--;\n\t\t});\n\t\t#end\n\t}\n\n\tstatic function processEvents():Float {\n\t\t// flush all pending calls\n\t\twhile (true) {\n\t\t\t#if sys\n\t\t\tmutex.acquire();\n\t\t\tvar f = pending.shift();\n\t\t\tmutex.release();\n\t\t\t#else\n\t\t\tvar f = pending.shift();\n\t\t\t#end\n\t\t\tif (f == null)\n\t\t\t\tbreak;\n\t\t\tf();\n\t\t}\n\t\tvar time = @:privateAccess MainLoop.tick();\n\t\tif (!MainLoop.hasEvents() && threadCount == 0)\n\t\t\treturn -1;\n\t\treturn time;\n\t}\n\n\t/**\n\t\tStart the main loop. Depending on the platform, this can return immediately or will only return when the application exits.\n\t**/\n\t@:keep public static function run() @:privateAccess {\n\t\t#if js\n\t\tvar nextTick = processEvents();\n\n\t\t#if nodejs\n\t\tif (nextTick < 0)\n\t\t\treturn;\n\t\t(untyped setTimeout)(run, nextTick);\n\t\t#else\n\t\tvar window:Dynamic = js.Browser.window;\n\t\tvar rqf:Dynamic = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\t\trqf(run);\n\t\t#end\n\t\t#elseif flash\n\t\tflash.Lib.current.stage.addEventListener(flash.events.Event.ENTER_FRAME, function(_) processEvents());\n\t\t#elseif sys\n\t\twhile (true) {\n\t\t\tvar nextTick = processEvents();\n\t\t\tif (nextTick < 0)\n\t\t\t\tbreak;\n\t\t\tif (nextTick > 0)\n\t\t\t\tsleepLock.wait(nextTick); // wait until nextTick or wakeup() call\n\t\t}\n\t\t#else\n\t\t// no implementation available, let's exit immediately\n\t\t#end\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","package haxe;\n\nimport haxe.EntryPoint;\n\nclass MainEvent {\n\tvar f:Void->Void;\n\tvar prev:MainEvent;\n\tvar next:MainEvent;\n\n\t/**\n\t\tTells if the event can lock the process from exiting (default:true)\n\t**/\n\tpublic var isBlocking:Bool = true;\n\n\tpublic var nextRun(default, null):Float;\n\tpublic var priority(default, null):Int;\n\n\tfunction new(f, p) {\n\t\tthis.f = f;\n\t\tthis.priority = p;\n\t\tnextRun = Math.NEGATIVE_INFINITY;\n\t}\n\n\t/**\n\t\tDelay the execution of the event for the given time, in seconds.\n\t\tIf t is null, the event will be run at tick() time.\n\t**/\n\tpublic function delay(t:Null<Float>) {\n\t\tnextRun = t == null ? Math.NEGATIVE_INFINITY : haxe.Timer.stamp() + t;\n\t}\n\n\t/**\n\t\tCall the event. Will do nothing if the event has been stopped.\n\t**/\n\tpublic inline function call() {\n\t\tif (f != null)\n\t\t\tf();\n\t}\n\n\t/**\n\t\tStop the event from firing anymore.\n\t**/\n\tpublic function stop() {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf = null;\n\t\tnextRun = Math.NEGATIVE_INFINITY;\n\t\tif (prev == null)\n\t\t\t@:privateAccess MainLoop.pending = next;\n\t\telse\n\t\t\tprev.next = next;\n\t\tif (next != null)\n\t\t\tnext.prev = prev;\n\t}\n}\n\n@:access(haxe.MainEvent)\nclass MainLoop {\n\tstatic var pending:MainEvent;\n\n\tpublic static var threadCount(get, never):Int;\n\n\tinline static function get_threadCount()\n\t\treturn EntryPoint.threadCount;\n\n\tpublic static function hasEvents() {\n\t\tvar p = pending;\n\t\twhile (p != null) {\n\t\t\tif (p.isBlocking)\n\t\t\t\treturn true;\n\t\t\tp = p.next;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function addThread(f:Void->Void) {\n\t\tEntryPoint.addThread(f);\n\t}\n\n\tpublic static function runInMainThread(f:Void->Void) {\n\t\tEntryPoint.runInMainThread(f);\n\t}\n\n\t/**\n\t\tAdd a pending event to be run into the main loop.\n\t**/\n\tpublic static function add(f:Void->Void, priority = 0):MainEvent@:privateAccess {\n\t\tif (f == null)\n\t\t\tthrow \"Event function is null\";\n\t\tvar e = new MainEvent(f, priority);\n\t\tvar head = pending;\n\t\tif (head != null)\n\t\t\thead.prev = e;\n\t\te.next = head;\n\t\tpending = e;\n\t\treturn e;\n\t}\n\n\tstatic function sortEvents() {\n\t\t// pending = haxe.ds.ListSort.sort(pending, function(e1, e2) return e1.nextRun > e2.nextRun ? -1 : 1);\n\t\t// we can't use directly ListSort because it requires prev/next to be public, which we don't want here\n\t\t// we do then a manual inline, this also allow use to do a Float comparison of nextRun\n\t\tvar list = pending;\n\n\t\tif (list == null)\n\t\t\treturn;\n\n\t\tvar insize = 1, nmerges, psize = 0, qsize = 0;\n\t\tvar p, q, e, tail:MainEvent;\n\n\t\twhile (true) {\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnmerges = 0;\n\t\t\twhile (p != null) {\n\t\t\t\tnmerges++;\n\t\t\t\tq = p;\n\t\t\t\tpsize = 0;\n\t\t\t\tfor (i in 0...insize) {\n\t\t\t\t\tpsize++;\n\t\t\t\t\tq = q.next;\n\t\t\t\t\tif (q == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tqsize = insize;\n\t\t\t\twhile (psize > 0 || (qsize > 0 && q != null)) {\n\t\t\t\t\tif (psize == 0) {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.next;\n\t\t\t\t\t\tqsize--;\n\t\t\t\t\t} else if (qsize == 0\n\t\t\t\t\t\t|| q == null\n\t\t\t\t\t\t|| (p.priority > q.priority || (p.priority == q.priority && p.nextRun <= q.nextRun))) {\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\tpsize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.next;\n\t\t\t\t\t\tqsize--;\n\t\t\t\t\t}\n\t\t\t\t\tif (tail != null)\n\t\t\t\t\t\ttail.next = e;\n\t\t\t\t\telse\n\t\t\t\t\t\tlist = e;\n\t\t\t\t\te.prev = tail;\n\t\t\t\t\ttail = e;\n\t\t\t\t}\n\t\t\t\tp = q;\n\t\t\t}\n\t\t\ttail.next = null;\n\t\t\tif (nmerges <= 1)\n\t\t\t\tbreak;\n\t\t\tinsize *= 2;\n\t\t}\n\t\tlist.prev = null; // not cycling\n\t\tpending = list;\n\t}\n\n\t/**\n\t\tRun the pending events. Return the time for next event.\n\t**/\n\tstatic function tick() {\n\t\tsortEvents();\n\t\tvar e = pending;\n\t\tvar now = haxe.Timer.stamp();\n\t\tvar wait = 1e9;\n\t\twhile (e != null) {\n\t\t\tvar next = e.next;\n\t\t\tvar wt = e.nextRun - now;\n\t\t\tif (wt <= 0) {\n\t\t\t\twait = 0;\n\t\t\t\te.call();\n\t\t\t} else if (wait > wt)\n\t\t\t\twait = wt;\n\t\t\te = next;\n\t\t}\n\t\treturn wait;\n\t}\n}\n"]}