{"sourceRoot":"","names":[],"mappings":"QAKA;QC6BA;QC7BA;;ACDA;AAAA;CAaC,UAbD,CAQ8B;EAAA,AAA7B,kBAA6B,KAM5B;EAAA,SAAS,EACT;EAAA,gBAAgB,EAChB;EAAA,eAAU;;;;;;;CAOX,SACC,CAAU;EAAA;EAAA,SAAK,MAAL;GAAA,MAAY;GAAZ,OAAqC;GAAA,8BAArC;GAAA,MAAqC,8BAAqB;IAApE;EAAA,eAAU;;;;;;CAMX,OACC;EAAA,GAAI,WAAK,MACR;GAAA;;;;;;;CAMF,OAAuB,CACtB;EAAA,GAAI,WAAK,MACR;GAAA;IACD;EAAA,SAAI,KACJ;EAAA,eAAU,UACV;EAAA,GAAI,cAAQ,MACK;GAAA,mBAAmB;GAEnC;GAAA,iBAAY;IACb;EAAA,GAAI,cAAQ,MACX;GAAA,iBAAY;;;;;;;;;;;;AAKf;AAAA;CAGC;;;CAEA,yBACC;EAAA,AAAO;;CAER,mBAAmC,CAClC;EAAA,QAAQ,iBACR;EAAA,MAAO,MAAK,MAAZ,CACC;GAAA,GAAI,eACH;IAAA,AAAO;KACR;GAAA,IAAI;IAEL;EAAA,AAAO;;CAGR,oBACC;EAAA,qBAAqB;;CAGtB,0BACC;EAAA,2BAA2B;;;;;;CAM5B,yBAAoD,GAA4B,CAC/E;EAAA,GAAI,MAAK,MACR;GAAA,uBAAM;IACP;EAAA,QAAQ,cAAc,GAAG,UACzB;EAAA,WAAW,iBACX;EAAA,GAAI,SAAQ,MACX;GAAA,YAAY;IACb;EAAA,SAAS,KACT;EAAA,mBAAU,EACV;EAAA,AAAO;;CAGR,oBAA6B,CAI5B;EAAA,WAAW,iBAEX;EAAA,GAAI,SAAQ,MACX;GAAA;IAED;EAAA,aAAa,EAAb;EAAA;EAAA,YAAiC,EAAjC;EAAA,YAA4C,EAC5C;EAAA;EAAA;EAAA;EAAA,SAEA;EAAA,MAAO,OAAM,CACZ;GAAA,IAAI,KACJ;GAAA,OAAO,KACP;GAAA,OAAO,KACP;GAAA,UAAU,EACV;GAAA,MAAO,MAAK,MAAZ,CACC;IAAA,UACA;IAAA,IAAI,EACJ;IAAA,QAAQ,EACR,AAAU;IAAA,WAAI;IAAA,iBAAd;IAAA,MAAK,CAAK,KAAI,KAAd,CAAU;KAAA,aACT;KAAA,QACA;KAAA,IAAI,OACJ;KAAA,GAAI,MAAK,MACR;MAAA;;MAEF;IAAA,QAAQ,OACR;IAAA,MAAO,SAAQ,KAAK,AAAC,QAAQ,KAAK,KAAK,MAAvC,CACC;KAAA,GAAI,UAAS,GAAG,CACf;MAAA,IAAI,EACJ;MAAA,IAAI,OACJ;MAAA;MACM,SAAI,UAAS,KAChB,KAAK,QACL,CAAC,aAAa,cAAc,AAAC,cAAc,cAAc,aAAa,YAAa,CACtF;MAAA,IAAI,EACJ;MAAA,IAAI,OACJ;MAAA;MACM,OACN;MAAA,IAAI,EACJ;MAAA,IAAI,OACJ;MAAA;OAED;KAAA,GAAI,SAAQ,MACX;MAAA,YAAY;MAEZ;MAAA,OAAO;OACR;KAAA,SAAS,KACT;KAAA,OAAO;MAER;IAAA,IAAI;KAEL;GAAA,YAAY,KACZ;GAAA,GAAI,YAAW,GACd;IAAA;KACD;GAAA,UAAU;IAEX;EAAA,YAAY,KACZ;EAAA,mBAAU;;;;;;CAMX,cAAuB,CACtB;EAAA,sBACA;EAAA,QAAQ,iBACE;EAAA,8BAAV;EAAA,UAAU,4BACV;EAAA,WAAW,IACX;EAAA,MAAO,MAAK,MAAZ,CACC;GAAA,WAAW,OACX;GAAA,SAAS,YAAY,IACrB;GAAA,GAAI,OAAM,GAAG,CACZ;IAAA,OAAO,EACP;IAAA;KAAA;;IACM,SAAI,QAAO,IACjB;IAAA,OAAO;KACR;GAAA,IAAI;IAEL;EAAA,AAAO","version":3,"file":"MainLoop.js.map","sources":["../../../../../../haxe/versions/4.1.4/std/js/_std/haxe/Exception.hx","../../../../../../haxe/versions/4.1.4/std/haxe/EntryPoint.hx","../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../haxe/versions/4.1.4/std/haxe/MainLoop.hx"],"sourcesContent":["package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package haxe;\n\n#if target.threaded\nimport sys.thread.Lock;\nimport sys.thread.Mutex;\nimport sys.thread.Thread;\n#elseif sys\nprivate class Lock {\n\tpublic function new() {}\n\n\tpublic inline function release() {}\n\n\tpublic inline function wait(?t:Float) {}\n}\n\nprivate class Mutex {\n\tpublic function new() {}\n\n\tpublic inline function acquire() {}\n\n\tpublic inline function release() {}\n}\n\nprivate class Thread {\n\tpublic static function create(f:Void->Void) {\n\t\tf();\n\t}\n}\n#end\n\n/**\n\tIf `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.\n\tThis class can be redefined by custom frameworks so they can handle their own main loop logic.\n**/\nclass EntryPoint {\n\t#if sys\n\tstatic var sleepLock = new Lock();\n\tstatic var mutex = new Mutex();\n\t#end\n\tstatic var pending = new Array<Void->Void>();\n\tpublic static var threadCount(default, null):Int = 0;\n\n\t/**\n\t\tWakeup a sleeping `run()`\n\t**/\n\tpublic static function wakeup() {\n\t\t#if sys\n\t\tsleepLock.release();\n\t\t#end\n\t}\n\n\tpublic static function runInMainThread(f:Void->Void) {\n\t\t#if sys\n\t\tmutex.acquire();\n\t\tpending.push(f);\n\t\tmutex.release();\n\t\twakeup();\n\t\t#else\n\t\tpending.push(f);\n\t\t#end\n\t}\n\n\tpublic static function addThread(f:Void->Void) {\n\t\t#if sys\n\t\tmutex.acquire();\n\t\tthreadCount++;\n\t\tmutex.release();\n\t\tThread.create(function() {\n\t\t\tf();\n\t\t\tmutex.acquire();\n\t\t\tthreadCount--;\n\t\t\tif (threadCount == 0)\n\t\t\t\twakeup();\n\t\t\tmutex.release();\n\t\t});\n\t\t#else\n\t\tthreadCount++;\n\t\tpending.push(function() {\n\t\t\tf();\n\t\t\tthreadCount--;\n\t\t});\n\t\t#end\n\t}\n\n\tstatic function processEvents():Float {\n\t\t// flush all pending calls\n\t\twhile (true) {\n\t\t\t#if sys\n\t\t\tmutex.acquire();\n\t\t\tvar f = pending.shift();\n\t\t\tmutex.release();\n\t\t\t#else\n\t\t\tvar f = pending.shift();\n\t\t\t#end\n\t\t\tif (f == null)\n\t\t\t\tbreak;\n\t\t\tf();\n\t\t}\n\t\tvar time = @:privateAccess MainLoop.tick();\n\t\tif (!MainLoop.hasEvents() && threadCount == 0)\n\t\t\treturn -1;\n\t\treturn time;\n\t}\n\n\t/**\n\t\tStart the main loop. Depending on the platform, this can return immediately or will only return when the application exits.\n\t**/\n\t@:keep public static function run() @:privateAccess {\n\t\t#if js\n\t\tvar nextTick = processEvents();\n\t\tinline function setTimeoutNextTick() {\n\t\t\tif (nextTick >= 0) {\n\t\t\t\t(untyped setTimeout)(run, nextTick * 1000);\n\t\t\t}\n\t\t}\n\t\t#if nodejs\n\t\tsetTimeoutNextTick();\n\t\t#else\n\t\tif(js.Lib.typeof(js.Browser.window) != 'undefined') {\n\t\t\tvar window:Dynamic = js.Browser.window;\n\t\t\tvar rqf:Dynamic = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\t\t\tif(rqf != null) {\n\t\t\t\trqf(run);\n\t\t\t} else {\n\t\t\t\tsetTimeoutNextTick();\n\t\t\t}\n\t\t} else {\n\t\t\tsetTimeoutNextTick();\n\t\t}\n\t\t#end\n\t\t#elseif flash\n\t\tflash.Lib.current.stage.addEventListener(flash.events.Event.ENTER_FRAME, function(_) processEvents());\n\t\t#elseif sys\n\t\twhile (true) {\n\t\t\tvar nextTick = processEvents();\n\t\t\tif (nextTick < 0)\n\t\t\t\tbreak;\n\t\t\tif (nextTick > 0)\n\t\t\t\tsleepLock.wait(nextTick); // wait until nextTick or wakeup() call\n\t\t}\n\t\t#else\n\t\t// no implementation available, let's exit immediately\n\t\t#end\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","package haxe;\n\nimport haxe.EntryPoint;\n\nclass MainEvent {\n\tvar f:Void->Void;\n\tvar prev:MainEvent;\n\tvar next:MainEvent;\n\n\t/**\n\t\tTells if the event can lock the process from exiting (default:true)\n\t**/\n\tpublic var isBlocking:Bool = true;\n\n\tpublic var nextRun(default, null):Float;\n\tpublic var priority(default, null):Int;\n\n\tfunction new(f, p) {\n\t\tthis.f = f;\n\t\tthis.priority = p;\n\t\tnextRun = Math.NEGATIVE_INFINITY;\n\t}\n\n\t/**\n\t\tDelay the execution of the event for the given time, in seconds.\n\t\tIf t is null, the event will be run at tick() time.\n\t**/\n\tpublic function delay(t:Null<Float>) {\n\t\tnextRun = t == null ? Math.NEGATIVE_INFINITY : haxe.Timer.stamp() + t;\n\t}\n\n\t/**\n\t\tCall the event. Will do nothing if the event has been stopped.\n\t**/\n\tpublic inline function call() {\n\t\tif (f != null)\n\t\t\tf();\n\t}\n\n\t/**\n\t\tStop the event from firing anymore.\n\t**/\n\tpublic function stop() {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf = null;\n\t\tnextRun = Math.NEGATIVE_INFINITY;\n\t\tif (prev == null)\n\t\t\t@:privateAccess MainLoop.pending = next;\n\t\telse\n\t\t\tprev.next = next;\n\t\tif (next != null)\n\t\t\tnext.prev = prev;\n\t}\n}\n\n@:access(haxe.MainEvent)\nclass MainLoop {\n\tstatic var pending:MainEvent;\n\n\tpublic static var threadCount(get, never):Int;\n\n\tinline static function get_threadCount()\n\t\treturn EntryPoint.threadCount;\n\n\tpublic static function hasEvents() {\n\t\tvar p = pending;\n\t\twhile (p != null) {\n\t\t\tif (p.isBlocking)\n\t\t\t\treturn true;\n\t\t\tp = p.next;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function addThread(f:Void->Void) {\n\t\tEntryPoint.addThread(f);\n\t}\n\n\tpublic static function runInMainThread(f:Void->Void) {\n\t\tEntryPoint.runInMainThread(f);\n\t}\n\n\t/**\n\t\tAdd a pending event to be run into the main loop.\n\t**/\n\tpublic static function add(f:Void->Void, priority = 0):MainEvent@:privateAccess {\n\t\tif (f == null)\n\t\t\tthrow \"Event function is null\";\n\t\tvar e = new MainEvent(f, priority);\n\t\tvar head = pending;\n\t\tif (head != null)\n\t\t\thead.prev = e;\n\t\te.next = head;\n\t\tpending = e;\n\t\treturn e;\n\t}\n\n\tstatic function sortEvents() {\n\t\t// pending = haxe.ds.ListSort.sort(pending, function(e1, e2) return e1.nextRun > e2.nextRun ? -1 : 1);\n\t\t// we can't use directly ListSort because it requires prev/next to be public, which we don't want here\n\t\t// we do then a manual inline, this also allow use to do a Float comparison of nextRun\n\t\tvar list = pending;\n\n\t\tif (list == null)\n\t\t\treturn;\n\n\t\tvar insize = 1, nmerges, psize = 0, qsize = 0;\n\t\tvar p, q, e, tail:MainEvent;\n\n\t\twhile (true) {\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnmerges = 0;\n\t\t\twhile (p != null) {\n\t\t\t\tnmerges++;\n\t\t\t\tq = p;\n\t\t\t\tpsize = 0;\n\t\t\t\tfor (i in 0...insize) {\n\t\t\t\t\tpsize++;\n\t\t\t\t\tq = q.next;\n\t\t\t\t\tif (q == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tqsize = insize;\n\t\t\t\twhile (psize > 0 || (qsize > 0 && q != null)) {\n\t\t\t\t\tif (psize == 0) {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.next;\n\t\t\t\t\t\tqsize--;\n\t\t\t\t\t} else if (qsize == 0\n\t\t\t\t\t\t|| q == null\n\t\t\t\t\t\t|| (p.priority > q.priority || (p.priority == q.priority && p.nextRun <= q.nextRun))) {\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\tpsize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.next;\n\t\t\t\t\t\tqsize--;\n\t\t\t\t\t}\n\t\t\t\t\tif (tail != null)\n\t\t\t\t\t\ttail.next = e;\n\t\t\t\t\telse\n\t\t\t\t\t\tlist = e;\n\t\t\t\t\te.prev = tail;\n\t\t\t\t\ttail = e;\n\t\t\t\t}\n\t\t\t\tp = q;\n\t\t\t}\n\t\t\ttail.next = null;\n\t\t\tif (nmerges <= 1)\n\t\t\t\tbreak;\n\t\t\tinsize *= 2;\n\t\t}\n\t\tlist.prev = null; // not cycling\n\t\tpending = list;\n\t}\n\n\t/**\n\t\tRun the pending events. Return the time for next event.\n\t**/\n\tstatic function tick() {\n\t\tsortEvents();\n\t\tvar e = pending;\n\t\tvar now = haxe.Timer.stamp();\n\t\tvar wait = 1e9;\n\t\twhile (e != null) {\n\t\t\tvar next = e.next;\n\t\t\tvar wt = e.nextRun - now;\n\t\t\tif (wt <= 0) {\n\t\t\t\twait = 0;\n\t\t\t\te.call();\n\t\t\t} else if (wait > wt)\n\t\t\t\twait = wt;\n\t\t\te = next;\n\t\t}\n\t\treturn wait;\n\t}\n}\n"]}