{"sourceRoot":"","names":[],"mappings":"QAyDA;QCpDA;AC6BA;;;;;;;CAWC;;;;iBAAgC;;CAMhC,0BAOC;0BAAa;;CAId,oBAA+C,CAc9C;2BACA;0BAAa,YAAW,CACvB;OACA;;;;CAKF,uBAAsC,CAErC;QAAO,OAAM,CAMZ;WAAQ,2BAER;MAAI,MAAK,MACR;;KACD;;IAED;aAA2B,gBAC3B;KAAI,EAAC,wBAAwB,0BAAe,GAC3C;GAAO;IACR;EAAO;;CAMD;;;;cAA6C,CAEnD;iBAAe,2BAOf;;;;;;;;;;;;;;AA7ED,qBAAqB;AACrB,yBAAmD","version":3,"file":"EntryPoint.js.map","sources":["../../../../../../haxe/versions/4.1.2/std/haxe/MainLoop.hx","../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../haxe/versions/4.1.2/std/haxe/EntryPoint.hx"],"sourcesContent":["package haxe;\n\nimport haxe.EntryPoint;\n\nclass MainEvent {\n\tvar f:Void->Void;\n\tvar prev:MainEvent;\n\tvar next:MainEvent;\n\n\t/**\n\t\tTells if the event can lock the process from exiting (default:true)\n\t**/\n\tpublic var isBlocking:Bool = true;\n\n\tpublic var nextRun(default, null):Float;\n\tpublic var priority(default, null):Int;\n\n\tfunction new(f, p) {\n\t\tthis.f = f;\n\t\tthis.priority = p;\n\t\tnextRun = Math.NEGATIVE_INFINITY;\n\t}\n\n\t/**\n\t\tDelay the execution of the event for the given time, in seconds.\n\t\tIf t is null, the event will be run at tick() time.\n\t**/\n\tpublic function delay(t:Null<Float>) {\n\t\tnextRun = t == null ? Math.NEGATIVE_INFINITY : haxe.Timer.stamp() + t;\n\t}\n\n\t/**\n\t\tCall the event. Will do nothing if the event has been stopped.\n\t**/\n\tpublic inline function call() {\n\t\tif (f != null)\n\t\t\tf();\n\t}\n\n\t/**\n\t\tStop the event from firing anymore.\n\t**/\n\tpublic function stop() {\n\t\tif (f == null)\n\t\t\treturn;\n\t\tf = null;\n\t\tnextRun = Math.NEGATIVE_INFINITY;\n\t\tif (prev == null)\n\t\t\t@:privateAccess MainLoop.pending = next;\n\t\telse\n\t\t\tprev.next = next;\n\t\tif (next != null)\n\t\t\tnext.prev = prev;\n\t}\n}\n\n@:access(haxe.MainEvent)\nclass MainLoop {\n\tstatic var pending:MainEvent;\n\n\tpublic static var threadCount(get, never):Int;\n\n\tinline static function get_threadCount()\n\t\treturn EntryPoint.threadCount;\n\n\tpublic static function hasEvents() {\n\t\tvar p = pending;\n\t\twhile (p != null) {\n\t\t\tif (p.isBlocking)\n\t\t\t\treturn true;\n\t\t\tp = p.next;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static function addThread(f:Void->Void) {\n\t\tEntryPoint.addThread(f);\n\t}\n\n\tpublic static function runInMainThread(f:Void->Void) {\n\t\tEntryPoint.runInMainThread(f);\n\t}\n\n\t/**\n\t\tAdd a pending event to be run into the main loop.\n\t**/\n\tpublic static function add(f:Void->Void, priority = 0):MainEvent@:privateAccess {\n\t\tif (f == null)\n\t\t\tthrow \"Event function is null\";\n\t\tvar e = new MainEvent(f, priority);\n\t\tvar head = pending;\n\t\tif (head != null)\n\t\t\thead.prev = e;\n\t\te.next = head;\n\t\tpending = e;\n\t\treturn e;\n\t}\n\n\tstatic function sortEvents() {\n\t\t// pending = haxe.ds.ListSort.sort(pending, function(e1, e2) return e1.nextRun > e2.nextRun ? -1 : 1);\n\t\t// we can't use directly ListSort because it requires prev/next to be public, which we don't want here\n\t\t// we do then a manual inline, this also allow use to do a Float comparison of nextRun\n\t\tvar list = pending;\n\n\t\tif (list == null)\n\t\t\treturn;\n\n\t\tvar insize = 1, nmerges, psize = 0, qsize = 0;\n\t\tvar p, q, e, tail:MainEvent;\n\n\t\twhile (true) {\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnmerges = 0;\n\t\t\twhile (p != null) {\n\t\t\t\tnmerges++;\n\t\t\t\tq = p;\n\t\t\t\tpsize = 0;\n\t\t\t\tfor (i in 0...insize) {\n\t\t\t\t\tpsize++;\n\t\t\t\t\tq = q.next;\n\t\t\t\t\tif (q == null)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tqsize = insize;\n\t\t\t\twhile (psize > 0 || (qsize > 0 && q != null)) {\n\t\t\t\t\tif (psize == 0) {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.next;\n\t\t\t\t\t\tqsize--;\n\t\t\t\t\t} else if (qsize == 0\n\t\t\t\t\t\t|| q == null\n\t\t\t\t\t\t|| (p.priority > q.priority || (p.priority == q.priority && p.nextRun <= q.nextRun))) {\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.next;\n\t\t\t\t\t\tpsize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.next;\n\t\t\t\t\t\tqsize--;\n\t\t\t\t\t}\n\t\t\t\t\tif (tail != null)\n\t\t\t\t\t\ttail.next = e;\n\t\t\t\t\telse\n\t\t\t\t\t\tlist = e;\n\t\t\t\t\te.prev = tail;\n\t\t\t\t\ttail = e;\n\t\t\t\t}\n\t\t\t\tp = q;\n\t\t\t}\n\t\t\ttail.next = null;\n\t\t\tif (nmerges <= 1)\n\t\t\t\tbreak;\n\t\t\tinsize *= 2;\n\t\t}\n\t\tlist.prev = null; // not cycling\n\t\tpending = list;\n\t}\n\n\t/**\n\t\tRun the pending events. Return the time for next event.\n\t**/\n\tstatic function tick() {\n\t\tsortEvents();\n\t\tvar e = pending;\n\t\tvar now = haxe.Timer.stamp();\n\t\tvar wait = 1e9;\n\t\twhile (e != null) {\n\t\t\tvar next = e.next;\n\t\t\tvar wt = e.nextRun - now;\n\t\t\tif (wt <= 0) {\n\t\t\t\twait = 0;\n\t\t\t\te.call();\n\t\t\t} else if (wait > wt)\n\t\t\t\twait = wt;\n\t\t\te = next;\n\t\t}\n\t\treturn wait;\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","package haxe;\n\n#if target.threaded\nimport sys.thread.Lock;\nimport sys.thread.Mutex;\nimport sys.thread.Thread;\n#elseif sys\nprivate class Lock {\n\tpublic function new() {}\n\n\tpublic inline function release() {}\n\n\tpublic inline function wait(?t:Float) {}\n}\n\nprivate class Mutex {\n\tpublic function new() {}\n\n\tpublic inline function acquire() {}\n\n\tpublic inline function release() {}\n}\n\nprivate class Thread {\n\tpublic static function create(f:Void->Void) {\n\t\tf();\n\t}\n}\n#end\n\n/**\n\tIf `haxe.MainLoop` is kept from DCE, then we will insert an `haxe.EntryPoint.run()` call just at then end of `main()`.\n\tThis class can be redefined by custom frameworks so they can handle their own main loop logic.\n**/\nclass EntryPoint {\n\t#if sys\n\tstatic var sleepLock = new Lock();\n\tstatic var mutex = new Mutex();\n\t#end\n\tstatic var pending = new Array<Void->Void>();\n\tpublic static var threadCount(default, null):Int = 0;\n\n\t/**\n\t\tWakeup a sleeping `run()`\n\t**/\n\tpublic static function wakeup() {\n\t\t#if sys\n\t\tsleepLock.release();\n\t\t#end\n\t}\n\n\tpublic static function runInMainThread(f:Void->Void) {\n\t\t#if sys\n\t\tmutex.acquire();\n\t\tpending.push(f);\n\t\tmutex.release();\n\t\twakeup();\n\t\t#else\n\t\tpending.push(f);\n\t\t#end\n\t}\n\n\tpublic static function addThread(f:Void->Void) {\n\t\t#if sys\n\t\tmutex.acquire();\n\t\tthreadCount++;\n\t\tmutex.release();\n\t\tThread.create(function() {\n\t\t\tf();\n\t\t\tmutex.acquire();\n\t\t\tthreadCount--;\n\t\t\tif (threadCount == 0)\n\t\t\t\twakeup();\n\t\t\tmutex.release();\n\t\t});\n\t\t#else\n\t\tthreadCount++;\n\t\tpending.push(function() {\n\t\t\tf();\n\t\t\tthreadCount--;\n\t\t});\n\t\t#end\n\t}\n\n\tstatic function processEvents():Float {\n\t\t// flush all pending calls\n\t\twhile (true) {\n\t\t\t#if sys\n\t\t\tmutex.acquire();\n\t\t\tvar f = pending.shift();\n\t\t\tmutex.release();\n\t\t\t#else\n\t\t\tvar f = pending.shift();\n\t\t\t#end\n\t\t\tif (f == null)\n\t\t\t\tbreak;\n\t\t\tf();\n\t\t}\n\t\tvar time = @:privateAccess MainLoop.tick();\n\t\tif (!MainLoop.hasEvents() && threadCount == 0)\n\t\t\treturn -1;\n\t\treturn time;\n\t}\n\n\t/**\n\t\tStart the main loop. Depending on the platform, this can return immediately or will only return when the application exits.\n\t**/\n\t@:keep public static function run() @:privateAccess {\n\t\t#if js\n\t\tvar nextTick = processEvents();\n\t\tinline function setTimeoutNextTick() {\n\t\t\tif (nextTick >= 0) {\n\t\t\t\t(untyped setTimeout)(run, nextTick * 1000);\n\t\t\t}\n\t\t}\n\t\t#if nodejs\n\t\tsetTimeoutNextTick();\n\t\t#else\n\t\tif(js.Lib.typeof(js.Browser.window) != 'undefined') {\n\t\t\tvar window:Dynamic = js.Browser.window;\n\t\t\tvar rqf:Dynamic = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n\t\t\tif(rqf != null) {\n\t\t\t\trqf(run);\n\t\t\t} else {\n\t\t\t\tsetTimeoutNextTick();\n\t\t\t}\n\t\t} else {\n\t\t\tsetTimeoutNextTick();\n\t\t}\n\t\t#end\n\t\t#elseif flash\n\t\tflash.Lib.current.stage.addEventListener(flash.events.Event.ENTER_FRAME, function(_) processEvents());\n\t\t#elseif sys\n\t\twhile (true) {\n\t\t\tvar nextTick = processEvents();\n\t\t\tif (nextTick < 0)\n\t\t\t\tbreak;\n\t\t\tif (nextTick > 0)\n\t\t\t\tsleepLock.wait(nextTick); // wait until nextTick or wakeup() call\n\t\t}\n\t\t#else\n\t\t// no implementation available, let's exit immediately\n\t\t#end\n\t}\n}\n"]}