{"sourceRoot":"","names":[],"mappings":"QA0BQ;QCOR;QC5BA;QC4EA;QChDU;QCPA;QCLA;QCiBV;ACPA;;;;;;;;CASC;;;;;;;;;mBAAuD,CACtD;aAAW,cAAc,GAAG,UAC5B;KAAI,SAAQ,MACX;SAAO,yBAAQ,AAAkB,aAAG;IAErC;UAAQ,UAAU,qBAClB;cAAY,+BAAyC,GACrD;KAAQ,oBACF,GAAL,CAAgB;oBACf;GAAO;GACR,OAAK;WAHE,MAIN;SAAO,gEAA8C;;;CASxD;;;;;;mBACC;EAAO,kBAAW,oBAAoB,IAAI","version":3,"file":"Rtti.js.map","sources":["../../../../../../../haxe/versions/4.0.3/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.3/std/haxe/rtti/XmlParser.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.3/std/Xml.hx","../../../../../../../haxe/versions/4.0.3/std/js/_std/Type.hx","../../../../../../../haxe/versions/4.0.3/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.0.3/std/js/_std/Reflect.hx","../../../../../../../haxe/versions/4.0.3/std/Lambda.hx","../../../../../../../haxe/versions/4.0.3/std/haxe/rtti/Rtti.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\nimport haxe.rtti.CType;\nimport haxe.xml.Access;\n\n/**\n\tXmlParser processes the runtime type information (RTTI) which\n\tis stored as a XML string in a static field `__rtti`.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>\n**/\nclass XmlParser {\n\tpublic var root:TypeRoot;\n\n\tvar curplatform:String;\n\n\tpublic function new() {\n\t\troot = new Array();\n\t}\n\n\tpublic function sort(?l:TypeRoot) {\n\t\tif (l == null)\n\t\t\tl = root;\n\t\tl.sort(function(e1, e2) {\n\t\t\tvar n1 = switch e1 {\n\t\t\t\tcase TPackage(p, _, _): \" \" + p;\n\t\t\t\tdefault: TypeApi.typeInfos(e1).path;\n\t\t\t};\n\t\t\tvar n2 = switch e2 {\n\t\t\t\tcase TPackage(p, _, _): \" \" + p;\n\t\t\t\tdefault: TypeApi.typeInfos(e2).path;\n\t\t\t};\n\t\t\tif (n1 > n2)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t});\n\t\tfor (x in l)\n\t\t\tswitch (x) {\n\t\t\t\tcase TPackage(_, _, l):\n\t\t\t\t\tsort(l);\n\t\t\t\tcase TClassdecl(c):\n\t\t\t\t\tsortFields(c.fields);\n\t\t\t\t\tsortFields(c.statics);\n\t\t\t\tcase TEnumdecl(_):\n\t\t\t\tcase TAbstractdecl(_):\n\t\t\t\tcase TTypedecl(_):\n\t\t\t}\n\t}\n\n\tfunction sortFields(a:Array<ClassField>) {\n\t\ta.sort(function(f1:ClassField, f2:ClassField) {\n\t\t\tvar v1 = TypeApi.isVar(f1.type);\n\t\t\tvar v2 = TypeApi.isVar(f2.type);\n\t\t\tif (v1 && !v2)\n\t\t\t\treturn -1;\n\t\t\tif (v2 && !v1)\n\t\t\t\treturn 1;\n\t\t\tif (f1.name == \"new\")\n\t\t\t\treturn -1;\n\t\t\tif (f2.name == \"new\")\n\t\t\t\treturn 1;\n\t\t\tif (f1.name > f2.name)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t});\n\t}\n\n\tpublic function process(x:Xml, platform:String) {\n\t\tcurplatform = platform;\n\t\txroot(new Access(x));\n\t}\n\n\t// merge inline and not inline\n\tfunction mergeRights(f1:ClassField, f2:ClassField) {\n\t\tif (f1.get == RInline && f1.set == RNo && f2.get == RNormal && f2.set == RMethod) {\n\t\t\tf1.get = RNormal;\n\t\t\tf1.set = RMethod;\n\t\t\treturn true;\n\t\t}\n\t\treturn Type.enumEq(f1.get, f2.get) && Type.enumEq(f1.set, f2.set);\n\t}\n\n\tfunction mergeDoc(f1:ClassField, f2:ClassField) {\n\t\tif (f1.doc == null)\n\t\t\tf1.doc = f2.doc;\n\t\telse if (f2.doc == null)\n\t\t\tf2.doc = f1.doc;\n\t\treturn true;\n\t}\n\n\tfunction mergeFields(f:ClassField, f2:ClassField) {\n\t\treturn TypeApi.fieldEq(f, f2)\n\t\t\t|| (f.name == f2.name && (mergeRights(f, f2) || mergeRights(f2, f)) && mergeDoc(f, f2) && TypeApi.fieldEq(f, f2));\n\t}\n\n\tpublic dynamic function newField(c:Classdef, f:ClassField) {}\n\n\tfunction mergeClasses(c:Classdef, c2:Classdef) {\n\t\t// todo : compare supers & interfaces\n\t\tif (c.isInterface != c2.isInterface)\n\t\t\treturn false;\n\t\tif (curplatform != null)\n\t\t\tc.platforms.push(curplatform);\n\t\tif (c.isExtern != c2.isExtern)\n\t\t\tc.isExtern = false;\n\n\t\tfor (f2 in c2.fields) {\n\t\t\tvar found = null;\n\t\t\tfor (f in c.fields)\n\t\t\t\tif (mergeFields(f, f2)) {\n\t\t\t\t\tfound = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null) {\n\t\t\t\tnewField(c, f2);\n\t\t\t\tc.fields.push(f2);\n\t\t\t} else if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\tfor (f2 in c2.statics) {\n\t\t\tvar found = null;\n\t\t\tfor (f in c.statics)\n\t\t\t\tif (mergeFields(f, f2)) {\n\t\t\t\t\tfound = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null) {\n\t\t\t\tnewField(c, f2);\n\t\t\t\tc.statics.push(f2);\n\t\t\t} else if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mergeEnums(e:Enumdef, e2:Enumdef) {\n\t\tif (e.isExtern != e2.isExtern)\n\t\t\treturn false;\n\t\tif (curplatform != null)\n\t\t\te.platforms.push(curplatform);\n\t\tfor (c2 in e2.constructors) {\n\t\t\tvar found = null;\n\t\t\tfor (c in e.constructors)\n\t\t\t\tif (TypeApi.constructorEq(c, c2)) {\n\t\t\t\t\tfound = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null)\n\t\t\t\treturn false; // don't allow by-platform constructor ?\n\t\t\tif (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mergeTypedefs(t:Typedef, t2:Typedef) {\n\t\tif (curplatform == null)\n\t\t\treturn false;\n\t\tt.platforms.push(curplatform);\n\t\tt.types.set(curplatform, t2.type);\n\t\treturn true;\n\t}\n\n\tfunction mergeAbstracts(a:Abstractdef, a2:Abstractdef) {\n\t\tif (curplatform == null)\n\t\t\treturn false;\n\t\tif (a.to.length != a2.to.length || a.from.length != a2.from.length)\n\t\t\treturn false;\n\t\tfor (i in 0...a.to.length)\n\t\t\tif (!TypeApi.typeEq(a.to[i].t, a2.to[i].t))\n\t\t\t\treturn false;\n\t\tfor (i in 0...a.from.length)\n\t\t\tif (!TypeApi.typeEq(a.from[i].t, a2.from[i].t))\n\t\t\t\treturn false;\n\t\tif (a2.impl != null)\n\t\t\tmergeClasses(a.impl, a2.impl);\n\t\ta.platforms.push(curplatform);\n\t\treturn true;\n\t}\n\n\tfunction merge(t:TypeTree) {\n\t\tvar inf = TypeApi.typeInfos(t);\n\t\tvar pack = inf.path.split(\".\");\n\t\tvar cur = root;\n\t\tvar curpack = new Array();\n\t\tpack.pop();\n\t\tfor (p in pack) {\n\t\t\tvar found = false;\n\t\t\tfor (pk in cur)\n\t\t\t\tswitch (pk) {\n\t\t\t\t\tcase TPackage(pname, _, subs):\n\t\t\t\t\t\tif (pname == p) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tcur = subs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcurpack.push(p);\n\t\t\tif (!found) {\n\t\t\t\tvar pk = new Array();\n\t\t\t\tcur.push(TPackage(p, curpack.join(\".\"), pk));\n\t\t\t\tcur = pk;\n\t\t\t}\n\t\t}\n\t\tfor (ct in cur) {\n\t\t\tif (ct.match(TPackage(_)))\n\t\t\t\tcontinue;\n\t\t\tvar tinf = TypeApi.typeInfos(ct);\n\n\t\t\t// compare params ?\n\t\t\tif (tinf.path == inf.path) {\n\t\t\t\tvar sameType = true;\n\t\t\t\tif ((tinf.doc == null) != (inf.doc == null)) {\n\t\t\t\t\tif (inf.doc == null)\n\t\t\t\t\t\tinf.doc = tinf.doc;\n\t\t\t\t\telse\n\t\t\t\t\t\ttinf.doc = inf.doc;\n\t\t\t\t}\n\t\t\t\tif (tinf.path == \"haxe._Int64.NativeInt64\")\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tinf.module == inf.module && tinf.doc == inf.doc && tinf.isPrivate == inf.isPrivate)\n\t\t\t\t\tswitch (ct) {\n\t\t\t\t\t\tcase TClassdecl(c):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TClassdecl(c2):\n\t\t\t\t\t\t\t\t\tif (mergeClasses(c, c2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TEnumdecl(e):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TEnumdecl(e2):\n\t\t\t\t\t\t\t\t\tif (mergeEnums(e, e2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TTypedecl(td):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TTypedecl(td2):\n\t\t\t\t\t\t\t\t\tif (mergeTypedefs(td, td2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TAbstractdecl(a):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TAbstractdecl(a2):\n\t\t\t\t\t\t\t\t\tif (mergeAbstracts(a, a2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TPackage(_, _, _):\n\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t}\n\t\t\t\t// we already have a mapping, but which is incompatible\n\t\t\t\tvar msg = if (tinf.module != inf.module) \"module \" + inf.module + \" should be \" + tinf.module; else if (tinf.doc != inf.doc)\n\t\t\t\t\t\"documentation is different\";\n\t\t\t\telse if (tinf.isPrivate != inf.isPrivate)\n\t\t\t\t\t\"private flag is different\";\n\t\t\t\telse if (!sameType)\n\t\t\t\t\t\"type kind is different\";\n\t\t\t\telse\n\t\t\t\t\t\"could not merge definition\";\n\t\t\t\tthrow \"Incompatibilities between \" + tinf.path + \" in \" + tinf.platforms.join(\",\") + \" and \" + curplatform + \" (\" + msg + \")\";\n\t\t\t}\n\t\t}\n\t\tcur.push(t);\n\t}\n\n\tfunction mkPath(p:String):Path {\n\t\treturn p;\n\t}\n\n\tfunction mkTypeParams(p:String):TypeParams {\n\t\tvar pl = p.split(\":\");\n\t\tif (pl[0] == \"\")\n\t\t\treturn new Array();\n\t\treturn pl;\n\t}\n\n\tfunction mkRights(r:String):Rights {\n\t\treturn switch (r) {\n\t\t\tcase \"null\": RNo;\n\t\t\tcase \"method\": RMethod;\n\t\t\tcase \"dynamic\": RDynamic;\n\t\t\tcase \"inline\": RInline;\n\t\t\tdefault: RCall(r);\n\t\t}\n\t}\n\n\tfunction xerror(c:Access):Dynamic {\n\t\treturn throw \"Invalid \" + c.name;\n\t}\n\n\tfunction xroot(x:Access) {\n\t\tfor (c in x.x.elements())\n\t\t\tmerge(processElement(c));\n\t}\n\n\tpublic function processElement(x:Xml) {\n\t\tvar c = new haxe.xml.Access(x);\n\t\treturn switch (c.name) {\n\t\t\tcase \"class\": TClassdecl(xclass(c));\n\t\t\tcase \"enum\": TEnumdecl(xenum(c));\n\t\t\tcase \"typedef\": TTypedecl(xtypedef(c));\n\t\t\tcase \"abstract\": TAbstractdecl(xabstract(c));\n\t\t\tdefault: xerror(c);\n\t\t}\n\t}\n\n\tfunction xmeta(x:Access):MetaData {\n\t\tvar ml = [];\n\t\tfor (m in x.nodes.m) {\n\t\t\tvar pl = [];\n\t\t\tfor (p in m.nodes.e)\n\t\t\t\tpl.push(p.innerHTML);\n\t\t\tml.push({name: m.att.n, params: pl});\n\t\t}\n\t\treturn ml;\n\t}\n\n\tfunction xoverloads(x:Access):Array<ClassField> {\n\t\tvar l = new Array();\n\t\tfor (m in x.elements) {\n\t\t\tl.push(xclassfield(m));\n\t\t}\n\t\treturn l;\n\t}\n\n\tfunction xpath(x:Access):PathParams {\n\t\tvar path = mkPath(x.att.path);\n\t\tvar params = new Array();\n\t\tfor (c in x.elements)\n\t\t\tparams.push(xtype(c));\n\t\treturn {\n\t\t\tpath: path,\n\t\t\tparams: params,\n\t\t};\n\t}\n\n\tfunction xclass(x:Access):Classdef {\n\t\tvar csuper = null;\n\t\tvar doc = null;\n\t\tvar tdynamic = null;\n\t\tvar interfaces = new Array();\n\t\tvar fields = new Array();\n\t\tvar statics = new Array();\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"extends\":\n\t\t\t\t\tcsuper = xpath(c);\n\t\t\t\tcase \"implements\":\n\t\t\t\t\tinterfaces.push(xpath(c));\n\t\t\t\tcase \"haxe_dynamic\":\n\t\t\t\t\ttdynamic = xtype(new Access(c.x.firstElement()));\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tdefault:\n\t\t\t\t\tif (c.x.exists(\"static\"))\n\t\t\t\t\t\tstatics.push(xclassfield(c));\n\t\t\t\t\telse\n\t\t\t\t\t\tfields.push(xclassfield(c));\n\t\t\t}\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tisExtern: x.x.exists(\"extern\"),\n\t\t\tisInterface: x.x.exists(\"interface\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tsuperClass: csuper,\n\t\t\tinterfaces: interfaces,\n\t\t\tfields: fields,\n\t\t\tstatics: statics,\n\t\t\ttdynamic: tdynamic,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xclassfield(x:Access, ?defPublic = false):ClassField {\n\t\tvar e = x.elements;\n\t\tvar t = xtype(e.next());\n\t\tvar doc = null;\n\t\tvar meta = [];\n\t\tvar overloads = null;\n\t\tfor (c in e)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tcase \"overloads\":\n\t\t\t\t\toverloads = xoverloads(c);\n\t\t\t\tdefault:\n\t\t\t\t\txerror(c);\n\t\t\t}\n\t\treturn {\n\t\t\tname:x.name, type:t, isPublic:x.x.exists(\"public\") || defPublic, isFinal:x.x.exists(\"final\"), isOverride:x.x.exists(\"override\"),\n\t\t\tline:if (x.has.line) Std.parseInt(x.att.line) else null, doc:doc, get:if (x.has.get) mkRights(x.att.get) else RNormal, set:if (x.has.set)\n\t\t\t\tmkRights(x.att.set)\n\t\t\telse\n\t\t\t\tRNormal, params:if (x.has.params) mkTypeParams(x.att.params) else [], platforms:defplat(), meta:meta, overloads:overloads, expr:if (x.has.expr)\n\t\t\t\tx.att.expr\n\t\t\telse\n\t\t\t\tnull\n\t\t};\n\t}\n\n\tfunction xenum(x:Access):Enumdef {\n\t\tvar cl = new Array();\n\t\tvar doc = null;\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tif (c.name == \"haxe_doc\")\n\t\t\t\tdoc = c.innerData;\n\t\t\telse if (c.name == \"meta\")\n\t\t\t\tmeta = xmeta(c);\n\t\t\telse\n\t\t\t\tcl.push(xenumfield(c));\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tisExtern: x.x.exists(\"extern\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tconstructors: cl,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xenumfield(x:Access):EnumField {\n\t\tvar args = null;\n\t\tvar docElements = x.x.elementsNamed(\"haxe_doc\");\n\t\tvar xdoc = if (docElements.hasNext()) docElements.next() else null;\n\t\tvar meta = if (x.hasNode.meta) xmeta(x.node.meta) else [];\n\t\tif (x.has.a) {\n\t\t\tvar names = x.att.a.split(\":\");\n\t\t\tvar elts = x.elements;\n\t\t\targs = new Array();\n\t\t\tfor (c in names) {\n\t\t\t\tvar opt = false;\n\t\t\t\tif (c.charAt(0) == \"?\") {\n\t\t\t\t\topt = true;\n\t\t\t\t\tc = c.substr(1);\n\t\t\t\t}\n\t\t\t\targs.push({\n\t\t\t\t\tname: c,\n\t\t\t\t\topt: opt,\n\t\t\t\t\tt: xtype(elts.next()),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: x.name,\n\t\t\targs: args,\n\t\t\tdoc: if (xdoc == null) null else new Access(xdoc).innerData,\n\t\t\tmeta: meta,\n\t\t\tplatforms: defplat(),\n\t\t};\n\t}\n\n\tfunction xabstract(x:Access):Abstractdef {\n\t\tvar doc = null, impl = null, athis = null;\n\t\tvar meta = [], to = [], from = [];\n\t\tfor (c in x.elements)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tcase \"to\":\n\t\t\t\t\tfor (t in c.elements)\n\t\t\t\t\t\tto.push({t: xtype(new Access(t.x.firstElement())), field: t.has.field ? t.att.field : null});\n\t\t\t\tcase \"from\":\n\t\t\t\t\tfor (t in c.elements)\n\t\t\t\t\t\tfrom.push({t: xtype(new Access(t.x.firstElement())), field: t.has.field ? t.att.field : null});\n\t\t\t\tcase \"impl\":\n\t\t\t\t\timpl = xclass(c.node.resolve(\"class\"));\n\t\t\t\tcase \"this\":\n\t\t\t\t\tathis = xtype(new Access(c.x.firstElement()));\n\t\t\t\tdefault:\n\t\t\t\t\txerror(c);\n\t\t\t}\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t\tathis: athis,\n\t\t\tto: to,\n\t\t\tfrom: from,\n\t\t\timpl: impl\n\t\t};\n\t}\n\n\tfunction xtypedef(x:Access):Typedef {\n\t\tvar doc = null;\n\t\tvar t = null;\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tif (c.name == \"haxe_doc\")\n\t\t\t\tdoc = c.innerData;\n\t\t\telse if (c.name == \"meta\")\n\t\t\t\tmeta = xmeta(c);\n\t\t\telse\n\t\t\t\tt = xtype(c);\n\t\tvar types = new haxe.ds.StringMap();\n\t\tif (curplatform != null)\n\t\t\ttypes.set(curplatform, t);\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\ttype: t,\n\t\t\ttypes: types,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xtype(x:Access):CType {\n\t\treturn switch (x.name) {\n\t\t\tcase \"unknown\":\n\t\t\t\tCUnknown;\n\t\t\tcase \"e\":\n\t\t\t\tCEnum(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"c\":\n\t\t\t\tCClass(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"t\":\n\t\t\t\tCTypedef(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"x\":\n\t\t\t\tCAbstract(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"f\":\n\t\t\t\tvar args = new Array();\n\t\t\t\tvar aname = x.att.a.split(\":\");\n\t\t\t\tvar eargs = aname.iterator();\n\t\t\t\tvar evalues = x.has.v ? x.att.v.split(\":\").iterator() : null;\n\t\t\t\tfor (e in x.elements) {\n\t\t\t\t\tvar opt = false;\n\t\t\t\t\tvar a = eargs.hasNext() ? eargs.next() : null;\n\t\t\t\t\tif (a == null)\n\t\t\t\t\t\ta = \"\";\n\t\t\t\t\tif (a.charAt(0) == \"?\") {\n\t\t\t\t\t\topt = true;\n\t\t\t\t\t\ta = a.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\tvar v = evalues == null || !evalues.hasNext() ? null : evalues.next();\n\t\t\t\t\targs.push({\n\t\t\t\t\t\tname: a,\n\t\t\t\t\t\topt: opt,\n\t\t\t\t\t\tt: xtype(e),\n\t\t\t\t\t\tvalue: v == \"\" ? null : v\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tvar ret = args[args.length - 1];\n\t\t\t\targs.remove(ret);\n\t\t\t\tCFunction(args, ret.t);\n\t\t\tcase \"a\":\n\t\t\t\tvar fields = new Array();\n\t\t\t\tfor (f in x.elements) {\n\t\t\t\t\tvar f = xclassfield(f, true);\n\t\t\t\t\tf.platforms = new Array(); // platforms selection are on the type itself, not on fields\n\t\t\t\t\tfields.push(f);\n\t\t\t\t}\n\t\t\t\tCAnonymous(fields);\n\t\t\tcase \"d\":\n\t\t\t\tvar t = null;\n\t\t\t\tvar tx = x.x.firstElement();\n\t\t\t\tif (tx != null)\n\t\t\t\t\tt = xtype(new Access(tx));\n\t\t\t\tCDynamic(t);\n\t\t\tdefault:\n\t\t\t\txerror(x);\n\t\t}\n\t}\n\n\tfunction xtypeparams(x:Access):Array<CType> {\n\t\tvar p = new Array();\n\t\tfor (c in x.elements)\n\t\t\tp.push(xtype(c));\n\t\treturn p;\n\t}\n\n\tfunction defplat() {\n\t\tvar l = new Array();\n\t\tif (curplatform != null)\n\t\t\tl.push(curplatform);\n\t\treturn l;\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tXml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nenum abstract XmlType(Int) {\n\t/**\n\t\tRepresents an XML element type.\n\t**/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n\t**/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n\t**/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n\t**/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n\t**/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n\t**/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n\t**/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nclass Xml {\n\t/**\n\t\tXML element type.\n\t**/\n\tstatic public var Element(default, never) = XmlType.Element;\n\n\t/**\n\t\tXML parsed character data type.\n\t**/\n\tstatic public var PCData(default, never) = XmlType.PCData;\n\n\t/**\n\t\tXML character data type.\n\t**/\n\tstatic public var CData(default, never) = XmlType.CData;\n\n\t/**\n\t\tXML comment type.\n\t**/\n\tstatic public var Comment(default, never) = XmlType.Comment;\n\n\t/**\n\t\tXML doctype element type.\n\t**/\n\tstatic public var DocType(default, never) = XmlType.DocType;\n\n\t/**\n\t\tXML processing instruction type.\n\t**/\n\tstatic public var ProcessingInstruction(default, never) = XmlType.ProcessingInstruction;\n\n\t/**\n\t\tXML document type.\n\t**/\n\tstatic public var Document(default, never) = XmlType.Document;\n\n\t/**\n\t\tParses the String into an Xml document.\n\t**/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n\t**/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n\t**/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n\t**/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n\t**/\n\tpublic var parent(default, null):Xml;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createElement(name:String):Xml {\n\t\tvar xml = new Xml(Element);\n\t\txml.nodeName = name;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createPCData(data:String):Xml {\n\t\tvar xml = new Xml(PCData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createCData(data:String):Xml {\n\t\tvar xml = new Xml(CData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createComment(data:String):Xml {\n\t\tvar xml = new Xml(Comment);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocType(data:String):Xml {\n\t\tvar xml = new Xml(DocType);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createProcessingInstruction(data:String):Xml {\n\t\tvar xml = new Xml(ProcessingInstruction);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocument():Xml {\n\t\treturn new Xml(Document);\n\t}\n\n\t/**\n\t\tGet the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function get(att:String):String {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap[att];\n\t}\n\n\t/**\n\t\tSet the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function set(att:String, value:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.set(att, value);\n\t}\n\n\t/**\n\t\tRemoves an attribute for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function remove(att:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.remove(att);\n\t}\n\n\t/**\n\t\tTells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function exists(att:String):Bool {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.exists(att);\n\t}\n\n\t/**\n\t\tReturns an `Iterator` on all the attribute names.\n\t**/\n\tpublic function attributes():Iterator<String> {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.keys();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elements():Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [for (child in children) if (child.nodeType == Element) child];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elementsNamed(name:String):Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [\n\t\t\tfor (child in children)\n\t\t\t\tif (child.nodeType == Element && child.nodeName == name) child\n\t\t];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns the first child node.\n\t**/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.\n\t**/\n\tpublic function firstElement():Xml {\n\t\tensureElementType();\n\t\tfor (child in children) {\n\t\t\tif (child.nodeType == Element) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tAdds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function addChild(x:Xml):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.removeChild(x);\n\t\t}\n\t\tchildren.push(x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tRemoves a child from the Document or Element.\n\t\tReturns true if the child was successfuly removed.\n\t**/\n\tpublic function removeChild(x:Xml):Bool {\n\t\tensureElementType();\n\t\tif (children.remove(x)) {\n\t\t\tx.parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tInserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function insertChild(x:Xml, pos:Int):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.children.remove(x);\n\t\t}\n\t\tchildren.insert(pos, x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tReturns a String representation of the Xml node.\n\t**/\n\tpublic #if !cppia inline #end function toString():String {\n\t\treturn haxe.xml.Printer.print(this);\n\t}\n\n\tfunction new(nodeType:XmlType) {\n\t\tthis.nodeType = nodeType;\n\t\tchildren = [];\n\t\tattributeMap = new Map();\n\t}\n\n\tinline function ensureElementType() {\n\t\tif (nodeType != Document && nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element or Document but found $nodeType';\n\t\t}\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass(c:Class<Dynamic>);\n\tTEnum(e:Enum<Dynamic>);\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\tpublic static inline function getClass<T>(o:T):Class<T> {\n\t\treturn @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum(o:EnumValue):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn null;\n\t\t\t#if js_enums_as_arrays\n\t\t\treturn o.__enum__;\n\t\t\t#else\n\t\t\treturn $hxEnums[o.__enum__];\n\t\t\t#end\n\t\t}\n\n\tpublic static inline function getSuperClass(c:Class<Dynamic>):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.getSuperClass\", c.__super__);\n\t}\n\n\tpublic static inline function getClassName(c:Class<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getClassName\", c.__name__);\n\t}\n\n\tpublic static inline function getEnumName(e:Enum<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getEnumName\", e.__ename__);\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic static function resolveClass(name:String):Class<Dynamic>\n\t\tuntyped {\n\t\t\tvar cl:Class<Dynamic> = $hxClasses[name];\n\t\t\t// ensure that this is a class\n\t\t\tif (cl == null || !js.Boot.isClass(cl))\n\t\t\t\treturn null;\n\t\t\treturn cl;\n\t\t}\n\n\tpublic static function resolveEnum(name:String):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tvar e:Dynamic = $hxClasses[name];\n\t\t\t// ensure that this is an enum\n\t\t\tif (e == null || !js.Boot.isEnum(e))\n\t\t\t\treturn null;\n\t\t\treturn e;\n\t\t}\n\t#else\n\tpublic static inline function resolveClass(name:String):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveClass\", $hxClasses[name]);\n\t}\n\n\tpublic static inline function resolveEnum(name:String):Enum<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveEnum\", $hxEnums[name]);\n\t}\n\t#end\n\n\t#if (js_es < 5)\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T {\n\t\tswitch (args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn js.Syntax.construct(cl);\n\t\t\tcase 1:\n\t\t\t\treturn js.Syntax.construct(cl, args[0]);\n\t\t\tcase 2:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1]);\n\t\t\tcase 3:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2]);\n\t\t\tcase 4:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3]);\n\t\t\tcase 5:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4]);\n\t\t\tcase 6:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5]);\n\t\t\tcase 7:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t\t\tcase 8:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n\t\t\tcase 9:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n\t\t\tcase 10:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n\t\t\tcase 11:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\n\t\t\tcase 12:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\n\t\t\tcase 13:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12]);\n\t\t\tcase 14:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12], args[13]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t}\n\n\tpublic static function createEmptyInstance<T>(cl:Class<T>):T\n\t\tuntyped {\n\t\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\t\treturn __js__(\"new empty()\");\n\t\t}\n\t#else\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T\n\t\tuntyped {\n\t\t\treturn untyped __js__(\"new ({0})\", Function.prototype.bind.apply(cl, [null].concat(args)));\n\t\t}\n\n\tpublic static inline function createEmptyInstance<T>(cl:Class<T>):T {\n\t\treturn js.lib.Object.create((cast cl).prototype);\n\t}\n\t#end\n\n\tpublic static function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\n\t\tvar f:Dynamic = Reflect.field(e, constr);\n\t\tif (f == null)\n\t\t\tthrow \"No such constructor \" + constr;\n\t\tif (Reflect.isFunction(f)) {\n\t\t\tif (params == null)\n\t\t\t\tthrow \"Constructor \" + constr + \" need parameters\";\n\t\t\treturn Reflect.callMethod(e, f, params);\n\t\t}\n\t\tif (params != null && params.length != 0)\n\t\t\tthrow \"Constructor \" + constr + \" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\n\t\tvar c:String = (untyped e.__constructs__)[index];\n\t\tif (c == null)\n\t\t\tthrow index + \" is not a valid enum constructor index\";\n\t\treturn createEnum(e, c, params);\n\t}\n\n\t#if (js_es >= 6)\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar result = [];\n\t\twhile (c != null) {\n\t\t\tfor (name in js.lib.Object.getOwnPropertyNames((cast c).prototype)) {\n\t\t\t\tswitch name {\n\t\t\t\t\tcase \"constructor\" | \"__class__\" | \"__properties__\":\n\t\t\t\t\t// skip special names\n\t\t\t\t\tcase _:\n\t\t\t\t\t\tif (result.indexOf(name) == -1)\n\t\t\t\t\t\t\tresult.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = getSuperClass(c);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = js.lib.Object.getOwnPropertyNames(cast c);\n\t\ta.remove(\"__id__\");\n\t\ta.remove(\"hx__closures__\");\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__isInterface__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__instanceFields__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\ta.remove(\"name\");\n\t\ta.remove(\"length\");\n\t\treturn a;\n\t}\n\t#else\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\t#end\n\n\tpublic static inline function getEnumConstructs(e:Enum<Dynamic>):Array<String> {\n\t\treturn ((cast e).__constructs__ : Array<String>).copy();\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function typeof(v:Dynamic):ValueType {\n\t\tswitch (js.Syntax.typeof(v)) {\n\t\t\tcase \"boolean\":\n\t\t\t\treturn TBool;\n\t\t\tcase \"string\":\n\t\t\t\treturn TClass(String);\n\t\t\tcase \"number\":\n\t\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\t\tif (Math.ceil(v) == v % 2147483648.0)\n\t\t\t\t\treturn TInt;\n\t\t\t\treturn TFloat;\n\t\t\tcase \"object\":\n\t\t\t\tif (v == null)\n\t\t\t\t\treturn TNull;\n\t\t\t\tvar e = v.__enum__;\n\t\t\t\tif (e != null) {\n\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\treturn TEnum(e);\n\t\t\t\t\t#else\n\t\t\t\t\treturn TEnum(untyped $hxEnums[e]);\n\t\t\t\t\t#end\n\t\t\t\t}\n\t\t\t\tvar c = js.Boot.getClass(v);\n\t\t\t\tif (c != null)\n\t\t\t\t\treturn TClass(c);\n\t\t\t\treturn TObject;\n\t\t\tcase \"function\":\n\t\t\t\tif (js.Boot.isClass(v) || js.Boot.isEnum(v))\n\t\t\t\t\treturn TObject;\n\t\t\t\treturn TFunction;\n\t\t\tcase \"undefined\":\n\t\t\t\treturn TNull;\n\t\t\tdefault:\n\t\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T:EnumValue>(a:T, b:T):Bool\n\t\tuntyped {\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\ttry {\n\t\t\t\tvar e = a.__enum__;\n\t\t\t\tif (e == null || e != b.__enum__)\n\t\t\t\t\treturn false;\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\tif (a[0] != b[0])\n\t\t\t\t\treturn false;\n\t\t\t\tfor (i in 2...a.length)\n\t\t\t\t\tif (!enumEq(a[i], b[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t#else\n\t\t\t\tif (a._hx_index != b._hx_index)\n\t\t\t\t\treturn false;\n\t\t\t\tvar enm = $hxEnums[e];\n\t\t\t\tvar ctorName = enm.__constructs__[a._hx_index];\n\t\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\t\tfor (f in params) {\n\t\t\t\t\tif (!enumEq(a[f], b[f])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t} catch (e:Dynamic) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\tpublic inline static function enumConstructor(e:EnumValue):String {\n\t\t#if js_enums_as_arrays\n\t\treturn untyped e[0];\n\t\t#else\n\t\treturn untyped $hxEnums[e.__enum__].__constructs__[e._hx_index];\n\t\t#end\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic inline static function enumParameters(e:EnumValue):Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\t#else\n\tpublic static function enumParameters(e:EnumValue):Array<Dynamic>\n\t\tuntyped {\n\t\t\tvar enm:Enum<Dynamic> = $hxEnums[e.__enum__];\n\t\t\tvar ctorName:String = enm.__constructs__[e._hx_index];\n\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\treturn params != null ? [for (p in params) e[p]] : [];\n\t\t}\n\t#end\n\n\tpublic inline static function enumIndex(e:EnumValue):Int {\n\t\t#if !js_enums_as_arrays\n\t\treturn untyped e._hx_index;\n\t\t#else\n\t\treturn untyped e[1];\n\t\t#end\n\t}\n\n\tpublic inline static function allEnums<T>(e:Enum<T>):Array<T> {\n\t\treturn untyped __define_feature__(\"Type.allEnums\", e.__empty_constructs__.slice());\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar v:Int = Syntax.code('parseInt({0}, ({0}[{1}]==\"x\" || {0}[{1}]==\"X\") ? 16 : 10)', x, i + 1);\n\t\t\t\t\treturn Math.isNaN(v) ? null : v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\t__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = __js__('Date'), __js__('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", __js__('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", __js__('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", __js__('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", __js__('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", __js__('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", __js__('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", __js__('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\t@:pure\n\tpublic inline static function hasField(o:Dynamic, field:String):Bool {\n\t\treturn js.lib.Object.prototype.hasOwnProperty.call(o, field);\n\t}\n\n\t@:pure\n\tpublic static function field(o:Dynamic, field:String):Dynamic {\n\t\ttry\n\t\t\treturn o[cast field]\n\t\tcatch (e:Dynamic)\n\t\t\treturn null;\n\t}\n\n\tpublic inline static function setField(o:Dynamic, field:String, value:Dynamic):Void {\n\t\to[cast field] = value;\n\t}\n\n\tpublic static function getProperty(o:Dynamic, field:String):Dynamic\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\treturn if (o == null) __define_feature__(\"Reflect.getProperty\",\n\t\t\t\tnull) else if (o.__properties__ && (tmp = o.__properties__[\"get_\" + field])) o[tmp]() else o[field];\n\t\t}\n\n\tpublic static function setProperty(o:Dynamic, field:String, value:Dynamic):Void\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\tif (o.__properties__ && (tmp = o.__properties__[\"set_\" + field]))\n\t\t\t\to[tmp](value)\n\t\t\telse\n\t\t\t\to[field] = __define_feature__(\"Reflect.setProperty\", value);\n\t\t}\n\n\tpublic inline static function callMethod(o:Dynamic, func:haxe.Constraints.Function, args:Array<Dynamic>):Dynamic {\n\t\treturn (cast func : js.lib.Function).apply(o, args);\n\t}\n\n\tpublic static function fields(o:Dynamic):Array<String> {\n\t\tvar a = [];\n\t\tif (o != null)\n\t\t\tuntyped {\n\t\t\t\tvar hasOwnProperty = js.lib.Object.prototype.hasOwnProperty;\n\t\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\t\tif (f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f))\n\t\t\t\t\ta.push(f);\n\t\t\t\t__js__(\"}\");\n\t\t\t}\n\t\treturn a;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isFunction(f:Dynamic):Bool {\n\t\treturn js.Syntax.typeof(f) == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>(a:T, b:T):Int {\n\t\treturn (a == b) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods(f1:Dynamic, f2:Dynamic):Bool {\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\t\tif (!isFunction(f1) || !isFunction(f2))\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isObject(v:Dynamic):Bool {\n\t\tif (v == null)\n\t\t\treturn false;\n\t\tvar t = js.Syntax.typeof(v);\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null))\n\t\t\t|| (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue(v:Dynamic):Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField(o:Dynamic, field:String):Bool {\n\t\tif (!hasField(o, field))\n\t\t\treturn false;\n\t\tjs.Syntax.delete(o, field);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>(o:Null<T>):Null<T> {\n\t\tif (o == null)\n\t\t\treturn null;\n\t\tvar o2:Dynamic = {};\n\t\tfor (f in Reflect.fields(o))\n\t\t\tReflect.setField(o2, f, Reflect.field(o, f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function(f:Array<Dynamic>->Void):Dynamic {})\n\tpublic static function makeVarArgs(f:Array<Dynamic>->Dynamic):Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.ds.List;\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with `using Lambda` and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n\n\t@see https://haxe.org/manual/std-Lambda.html\n**/\nclass Lambda {\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>(it:Iterable<A>):Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor (i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>(it:Iterable<A>):List<A> {\n\t\tvar l = new List<A>();\n\t\tfor (i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new Array by applying function `f` to all elements of `it`.\n\t\tThe order of elements is preserved.\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static inline function map<A, B>(it:Iterable<A>, f:(item:A) -> B):Array<B> {\n\t\treturn [for (x in it) f(x)];\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\t\tThe order of elements is preserved.\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static inline function mapi<A, B>(it:Iterable<A>, f:(index:Int, item:A) -> B):Array<B> {\n\t\tvar i = 0;\n\t\treturn [for (x in it) f(i++, x)];\n\t}\n\n\t/**\n\t\tConcatenate a list of iterables.\n\t\tThe order of elements is preserved.\n\t**/\n\tpublic static inline function flatten<A>(it:Iterable<Iterable<A>>):Array<A> {\n\t\treturn [for (e in it) for (x in e) x];\n\t}\n\n\t/**\n\t\tA composition of map and flatten.\n\t\tThe order of elements is preserved.\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static inline function flatMap<A, B>(it:Iterable<A>, f:(item:A) -> Iterable<B>):Array<B> {\n\t\treturn Lambda.flatten(Lambda.map(it, f));\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>(it:Iterable<A>, elt:A):Bool {\n\t\tfor (x in it)\n\t\t\tif (x == elt)\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>(it:Iterable<A>, f:(item:A) -> Bool) {\n\t\tfor (x in it)\n\t\t\tif (f(x))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>(it:Iterable<A>, f:(item:A) -> Bool) {\n\t\tfor (x in it)\n\t\t\tif (!f(x))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>(it:Iterable<A>, f:(item:A) -> Void) {\n\t\tfor (x in it)\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a Array containing those elements of `it` for which `f` returned\n\t\ttrue.\n\t\tIf `it` is empty, the result is the empty Array even if `f` is null.\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>(it:Iterable<A>, f:(item:A) -> Bool) {\n\t\treturn [for (x in it) if (f(x)) x];\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A, B>(it:Iterable<A>, f:(item:A, result:B) -> B, first:B):B {\n\t\tfor (x in it)\n\t\t\tfirst = f(x, first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>(it:Iterable<A>, ?pred:(item:A) -> Bool) {\n\t\tvar n = 0;\n\t\tif (pred == null)\n\t\t\tfor (_ in it)\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor (x in it)\n\t\t\t\tif (pred(x))\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>(it:Iterable<T>):Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>(it:Iterable<T>, v:T):Int {\n\t\tvar i = 0;\n\t\tfor (v2 in it) {\n\t\t\tif (v == v2)\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>(it:Iterable<T>, f:(item:T) -> Bool):Null<T> {\n\t\tfor (v in it) {\n\t\t\tif (f(v))\n\t\t\t\treturn v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new Array containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>(a:Iterable<T>, b:Iterable<T>):Array<T> {\n\t\tvar l = new Array();\n\t\tfor (x in a)\n\t\t\tl.push(x);\n\t\tfor (x in b)\n\t\t\tl.push(x);\n\t\treturn l;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\nimport haxe.rtti.CType;\n\n/**\n\tRtti is a helper class which supplements the `@:rtti` metadata.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>\n**/\nclass Rtti {\n\t/**\n\t\tReturns the `haxe.rtti.CType.Classdef` corresponding to class `c`.\n\n\t\tIf `c` has no runtime type information, e.g. because no `@:rtti` was\n\t\tadded, an exception of type `String` is thrown.\n\n\t\tIf `c` is `null`, the result is unspecified.\n\t**/\n\tstatic public function getRtti<T>(c:Class<T>):Classdef {\n\t\tvar rtti = Reflect.field(c, \"__rtti\");\n\t\tif (rtti == null) {\n\t\t\tthrow 'Class ${Type.getClassName(c)} has no RTTI information, consider adding @:rtti';\n\t\t}\n\t\tvar x = Xml.parse(rtti).firstElement();\n\t\tvar infos = new haxe.rtti.XmlParser().processElement(x);\n\t\tswitch (infos) {\n\t\t\tcase TClassdecl(c):\n\t\t\t\treturn c;\n\t\t\tcase var t:\n\t\t\t\tthrow 'Enum mismatch: expected TClassDecl but found $t';\n\t\t}\n\t}\n\n\t/**\n\t\tTells if `c` has runtime type information.\n\n\t\tIf `c` is `null`, the result is unspecified.\n\t**/\n\tstatic public function hasRtti<T>(c:Class<T>):Bool {\n\t\treturn Lambda.has(Type.getClassFields(c), \"__rtti\");\n\t}\n}\n"]}