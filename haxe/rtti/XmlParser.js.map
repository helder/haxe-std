{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"XmlParser.js.map","sources":["../../../../../../../haxe/versions/4.0.0/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/xml/Access.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/rtti/CType.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/haxe/ds/StringMap.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.0/std/Xml.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/Type.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/rtti/XmlParser.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.xml;\n\nprivate abstract NodeAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Access {\n\t\tvar x = this.elementsNamed(name).next();\n\t\tif (x == null) {\n\t\t\tvar xname = if (this.nodeType == Xml.Document) \"Document\" else this.nodeName;\n\t\t\tthrow xname + \" is missing element \" + name;\n\t\t}\n\t\treturn new Access(x);\n\t}\n}\n\nprivate abstract AttribAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):String {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\tvar v = this.get(name);\n\t\tif (v == null)\n\t\t\tthrow this.nodeName + \" is missing attribute \" + name;\n\t\treturn v;\n\t}\n\n\t@:op(a.b)\n\tfunction _hx_set(name:String, value:String):String {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\tthis.set(name, value);\n\t\treturn value;\n\t}\n}\n\nprivate abstract HasAttribAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Bool {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\treturn this.exists(name);\n\t}\n}\n\nprivate abstract HasNodeAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Bool {\n\t\treturn this.elementsNamed(name).hasNext();\n\t}\n}\n\nprivate abstract NodeListAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Array<Access> {\n\t\tvar l = [];\n\t\tfor (x in this.elementsNamed(name))\n\t\t\tl.push(new Access(x));\n\t\treturn l;\n\t}\n}\n\n/**\n\tThe `haxe.xml.Access` API helps providing a fast dot-syntax access to the\n\tmost common `Xml` methods.\n**/\nabstract Access(Xml) {\n\tpublic var x(get, never):Xml;\n\n\tpublic inline function get_x()\n\t\treturn this;\n\n\t/**\n\t\tThe name of the current element. This is the same as `Xml.nodeName`.\n\t**/\n\tpublic var name(get, never):String;\n\n\tinline function get_name() {\n\t\treturn if (this.nodeType == Xml.Document) \"Document\" else this.nodeName;\n\t}\n\n\t/**\n\t\tThe inner PCDATA or CDATA of the node.\n\n\t\tAn exception is thrown if there is no data or if there not only data\n\t\tbut also other nodes.\n\t**/\n\tpublic var innerData(get, never):String;\n\n\t/**\n\t\tThe XML string built with all the sub nodes, excluding the current one.\n\t**/\n\tpublic var innerHTML(get, never):String;\n\n\t/**\n\t\tAccess to the first sub element with the given name.\n\n\t\tAn exception is thrown if the element doesn't exists.\n\t\tUse `hasNode` to check the existence of a node.\n\n\t\t```haxe\n\t\tvar access = new haxe.xml.Access(Xml.parse(\"<user><name>John</name></user>\"));\n\t\tvar user = access.node.user;\n\t\tvar name = user.node.name;\n\t\ttrace(name.innerData); // John\n\n\t\t// Uncaught Error: Document is missing element password\n\t\tvar password = user.node.password;\n\t\t```\n\t**/\n\tpublic var node(get, never):NodeAccess;\n\n\tinline function get_node():NodeAccess\n\t\treturn x;\n\n\t/**\n\t\tAccess to the List of elements with the given name.\n\t\t```haxe\n\t\tvar fast = new haxe.xml.Access(Xml.parse(\"\n\t\t\t<users>\n\t\t\t\t<user name='John'/>\n\t\t\t\t<user name='Andy'/>\n\t\t\t\t<user name='Dan'/>\n\t\t\t</users>\"\n\t\t));\n\n\t\tvar users = fast.node.users;\n\t\tfor (user in users.nodes.user) {\n\t\t\ttrace(user.att.name);\n\t\t}\n\t\t```\n\t**/\n\tpublic var nodes(get, never):NodeListAccess;\n\n\tinline function get_nodes():NodeListAccess\n\t\treturn this;\n\n\t/**\n\t\tAccess to a given attribute.\n\n\t\tAn exception is thrown if the attribute doesn't exists.\n\t\tUse `has` to check the existence of an attribute.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user name='Mark'></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.has.name) {\n\t\t\ttrace(user.att.name); // Mark\n\t\t}\n\t\t```\n\t**/\n\tpublic var att(get, never):AttribAccess;\n\n\tinline function get_att():AttribAccess\n\t\treturn this;\n\n\t/**\n\t\tCheck the existence of an attribute with the given name.\n\t**/\n\tpublic var has(get, never):HasAttribAccess;\n\n\tinline function get_has():HasAttribAccess\n\t\treturn this;\n\n\t/**\n\t\tCheck the existence of a sub node with the given name.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user><age>31</age></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.hasNode.age) {\n\t\t\ttrace(user.node.age.innerData); // 31\n\t\t}\n\t\t```\n\t**/\n\tpublic var hasNode(get, never):HasNodeAccess;\n\n\tinline function get_hasNode():HasNodeAccess\n\t\treturn x;\n\n\t/**\n\t\tThe list of all sub-elements which are the nodes with type `Xml.Element`.\n\t**/\n\tpublic var elements(get, never):Iterator<Access>;\n\n\tinline function get_elements():Iterator<Access>\n\t\treturn cast this.elements();\n\n\tpublic inline function new(x:Xml) {\n\t\tif (x.nodeType != Xml.Document && x.nodeType != Xml.Element)\n\t\t\tthrow \"Invalid nodeType \" + x.nodeType;\n\t\tthis = x;\n\t}\n\n\tfunction get_innerData() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext())\n\t\t\tthrow name + \" does not have data\";\n\t\tvar v = it.next();\n\t\tif (it.hasNext()) {\n\t\t\tvar n = it.next();\n\t\t\t// handle <spaces>CDATA<spaces>\n\t\t\tif (v.nodeType == Xml.PCData && n.nodeType == Xml.CData && StringTools.trim(v.nodeValue) == \"\") {\n\t\t\t\tif (!it.hasNext())\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t\tvar n2 = it.next();\n\t\t\t\tif (n2.nodeType == Xml.PCData && StringTools.trim(n2.nodeValue) == \"\" && !it.hasNext())\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t}\n\t\t\tthrow name + \" does not only have data\";\n\t\t}\n\t\tif (v.nodeType != Xml.PCData && v.nodeType != Xml.CData)\n\t\t\tthrow name + \" does not have data\";\n\t\treturn v.nodeValue;\n\t}\n\n\tfunction get_innerHTML() {\n\t\tvar s = new StringBuf();\n\t\tfor (x in this)\n\t\t\ts.add(x.toString());\n\t\treturn s.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\nimport haxe.ds.List;\n\n/**\n\tThe (dot-)path of the runtime type.\n**/\ntypedef Path = String;\n\n/**\n\tA list of strings representing the targets where the type is available.\n**/\ntypedef Platforms = Array<String>;\n\n/**\n\tThe function argument runtime type information.\n**/\ntypedef FunctionArgument = {name:String, opt:Bool, t:CType, ?value:String};\n\n/**\n\tThe runtime member types.\n**/\nenum CType {\n\tCUnknown;\n\tCEnum(name:Path, params:Array<CType>);\n\tCClass(name:Path, params:Array<CType>);\n\tCTypedef(name:Path, params:Array<CType>);\n\tCFunction(args:Array<FunctionArgument>, ret:CType);\n\tCAnonymous(fields:Array<ClassField>);\n\tCDynamic(?t:CType);\n\tCAbstract(name:Path, params:Array<CType>);\n}\n\n/**\n\tThe type parameters in the runtime type information.\n**/\ntypedef PathParams = {\n\t/**\n\t\tThe path of the type.\n\t**/\n\tvar path:Path;\n\n\t/**\n\t\tThe array of parameters types.\n\t**/\n\tvar params:Array<CType>;\n};\n\n/**\n\tAn array of strings representing the names of the type parameters the type\n\thas. As of Haxe 3.2.0, this does not include the constraints.\n**/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\n\tRepresents the runtime rights of a type.\n**/\nenum Rights {\n\tRNormal;\n\tRNo;\n\tRCall(m:String);\n\tRMethod;\n\tRDynamic;\n\tRInline;\n}\n\n/**\n\tThe list of runtime metadata.\n**/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\n\tThe runtime class field information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n**/\ntypedef ClassField = {\n\t/**\n\t\tThe name of the field.\n\t**/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the field.\n\t**/\n\tvar type:CType;\n\n\t/**\n\t\tWhether or not the field is public.\n\t**/\n\tvar isPublic:Bool;\n\n\t/**\n\t\tWhether or not the field is final.\n\t**/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the field overrides another field.\n\t**/\n\tvar isOverride:Bool;\n\n\t/**\n\t\tThe documentation of the field. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or\n\t\tif the field has no documentation, the value is `null`.\n\t**/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe [read access](https://haxe.org/manual/dictionary.html#define-read-access)\n\t\tbehavior of the field.\n\t**/\n\tvar get:Rights;\n\n\t/**\n\t\tThe [write access](https://haxe.org/manual/dictionary.html#define-write-access)\n\t\tbehavior of the field.\n\t**/\n\tvar set:Rights;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters\n\t\tthe field has.\n\t**/\n\tvar params:TypeParams;\n\n\t/**\n\t\tA list of strings representing the targets where the field is available.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the field was annotated with.\n\t**/\n\tvar meta:MetaData;\n\n\t/**\n\t\tThe line number where the field is defined. This information is only\n\t\tavailable if the field has an expression.\n\t\tOtherwise the value is `null`.\n\t**/\n\tvar line:Null<Int>;\n\n\t/**\n\t\tThe list of available overloads for the fields or `null` if no overloads\n\t\texists.\n\t**/\n\tvar overloads:Null<Array<ClassField>>;\n\n\t/**\n\t\tThe actual expression of the field or `null` if there is no expression.\n\t**/\n\tvar expr:Null<String>;\n};\n\n/**\n\tThe general runtime type information.\n**/\ntypedef TypeInfos = {\n\t/**\n\t\tThe type path of the type.\n\t**/\n\tvar path:Path;\n\n\t/**\n\t\tThe type path of the module containing the type.\n\t**/\n\tvar module:Path;\n\n\t/**\n\t\tThe full slash path of the .hx file containing the type.\n\t\tThis might be `null` in case there is no such file, e.g. if the\n\t\ttype is defined through a macro.\n\t**/\n\tvar file:Null<String>;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters the\n\t\ttype has.\n\t**/\n\tvar params:TypeParams;\n\n\t/**\n\t\tThe documentation of the type. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n\t**/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tWhether or not the type is [private](https://haxe.org/manual/dictionary.html#define-private-type).\n\t**/\n\tvar isPrivate:Bool;\n\n\t/**\n\t\tA list of strings representing the targets where the type is available.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe [metadata](https://haxe.org/manual/lf-metadata.html) the type was\n\t\tannotated with.\n\t**/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe runtime class definition information.\n**/\ntypedef Classdef = TypeInfos & {\n\t/**\n\t\tWhether or not the class is [extern](https://haxe.org/manual/lf-externs.html).\n\t**/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tWhether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n\t**/\n\tvar isInterface:Bool;\n\n\t/**\n\t\tThe class' parent class defined by its type path and list of type\n\t\tparameters.\n\t**/\n\tvar superClass:Null<PathParams>;\n\n\t/**\n\t\tThe list of interfaces defined by their type path and list of type\n\t\tparameters.\n\t**/\n\tvar interfaces:Array<PathParams>;\n\n\t/**\n\t\tThe list of member [class fields](https://haxe.org/manual/class-field.html).\n\t**/\n\tvar fields:Array<ClassField>;\n\n\t/**\n\t\tThe list of static class fields.\n\t**/\n\tvar statics:Array<ClassField>;\n\n\t/**\n\t\tThe type which is dynamically implemented by the class or `null` if no\n\t\tsuch type exists.\n\t**/\n\tvar tdynamic:Null<CType>;\n};\n\n/**\n\tThe runtime enum constructor information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n**/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the constructor.\n\t**/\n\tvar name:String;\n\n\t/**\n\t\tThe list of arguments the constructor has or `null` if no arguments are\n\t\tavailable.\n\t**/\n\tvar args:Null<Array<{name:String, opt:Bool, t:CType}>>;\n\n\t/**\n\t\tThe documentation of the constructor. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n\t**/\n\tvar doc:String;\n\n\t/**\n\t\tA list of strings representing the targets where the constructor is\n\t\tavailable.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the constructor was annotated with.\n\t**/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe enum runtime type information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n**/\ntypedef Enumdef = TypeInfos & {\n\t/**\n\t\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n\t**/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tThe list of enum constructors.\n\t**/\n\tvar constructors:Array<EnumField>;\n};\n\n/**\n\tThe typedef runtime information.\n**/\ntypedef Typedef = TypeInfos & {\n\t/**\n\t\tThe type of the typedef.\n\t**/\n\tvar type:CType;\n\n\t/**\n\t\tThe types of the typedef, by platform.\n\t**/\n\tvar types:Map<String, CType>; // by platform\n\n};\n\n/**\n\tThe abstract type runtime information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>\n**/\ntypedef Abstractdef = TypeInfos & {\n\tvar to:Array<{t:CType, field:Null<String>}>;\n\tvar from:Array<{t:CType, field:Null<String>}>;\n\tvar impl:Classdef;\n\tvar athis:CType;\n};\n\n/**\n\tThe tree types of the runtime type.\n**/\nenum TypeTree {\n\tTPackage(name:String, full:String, subs:Array<TypeTree>);\n\tTClassdecl(c:Classdef);\n\tTEnumdecl(e:Enumdef);\n\tTTypedecl(t:Typedef);\n\tTAbstractdecl(a:Abstractdef);\n}\n\n/**\n\tArray of `TypeTree`.\n**/\ntypedef TypeRoot = Array<TypeTree>;\n\n/**\n\tContains type and equality checks functionalities for RTTI.\n**/\nclass TypeApi {\n\tpublic static function typeInfos(t:TypeTree):TypeInfos {\n\t\tvar inf:TypeInfos;\n\t\tswitch (t) {\n\t\t\tcase TClassdecl(c):\n\t\t\t\tinf = c;\n\t\t\tcase TEnumdecl(e):\n\t\t\t\tinf = e;\n\t\t\tcase TTypedecl(t):\n\t\t\t\tinf = t;\n\t\t\tcase TAbstractdecl(a):\n\t\t\t\tinf = a;\n\t\t\tcase TPackage(_, _, _):\n\t\t\t\tthrow \"Unexpected Package\";\n\t\t}\n\t\treturn inf;\n\t}\n\n\t/**\n\t\tReturns `true` if the given `CType` is a variable or `false` if it is a\n\t\tfunction.\n\t**/\n\tpublic static function isVar(t:CType) {\n\t\treturn switch (t) {\n\t\t\tcase CFunction(_, _): false;\n\t\t\tdefault: true;\n\t\t}\n\t}\n\n\tstatic function leq<T>(f:T->T->Bool, l1:Array<T>, l2:Array<T>) {\n\t\tvar it = l2.iterator();\n\t\tfor (e1 in l1) {\n\t\t\tif (!it.hasNext())\n\t\t\t\treturn false;\n\t\t\tvar e2 = it.next();\n\t\t\tif (!f(e1, e2))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (it.hasNext())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `r1 == r2`, this function performs a deep equality check on\n\t\tthe given `Rights` instances.\n\n\t\tIf `r1` or `r2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function rightsEq(r1:Rights, r2:Rights) {\n\t\tif (r1 == r2)\n\t\t\treturn true;\n\t\tswitch (r1) {\n\t\t\tcase RCall(m1):\n\t\t\t\tswitch (r2) {\n\t\t\t\t\tcase RCall(m2):\n\t\t\t\t\t\treturn m1 == m2;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tdefault:\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `t1 == t2`, this function performs a deep equality check on\n\t\tthe given `CType` instances.\n\n\t\tIf `t1` or `t2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function typeEq(t1:CType, t2:CType) {\n\t\tswitch (t1) {\n\t\t\tcase CUnknown:\n\t\t\t\treturn t2 == CUnknown;\n\t\t\tcase CEnum(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CEnum(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CClass(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CClass(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAbstract(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAbstract(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CTypedef(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CTypedef(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CFunction(args2, ret2):\n\t\t\t\t\t\treturn leq(function(a:FunctionArgument, b:FunctionArgument) {\n\t\t\t\t\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t\t\t\t\t}, args, args2) && typeEq(ret, ret2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAnonymous(fields2):\n\t\t\t\t\t\treturn leq(function(a, b) return fieldEq(a, b), fields, fields2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CDynamic(t):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CDynamic(t2):\n\t\t\t\t\t\tif ((t == null) != (t2 == null))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\treturn t == null || typeEq(t, t2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `f1 == f2`, this function performs a deep equality check on\n\t\tthe given `ClassField` instances.\n\n\t\tIf `f1` or `f2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function fieldEq(f1:ClassField, f2:ClassField) {\n\t\tif (f1.name != f2.name)\n\t\t\treturn false;\n\t\tif (!typeEq(f1.type, f2.type))\n\t\t\treturn false;\n\t\tif (f1.isPublic != f2.isPublic)\n\t\t\treturn false;\n\t\tif (f1.doc != f2.doc)\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.get, f2.get))\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.set, f2.set))\n\t\t\treturn false;\n\t\tif ((f1.params == null) != (f2.params == null))\n\t\t\treturn false;\n\t\tif (f1.params != null && f1.params.join(\":\") != f2.params.join(\":\"))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `c1 == c2`, this function performs a deep equality check on\n\t\tthe arguments of the enum constructors, if exists.\n\n\t\tIf `c1` or `c2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function constructorEq(c1:EnumField, c2:EnumField) {\n\t\tif (c1.name != c2.name)\n\t\t\treturn false;\n\t\tif (c1.doc != c2.doc)\n\t\t\treturn false;\n\t\tif ((c1.args == null) != (c2.args == null))\n\t\t\treturn false;\n\t\tif (c1.args != null && !leq(function(a, b) {\n\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t}, c1.args, c2.args))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n\n/**\n\tThe CTypeTools class contains some extra functionalities for handling\n\t`CType` instances.\n**/\nclass CTypeTools {\n\t/**\n\t\tGet the string representation of `CType`.\n\t**/\n\tstatic public function toString(t:CType):String {\n\t\treturn switch (t) {\n\t\t\tcase CUnknown:\n\t\t\t\t\"unknown\";\n\t\t\tcase CClass(name, params), CEnum(name, params), CTypedef(name, params), CAbstract(name, params):\n\t\t\t\tnameWithParams(name, params);\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tif (args.length == 0) {\n\t\t\t\t\t\"Void -> \" + toString(ret);\n\t\t\t\t} else {\n\t\t\t\t\targs.map(functionArgumentName).join(\" -> \") + \" -> \" + toString(ret);\n\t\t\t\t}\n\t\t\tcase CDynamic(d):\n\t\t\t\tif (d == null) {\n\t\t\t\t\t\"Dynamic\";\n\t\t\t\t} else {\n\t\t\t\t\t\"Dynamic<\" + toString(d) + \">\";\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\t\"{ \" + fields.map(classField).join(\", \") + \"}\";\n\t\t}\n\t}\n\n\tstatic function nameWithParams(name:String, params:Array<CType>) {\n\t\tif (params.length == 0) {\n\t\t\treturn name;\n\t\t}\n\t\treturn name + \"<\" + params.map(toString).join(\", \") + \">\";\n\t}\n\n\tstatic function functionArgumentName(arg:FunctionArgument) {\n\t\treturn (arg.opt ? \"?\" : \"\")\n\t\t\t+ (arg.name == \"\" ? \"\" : arg.name + \":\")\n\t\t\t+ toString(arg.t)\n\t\t\t+ (arg.value == null ? \"\" : \" = \" + arg.value);\n\t}\n\n\tstatic function classField(cf:ClassField) {\n\t\treturn cf.name + \":\" + toString(cf.type);\n\t}\n}\n","package haxe.ds;\n\n#if !js\nextern class StringMap<T> implements haxe.Constraints.IMap<String, T> {\n  public function new(): Void;\n  public function set(key: String, value: T): Void;\n  public function get(key: String): Null<T>;\n  public function exists(key: String): Bool;\n  public function remove(key: String): Bool;\n  public function keys(): Iterator<String>;\n  public function iterator(): Iterator<T>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): StringMap<T>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass StringMap<T> extends genes.util.EsMap<String, T> implements haxe.Constraints.IMap<String, T> {\n  public inline function copy(): StringMap<T> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tXml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nenum abstract XmlType(Int) {\n\t/**\n\t\tRepresents an XML element type.\n\t**/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n\t**/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n\t**/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n\t**/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n\t**/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n\t**/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n\t**/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nclass Xml {\n\t/**\n\t\tXML element type.\n\t**/\n\tstatic public var Element(default, never) = XmlType.Element;\n\n\t/**\n\t\tXML parsed character data type.\n\t**/\n\tstatic public var PCData(default, never) = XmlType.PCData;\n\n\t/**\n\t\tXML character data type.\n\t**/\n\tstatic public var CData(default, never) = XmlType.CData;\n\n\t/**\n\t\tXML comment type.\n\t**/\n\tstatic public var Comment(default, never) = XmlType.Comment;\n\n\t/**\n\t\tXML doctype element type.\n\t**/\n\tstatic public var DocType(default, never) = XmlType.DocType;\n\n\t/**\n\t\tXML processing instruction type.\n\t**/\n\tstatic public var ProcessingInstruction(default, never) = XmlType.ProcessingInstruction;\n\n\t/**\n\t\tXML document type.\n\t**/\n\tstatic public var Document(default, never) = XmlType.Document;\n\n\t/**\n\t\tParses the String into an Xml document.\n\t**/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n\t**/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n\t**/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n\t**/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n\t**/\n\tpublic var parent(default, null):Xml;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createElement(name:String):Xml {\n\t\tvar xml = new Xml(Element);\n\t\txml.nodeName = name;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createPCData(data:String):Xml {\n\t\tvar xml = new Xml(PCData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createCData(data:String):Xml {\n\t\tvar xml = new Xml(CData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createComment(data:String):Xml {\n\t\tvar xml = new Xml(Comment);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocType(data:String):Xml {\n\t\tvar xml = new Xml(DocType);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createProcessingInstruction(data:String):Xml {\n\t\tvar xml = new Xml(ProcessingInstruction);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocument():Xml {\n\t\treturn new Xml(Document);\n\t}\n\n\t/**\n\t\tGet the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function get(att:String):String {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap[att];\n\t}\n\n\t/**\n\t\tSet the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function set(att:String, value:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.set(att, value);\n\t}\n\n\t/**\n\t\tRemoves an attribute for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function remove(att:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.remove(att);\n\t}\n\n\t/**\n\t\tTells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function exists(att:String):Bool {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.exists(att);\n\t}\n\n\t/**\n\t\tReturns an `Iterator` on all the attribute names.\n\t**/\n\tpublic function attributes():Iterator<String> {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.keys();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elements():Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [for (child in children) if (child.nodeType == Element) child];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elementsNamed(name:String):Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [\n\t\t\tfor (child in children)\n\t\t\t\tif (child.nodeType == Element && child.nodeName == name) child\n\t\t];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns the first child node.\n\t**/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.\n\t**/\n\tpublic function firstElement():Xml {\n\t\tensureElementType();\n\t\tfor (child in children) {\n\t\t\tif (child.nodeType == Element) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tAdds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function addChild(x:Xml):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.removeChild(x);\n\t\t}\n\t\tchildren.push(x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tRemoves a child from the Document or Element.\n\t\tReturns true if the child was successfuly removed.\n\t**/\n\tpublic function removeChild(x:Xml):Bool {\n\t\tensureElementType();\n\t\tif (children.remove(x)) {\n\t\t\tx.parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tInserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function insertChild(x:Xml, pos:Int):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.children.remove(x);\n\t\t}\n\t\tchildren.insert(pos, x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tReturns a String representation of the Xml node.\n\t**/\n\tpublic #if !cppia inline #end function toString():String {\n\t\treturn haxe.xml.Printer.print(this);\n\t}\n\n\tfunction new(nodeType:XmlType) {\n\t\tthis.nodeType = nodeType;\n\t\tchildren = [];\n\t\tattributeMap = new Map();\n\t}\n\n\tinline function ensureElementType() {\n\t\tif (nodeType != Document && nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element or Document but found $nodeType';\n\t\t}\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass(c:Class<Dynamic>);\n\tTEnum(e:Enum<Dynamic>);\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\tpublic static inline function getClass<T>(o:T):Class<T> {\n\t\treturn @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum(o:EnumValue):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn null;\n\t\t\t#if js_enums_as_arrays\n\t\t\treturn o.__enum__;\n\t\t\t#else\n\t\t\treturn $hxEnums[o.__enum__];\n\t\t\t#end\n\t\t}\n\n\tpublic static inline function getSuperClass(c:Class<Dynamic>):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.getSuperClass\", c.__super__);\n\t}\n\n\tpublic static inline function getClassName(c:Class<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getClassName\", c.__name__);\n\t}\n\n\tpublic static inline function getEnumName(e:Enum<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getEnumName\", e.__ename__);\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic static function resolveClass(name:String):Class<Dynamic>\n\t\tuntyped {\n\t\t\tvar cl:Class<Dynamic> = $hxClasses[name];\n\t\t\t// ensure that this is a class\n\t\t\tif (cl == null || !js.Boot.isClass(cl))\n\t\t\t\treturn null;\n\t\t\treturn cl;\n\t\t}\n\n\tpublic static function resolveEnum(name:String):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tvar e:Dynamic = $hxClasses[name];\n\t\t\t// ensure that this is an enum\n\t\t\tif (e == null || !js.Boot.isEnum(e))\n\t\t\t\treturn null;\n\t\t\treturn e;\n\t\t}\n\t#else\n\tpublic static inline function resolveClass(name:String):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveClass\", $hxClasses[name]);\n\t}\n\n\tpublic static inline function resolveEnum(name:String):Enum<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveEnum\", $hxEnums[name]);\n\t}\n\t#end\n\n\t#if (js_es < 5)\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T {\n\t\tswitch (args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn js.Syntax.construct(cl);\n\t\t\tcase 1:\n\t\t\t\treturn js.Syntax.construct(cl, args[0]);\n\t\t\tcase 2:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1]);\n\t\t\tcase 3:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2]);\n\t\t\tcase 4:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3]);\n\t\t\tcase 5:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4]);\n\t\t\tcase 6:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5]);\n\t\t\tcase 7:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t\t\tcase 8:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n\t\t\tcase 9:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n\t\t\tcase 10:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n\t\t\tcase 11:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\n\t\t\tcase 12:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\n\t\t\tcase 13:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12]);\n\t\t\tcase 14:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12], args[13]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t}\n\n\tpublic static function createEmptyInstance<T>(cl:Class<T>):T\n\t\tuntyped {\n\t\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\t\treturn __js__(\"new empty()\");\n\t\t}\n\t#else\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T\n\t\tuntyped {\n\t\t\treturn untyped __js__(\"new ({0})\", Function.prototype.bind.apply(cl, [null].concat(args)));\n\t\t}\n\n\tpublic static inline function createEmptyInstance<T>(cl:Class<T>):T {\n\t\treturn js.lib.Object.create((cast cl).prototype);\n\t}\n\t#end\n\n\tpublic static function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\n\t\tvar f:Dynamic = Reflect.field(e, constr);\n\t\tif (f == null)\n\t\t\tthrow \"No such constructor \" + constr;\n\t\tif (Reflect.isFunction(f)) {\n\t\t\tif (params == null)\n\t\t\t\tthrow \"Constructor \" + constr + \" need parameters\";\n\t\t\treturn Reflect.callMethod(e, f, params);\n\t\t}\n\t\tif (params != null && params.length != 0)\n\t\t\tthrow \"Constructor \" + constr + \" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\n\t\tvar c:String = (untyped e.__constructs__)[index];\n\t\tif (c == null)\n\t\t\tthrow index + \" is not a valid enum constructor index\";\n\t\treturn createEnum(e, c, params);\n\t}\n\n\t#if (js_es >= 6)\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar result = [];\n\t\twhile (c != null) {\n\t\t\tfor (name in js.lib.Object.getOwnPropertyNames((cast c).prototype)) {\n\t\t\t\tswitch name {\n\t\t\t\t\tcase \"constructor\" | \"__class__\" | \"__properties__\":\n\t\t\t\t\t// skip special names\n\t\t\t\t\tcase _:\n\t\t\t\t\t\tif (result.indexOf(name) == -1)\n\t\t\t\t\t\t\tresult.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = getSuperClass(c);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = js.lib.Object.getOwnPropertyNames(cast c);\n\t\ta.remove(\"__id__\");\n\t\ta.remove(\"hx__closures__\");\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__isInterface__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__instanceFields__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\ta.remove(\"name\");\n\t\ta.remove(\"length\");\n\t\treturn a;\n\t}\n\t#else\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\t#end\n\n\tpublic static inline function getEnumConstructs(e:Enum<Dynamic>):Array<String> {\n\t\treturn ((cast e).__constructs__ : Array<String>).copy();\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function typeof(v:Dynamic):ValueType {\n\t\tswitch (js.Syntax.typeof(v)) {\n\t\t\tcase \"boolean\":\n\t\t\t\treturn TBool;\n\t\t\tcase \"string\":\n\t\t\t\treturn TClass(String);\n\t\t\tcase \"number\":\n\t\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\t\tif (Math.ceil(v) == v % 2147483648.0)\n\t\t\t\t\treturn TInt;\n\t\t\t\treturn TFloat;\n\t\t\tcase \"object\":\n\t\t\t\tif (v == null)\n\t\t\t\t\treturn TNull;\n\t\t\t\tvar e = v.__enum__;\n\t\t\t\tif (e != null) {\n\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\treturn TEnum(e);\n\t\t\t\t\t#else\n\t\t\t\t\treturn TEnum(untyped $hxEnums[e]);\n\t\t\t\t\t#end\n\t\t\t\t}\n\t\t\t\tvar c = js.Boot.getClass(v);\n\t\t\t\tif (c != null)\n\t\t\t\t\treturn TClass(c);\n\t\t\t\treturn TObject;\n\t\t\tcase \"function\":\n\t\t\t\tif (js.Boot.isClass(v) || js.Boot.isEnum(v))\n\t\t\t\t\treturn TObject;\n\t\t\t\treturn TFunction;\n\t\t\tcase \"undefined\":\n\t\t\t\treturn TNull;\n\t\t\tdefault:\n\t\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T:EnumValue>(a:T, b:T):Bool\n\t\tuntyped {\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\ttry {\n\t\t\t\tvar e = a.__enum__;\n\t\t\t\tif (e == null || e != b.__enum__)\n\t\t\t\t\treturn false;\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\tif (a[0] != b[0])\n\t\t\t\t\treturn false;\n\t\t\t\tfor (i in 2...a.length)\n\t\t\t\t\tif (!enumEq(a[i], b[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t#else\n\t\t\t\tif (a._hx_index != b._hx_index)\n\t\t\t\t\treturn false;\n\t\t\t\tvar enm = $hxEnums[e];\n\t\t\t\tvar ctorName = enm.__constructs__[a._hx_index];\n\t\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\t\tfor (f in params) {\n\t\t\t\t\tif (!enumEq(a[f], b[f])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t} catch (e:Dynamic) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\tpublic inline static function enumConstructor(e:EnumValue):String {\n\t\t#if js_enums_as_arrays\n\t\treturn untyped e[0];\n\t\t#else\n\t\treturn untyped $hxEnums[e.__enum__].__constructs__[e._hx_index];\n\t\t#end\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic inline static function enumParameters(e:EnumValue):Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\t#else\n\tpublic static function enumParameters(e:EnumValue):Array<Dynamic>\n\t\tuntyped {\n\t\t\tvar enm:Enum<Dynamic> = $hxEnums[e.__enum__];\n\t\t\tvar ctorName:String = enm.__constructs__[e._hx_index];\n\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\treturn params != null ? [for (p in params) e[p]] : [];\n\t\t}\n\t#end\n\n\tpublic inline static function enumIndex(e:EnumValue):Int {\n\t\t#if !js_enums_as_arrays\n\t\treturn untyped e._hx_index;\n\t\t#else\n\t\treturn untyped e[1];\n\t\t#end\n\t}\n\n\tpublic inline static function allEnums<T>(e:Enum<T>):Array<T> {\n\t\treturn untyped __define_feature__(\"Type.allEnums\", e.__empty_constructs__.slice());\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tvar v = untyped __js__('parseInt({0}, {0} && {0}[0]==\"0\" && ({0}[1]==\"x\" || {0}[1]==\"X\") ? 16 : 10)', x);\n\t\tif (untyped __js__(\"isNaN\")(v))\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\t__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = __js__('Date'), __js__('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", __js__('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", __js__('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", __js__('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", __js__('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", __js__('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", __js__('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", __js__('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) __js__(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) __js__(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\nimport haxe.rtti.CType;\nimport haxe.xml.Access;\n\n/**\n\tXmlParser processes the runtime type information (RTTI) which\n\tis stored as a XML string in a static field `__rtti`.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>\n**/\nclass XmlParser {\n\tpublic var root:TypeRoot;\n\n\tvar curplatform:String;\n\n\tpublic function new() {\n\t\troot = new Array();\n\t}\n\n\tpublic function sort(?l:TypeRoot) {\n\t\tif (l == null)\n\t\t\tl = root;\n\t\tl.sort(function(e1, e2) {\n\t\t\tvar n1 = switch e1 {\n\t\t\t\tcase TPackage(p, _, _): \" \" + p;\n\t\t\t\tdefault: TypeApi.typeInfos(e1).path;\n\t\t\t};\n\t\t\tvar n2 = switch e2 {\n\t\t\t\tcase TPackage(p, _, _): \" \" + p;\n\t\t\t\tdefault: TypeApi.typeInfos(e2).path;\n\t\t\t};\n\t\t\tif (n1 > n2)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t});\n\t\tfor (x in l)\n\t\t\tswitch (x) {\n\t\t\t\tcase TPackage(_, _, l):\n\t\t\t\t\tsort(l);\n\t\t\t\tcase TClassdecl(c):\n\t\t\t\t\tsortFields(c.fields);\n\t\t\t\t\tsortFields(c.statics);\n\t\t\t\tcase TEnumdecl(_):\n\t\t\t\tcase TAbstractdecl(_):\n\t\t\t\tcase TTypedecl(_):\n\t\t\t}\n\t}\n\n\tfunction sortFields(a:Array<ClassField>) {\n\t\ta.sort(function(f1:ClassField, f2:ClassField) {\n\t\t\tvar v1 = TypeApi.isVar(f1.type);\n\t\t\tvar v2 = TypeApi.isVar(f2.type);\n\t\t\tif (v1 && !v2)\n\t\t\t\treturn -1;\n\t\t\tif (v2 && !v1)\n\t\t\t\treturn 1;\n\t\t\tif (f1.name == \"new\")\n\t\t\t\treturn -1;\n\t\t\tif (f2.name == \"new\")\n\t\t\t\treturn 1;\n\t\t\tif (f1.name > f2.name)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t});\n\t}\n\n\tpublic function process(x:Xml, platform:String) {\n\t\tcurplatform = platform;\n\t\txroot(new Access(x));\n\t}\n\n\t// merge inline and not inline\n\tfunction mergeRights(f1:ClassField, f2:ClassField) {\n\t\tif (f1.get == RInline && f1.set == RNo && f2.get == RNormal && f2.set == RMethod) {\n\t\t\tf1.get = RNormal;\n\t\t\tf1.set = RMethod;\n\t\t\treturn true;\n\t\t}\n\t\treturn Type.enumEq(f1.get, f2.get) && Type.enumEq(f1.set, f2.set);\n\t}\n\n\tfunction mergeDoc(f1:ClassField, f2:ClassField) {\n\t\tif (f1.doc == null)\n\t\t\tf1.doc = f2.doc;\n\t\telse if (f2.doc == null)\n\t\t\tf2.doc = f1.doc;\n\t\treturn true;\n\t}\n\n\tfunction mergeFields(f:ClassField, f2:ClassField) {\n\t\treturn TypeApi.fieldEq(f, f2)\n\t\t\t|| (f.name == f2.name && (mergeRights(f, f2) || mergeRights(f2, f)) && mergeDoc(f, f2) && TypeApi.fieldEq(f, f2));\n\t}\n\n\tpublic dynamic function newField(c:Classdef, f:ClassField) {}\n\n\tfunction mergeClasses(c:Classdef, c2:Classdef) {\n\t\t// todo : compare supers & interfaces\n\t\tif (c.isInterface != c2.isInterface)\n\t\t\treturn false;\n\t\tif (curplatform != null)\n\t\t\tc.platforms.push(curplatform);\n\t\tif (c.isExtern != c2.isExtern)\n\t\t\tc.isExtern = false;\n\n\t\tfor (f2 in c2.fields) {\n\t\t\tvar found = null;\n\t\t\tfor (f in c.fields)\n\t\t\t\tif (mergeFields(f, f2)) {\n\t\t\t\t\tfound = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null) {\n\t\t\t\tnewField(c, f2);\n\t\t\t\tc.fields.push(f2);\n\t\t\t} else if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\tfor (f2 in c2.statics) {\n\t\t\tvar found = null;\n\t\t\tfor (f in c.statics)\n\t\t\t\tif (mergeFields(f, f2)) {\n\t\t\t\t\tfound = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null) {\n\t\t\t\tnewField(c, f2);\n\t\t\t\tc.statics.push(f2);\n\t\t\t} else if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mergeEnums(e:Enumdef, e2:Enumdef) {\n\t\tif (e.isExtern != e2.isExtern)\n\t\t\treturn false;\n\t\tif (curplatform != null)\n\t\t\te.platforms.push(curplatform);\n\t\tfor (c2 in e2.constructors) {\n\t\t\tvar found = null;\n\t\t\tfor (c in e.constructors)\n\t\t\t\tif (TypeApi.constructorEq(c, c2)) {\n\t\t\t\t\tfound = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null)\n\t\t\t\treturn false; // don't allow by-platform constructor ?\n\t\t\tif (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mergeTypedefs(t:Typedef, t2:Typedef) {\n\t\tif (curplatform == null)\n\t\t\treturn false;\n\t\tt.platforms.push(curplatform);\n\t\tt.types.set(curplatform, t2.type);\n\t\treturn true;\n\t}\n\n\tfunction mergeAbstracts(a:Abstractdef, a2:Abstractdef) {\n\t\tif (curplatform == null)\n\t\t\treturn false;\n\t\tif (a.to.length != a2.to.length || a.from.length != a2.from.length)\n\t\t\treturn false;\n\t\tfor (i in 0...a.to.length)\n\t\t\tif (!TypeApi.typeEq(a.to[i].t, a2.to[i].t))\n\t\t\t\treturn false;\n\t\tfor (i in 0...a.from.length)\n\t\t\tif (!TypeApi.typeEq(a.from[i].t, a2.from[i].t))\n\t\t\t\treturn false;\n\t\tif (a2.impl != null)\n\t\t\tmergeClasses(a.impl, a2.impl);\n\t\ta.platforms.push(curplatform);\n\t\treturn true;\n\t}\n\n\tfunction merge(t:TypeTree) {\n\t\tvar inf = TypeApi.typeInfos(t);\n\t\tvar pack = inf.path.split(\".\");\n\t\tvar cur = root;\n\t\tvar curpack = new Array();\n\t\tpack.pop();\n\t\tfor (p in pack) {\n\t\t\tvar found = false;\n\t\t\tfor (pk in cur)\n\t\t\t\tswitch (pk) {\n\t\t\t\t\tcase TPackage(pname, _, subs):\n\t\t\t\t\t\tif (pname == p) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tcur = subs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcurpack.push(p);\n\t\t\tif (!found) {\n\t\t\t\tvar pk = new Array();\n\t\t\t\tcur.push(TPackage(p, curpack.join(\".\"), pk));\n\t\t\t\tcur = pk;\n\t\t\t}\n\t\t}\n\t\tfor (ct in cur) {\n\t\t\tif (ct.match(TPackage(_)))\n\t\t\t\tcontinue;\n\t\t\tvar tinf = TypeApi.typeInfos(ct);\n\n\t\t\t// compare params ?\n\t\t\tif (tinf.path == inf.path) {\n\t\t\t\tvar sameType = true;\n\t\t\t\tif ((tinf.doc == null) != (inf.doc == null)) {\n\t\t\t\t\tif (inf.doc == null)\n\t\t\t\t\t\tinf.doc = tinf.doc;\n\t\t\t\t\telse\n\t\t\t\t\t\ttinf.doc = inf.doc;\n\t\t\t\t}\n\t\t\t\tif (tinf.path == \"haxe._Int64.NativeInt64\")\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tinf.module == inf.module && tinf.doc == inf.doc && tinf.isPrivate == inf.isPrivate)\n\t\t\t\t\tswitch (ct) {\n\t\t\t\t\t\tcase TClassdecl(c):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TClassdecl(c2):\n\t\t\t\t\t\t\t\t\tif (mergeClasses(c, c2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TEnumdecl(e):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TEnumdecl(e2):\n\t\t\t\t\t\t\t\t\tif (mergeEnums(e, e2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TTypedecl(td):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TTypedecl(td2):\n\t\t\t\t\t\t\t\t\tif (mergeTypedefs(td, td2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TAbstractdecl(a):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TAbstractdecl(a2):\n\t\t\t\t\t\t\t\t\tif (mergeAbstracts(a, a2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TPackage(_, _, _):\n\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t}\n\t\t\t\t// we already have a mapping, but which is incompatible\n\t\t\t\tvar msg = if (tinf.module != inf.module) \"module \" + inf.module + \" should be \" + tinf.module; else if (tinf.doc != inf.doc)\n\t\t\t\t\t\"documentation is different\";\n\t\t\t\telse if (tinf.isPrivate != inf.isPrivate)\n\t\t\t\t\t\"private flag is different\";\n\t\t\t\telse if (!sameType)\n\t\t\t\t\t\"type kind is different\";\n\t\t\t\telse\n\t\t\t\t\t\"could not merge definition\";\n\t\t\t\tthrow \"Incompatibilities between \" + tinf.path + \" in \" + tinf.platforms.join(\",\") + \" and \" + curplatform + \" (\" + msg + \")\";\n\t\t\t}\n\t\t}\n\t\tcur.push(t);\n\t}\n\n\tfunction mkPath(p:String):Path {\n\t\treturn p;\n\t}\n\n\tfunction mkTypeParams(p:String):TypeParams {\n\t\tvar pl = p.split(\":\");\n\t\tif (pl[0] == \"\")\n\t\t\treturn new Array();\n\t\treturn pl;\n\t}\n\n\tfunction mkRights(r:String):Rights {\n\t\treturn switch (r) {\n\t\t\tcase \"null\": RNo;\n\t\t\tcase \"method\": RMethod;\n\t\t\tcase \"dynamic\": RDynamic;\n\t\t\tcase \"inline\": RInline;\n\t\t\tdefault: RCall(r);\n\t\t}\n\t}\n\n\tfunction xerror(c:Access):Dynamic {\n\t\treturn throw \"Invalid \" + c.name;\n\t}\n\n\tfunction xroot(x:Access) {\n\t\tfor (c in x.x.elements())\n\t\t\tmerge(processElement(c));\n\t}\n\n\tpublic function processElement(x:Xml) {\n\t\tvar c = new haxe.xml.Access(x);\n\t\treturn switch (c.name) {\n\t\t\tcase \"class\": TClassdecl(xclass(c));\n\t\t\tcase \"enum\": TEnumdecl(xenum(c));\n\t\t\tcase \"typedef\": TTypedecl(xtypedef(c));\n\t\t\tcase \"abstract\": TAbstractdecl(xabstract(c));\n\t\t\tdefault: xerror(c);\n\t\t}\n\t}\n\n\tfunction xmeta(x:Access):MetaData {\n\t\tvar ml = [];\n\t\tfor (m in x.nodes.m) {\n\t\t\tvar pl = [];\n\t\t\tfor (p in m.nodes.e)\n\t\t\t\tpl.push(p.innerHTML);\n\t\t\tml.push({name: m.att.n, params: pl});\n\t\t}\n\t\treturn ml;\n\t}\n\n\tfunction xoverloads(x:Access):Array<ClassField> {\n\t\tvar l = new Array();\n\t\tfor (m in x.elements) {\n\t\t\tl.push(xclassfield(m));\n\t\t}\n\t\treturn l;\n\t}\n\n\tfunction xpath(x:Access):PathParams {\n\t\tvar path = mkPath(x.att.path);\n\t\tvar params = new Array();\n\t\tfor (c in x.elements)\n\t\t\tparams.push(xtype(c));\n\t\treturn {\n\t\t\tpath: path,\n\t\t\tparams: params,\n\t\t};\n\t}\n\n\tfunction xclass(x:Access):Classdef {\n\t\tvar csuper = null;\n\t\tvar doc = null;\n\t\tvar tdynamic = null;\n\t\tvar interfaces = new Array();\n\t\tvar fields = new Array();\n\t\tvar statics = new Array();\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"extends\":\n\t\t\t\t\tcsuper = xpath(c);\n\t\t\t\tcase \"implements\":\n\t\t\t\t\tinterfaces.push(xpath(c));\n\t\t\t\tcase \"haxe_dynamic\":\n\t\t\t\t\ttdynamic = xtype(new Access(c.x.firstElement()));\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tdefault:\n\t\t\t\t\tif (c.x.exists(\"static\"))\n\t\t\t\t\t\tstatics.push(xclassfield(c));\n\t\t\t\t\telse\n\t\t\t\t\t\tfields.push(xclassfield(c));\n\t\t\t}\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tisExtern: x.x.exists(\"extern\"),\n\t\t\tisInterface: x.x.exists(\"interface\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tsuperClass: csuper,\n\t\t\tinterfaces: interfaces,\n\t\t\tfields: fields,\n\t\t\tstatics: statics,\n\t\t\ttdynamic: tdynamic,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xclassfield(x:Access, ?defPublic = false):ClassField {\n\t\tvar e = x.elements;\n\t\tvar t = xtype(e.next());\n\t\tvar doc = null;\n\t\tvar meta = [];\n\t\tvar overloads = null;\n\t\tfor (c in e)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tcase \"overloads\":\n\t\t\t\t\toverloads = xoverloads(c);\n\t\t\t\tdefault:\n\t\t\t\t\txerror(c);\n\t\t\t}\n\t\treturn {\n\t\t\tname:x.name, type:t, isPublic:x.x.exists(\"public\") || defPublic, isFinal:x.x.exists(\"final\"), isOverride:x.x.exists(\"override\"),\n\t\t\tline:if (x.has.line) Std.parseInt(x.att.line) else null, doc:doc, get:if (x.has.get) mkRights(x.att.get) else RNormal, set:if (x.has.set)\n\t\t\t\tmkRights(x.att.set)\n\t\t\telse\n\t\t\t\tRNormal, params:if (x.has.params) mkTypeParams(x.att.params) else [], platforms:defplat(), meta:meta, overloads:overloads, expr:if (x.has.expr)\n\t\t\t\tx.att.expr\n\t\t\telse\n\t\t\t\tnull\n\t\t};\n\t}\n\n\tfunction xenum(x:Access):Enumdef {\n\t\tvar cl = new Array();\n\t\tvar doc = null;\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tif (c.name == \"haxe_doc\")\n\t\t\t\tdoc = c.innerData;\n\t\t\telse if (c.name == \"meta\")\n\t\t\t\tmeta = xmeta(c);\n\t\t\telse\n\t\t\t\tcl.push(xenumfield(c));\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tisExtern: x.x.exists(\"extern\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tconstructors: cl,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xenumfield(x:Access):EnumField {\n\t\tvar args = null;\n\t\tvar docElements = x.x.elementsNamed(\"haxe_doc\");\n\t\tvar xdoc = if (docElements.hasNext()) docElements.next() else null;\n\t\tvar meta = if (x.hasNode.meta) xmeta(x.node.meta) else [];\n\t\tif (x.has.a) {\n\t\t\tvar names = x.att.a.split(\":\");\n\t\t\tvar elts = x.elements;\n\t\t\targs = new Array();\n\t\t\tfor (c in names) {\n\t\t\t\tvar opt = false;\n\t\t\t\tif (c.charAt(0) == \"?\") {\n\t\t\t\t\topt = true;\n\t\t\t\t\tc = c.substr(1);\n\t\t\t\t}\n\t\t\t\targs.push({\n\t\t\t\t\tname: c,\n\t\t\t\t\topt: opt,\n\t\t\t\t\tt: xtype(elts.next()),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: x.name,\n\t\t\targs: args,\n\t\t\tdoc: if (xdoc == null) null else new Access(xdoc).innerData,\n\t\t\tmeta: meta,\n\t\t\tplatforms: defplat(),\n\t\t};\n\t}\n\n\tfunction xabstract(x:Access):Abstractdef {\n\t\tvar doc = null, impl = null, athis = null;\n\t\tvar meta = [], to = [], from = [];\n\t\tfor (c in x.elements)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tcase \"to\":\n\t\t\t\t\tfor (t in c.elements)\n\t\t\t\t\t\tto.push({t: xtype(new Access(t.x.firstElement())), field: t.has.field ? t.att.field : null});\n\t\t\t\tcase \"from\":\n\t\t\t\t\tfor (t in c.elements)\n\t\t\t\t\t\tfrom.push({t: xtype(new Access(t.x.firstElement())), field: t.has.field ? t.att.field : null});\n\t\t\t\tcase \"impl\":\n\t\t\t\t\timpl = xclass(c.node.resolve(\"class\"));\n\t\t\t\tcase \"this\":\n\t\t\t\t\tathis = xtype(new Access(c.x.firstElement()));\n\t\t\t\tdefault:\n\t\t\t\t\txerror(c);\n\t\t\t}\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t\tathis: athis,\n\t\t\tto: to,\n\t\t\tfrom: from,\n\t\t\timpl: impl\n\t\t};\n\t}\n\n\tfunction xtypedef(x:Access):Typedef {\n\t\tvar doc = null;\n\t\tvar t = null;\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tif (c.name == \"haxe_doc\")\n\t\t\t\tdoc = c.innerData;\n\t\t\telse if (c.name == \"meta\")\n\t\t\t\tmeta = xmeta(c);\n\t\t\telse\n\t\t\t\tt = xtype(c);\n\t\tvar types = new haxe.ds.StringMap();\n\t\tif (curplatform != null)\n\t\t\ttypes.set(curplatform, t);\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\ttype: t,\n\t\t\ttypes: types,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xtype(x:Access):CType {\n\t\treturn switch (x.name) {\n\t\t\tcase \"unknown\":\n\t\t\t\tCUnknown;\n\t\t\tcase \"e\":\n\t\t\t\tCEnum(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"c\":\n\t\t\t\tCClass(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"t\":\n\t\t\t\tCTypedef(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"x\":\n\t\t\t\tCAbstract(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"f\":\n\t\t\t\tvar args = new Array();\n\t\t\t\tvar aname = x.att.a.split(\":\");\n\t\t\t\tvar eargs = aname.iterator();\n\t\t\t\tvar evalues = x.has.v ? x.att.v.split(\":\").iterator() : null;\n\t\t\t\tfor (e in x.elements) {\n\t\t\t\t\tvar opt = false;\n\t\t\t\t\tvar a = eargs.hasNext() ? eargs.next() : null;\n\t\t\t\t\tif (a == null)\n\t\t\t\t\t\ta = \"\";\n\t\t\t\t\tif (a.charAt(0) == \"?\") {\n\t\t\t\t\t\topt = true;\n\t\t\t\t\t\ta = a.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\tvar v = evalues == null || !evalues.hasNext() ? null : evalues.next();\n\t\t\t\t\targs.push({\n\t\t\t\t\t\tname: a,\n\t\t\t\t\t\topt: opt,\n\t\t\t\t\t\tt: xtype(e),\n\t\t\t\t\t\tvalue: v == \"\" ? null : v\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tvar ret = args[args.length - 1];\n\t\t\t\targs.remove(ret);\n\t\t\t\tCFunction(args, ret.t);\n\t\t\tcase \"a\":\n\t\t\t\tvar fields = new Array();\n\t\t\t\tfor (f in x.elements) {\n\t\t\t\t\tvar f = xclassfield(f, true);\n\t\t\t\t\tf.platforms = new Array(); // platforms selection are on the type itself, not on fields\n\t\t\t\t\tfields.push(f);\n\t\t\t\t}\n\t\t\t\tCAnonymous(fields);\n\t\t\tcase \"d\":\n\t\t\t\tvar t = null;\n\t\t\t\tvar tx = x.x.firstElement();\n\t\t\t\tif (tx != null)\n\t\t\t\t\tt = xtype(new Access(tx));\n\t\t\t\tCDynamic(t);\n\t\t\tdefault:\n\t\t\t\txerror(x);\n\t\t}\n\t}\n\n\tfunction xtypeparams(x:Access):Array<CType> {\n\t\tvar p = new Array();\n\t\tfor (c in x.elements)\n\t\t\tp.push(xtype(c));\n\t\treturn p;\n\t}\n\n\tfunction defplat() {\n\t\tvar l = new Array();\n\t\tif (curplatform != null)\n\t\t\tl.push(curplatform);\n\t\treturn l;\n\t}\n}\n"]}