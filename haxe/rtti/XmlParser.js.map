{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"XmlParser.js.map","sources":["../../../../../../../haxe/versions/4.1.4/std/haxe/xml/Access.hx","../../../../../../../haxe/versions/4.1.4/std/haxe/rtti/CType.hx","../../../../../../../haxe/versions/4.1.4/std/haxe/iterators/ArrayIterator.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/haxe/ds/StringMap.hx","../../../../../../../haxe/versions/4.1.4/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.1.4/std/Xml.hx","../../../../../../../haxe/versions/4.1.4/std/js/_std/Type.hx","../../../../../../../haxe/versions/4.1.4/std/js/_std/Std.hx","../../../../../../../haxe/versions/4.1.4/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.1.4/std/haxe/rtti/XmlParser.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.xml;\n\nprivate abstract NodeAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Access {\n\t\tvar x = this.elementsNamed(name).next();\n\t\tif (x == null) {\n\t\t\tvar xname = if (this.nodeType == Xml.Document) \"Document\" else this.nodeName;\n\t\t\tthrow xname + \" is missing element \" + name;\n\t\t}\n\t\treturn new Access(x);\n\t}\n}\n\nprivate abstract AttribAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):String {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\tvar v = this.get(name);\n\t\tif (v == null)\n\t\t\tthrow this.nodeName + \" is missing attribute \" + name;\n\t\treturn v;\n\t}\n\n\t@:op(a.b)\n\tfunction _hx_set(name:String, value:String):String {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\tthis.set(name, value);\n\t\treturn value;\n\t}\n}\n\nprivate abstract HasAttribAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Bool {\n\t\tif (this.nodeType == Xml.Document)\n\t\t\tthrow \"Cannot access document attribute \" + name;\n\t\treturn this.exists(name);\n\t}\n}\n\nprivate abstract HasNodeAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Bool {\n\t\treturn this.elementsNamed(name).hasNext();\n\t}\n}\n\nprivate abstract NodeListAccess(Xml) from Xml {\n\t@:op(a.b)\n\tpublic function resolve(name:String):Array<Access> {\n\t\tvar l = [];\n\t\tfor (x in this.elementsNamed(name))\n\t\t\tl.push(new Access(x));\n\t\treturn l;\n\t}\n}\n\n/**\n\tThe `haxe.xml.Access` API helps providing a fast dot-syntax access to the\n\tmost common `Xml` methods.\n**/\nabstract Access(Xml) {\n\tpublic var x(get, never):Xml;\n\n\tpublic inline function get_x()\n\t\treturn this;\n\n\t/**\n\t\tThe name of the current element. This is the same as `Xml.nodeName`.\n\t**/\n\tpublic var name(get, never):String;\n\n\tinline function get_name() {\n\t\treturn if (this.nodeType == Xml.Document) \"Document\" else this.nodeName;\n\t}\n\n\t/**\n\t\tThe inner PCDATA or CDATA of the node.\n\n\t\tAn exception is thrown if there is no data or if there not only data\n\t\tbut also other nodes.\n\t**/\n\tpublic var innerData(get, never):String;\n\n\t/**\n\t\tThe XML string built with all the sub nodes, excluding the current one.\n\t**/\n\tpublic var innerHTML(get, never):String;\n\n\t/**\n\t\tAccess to the first sub element with the given name.\n\n\t\tAn exception is thrown if the element doesn't exists.\n\t\tUse `hasNode` to check the existence of a node.\n\n\t\t```haxe\n\t\tvar access = new haxe.xml.Access(Xml.parse(\"<user><name>John</name></user>\"));\n\t\tvar user = access.node.user;\n\t\tvar name = user.node.name;\n\t\ttrace(name.innerData); // John\n\n\t\t// Uncaught Error: Document is missing element password\n\t\tvar password = user.node.password;\n\t\t```\n\t**/\n\tpublic var node(get, never):NodeAccess;\n\n\tinline function get_node():NodeAccess\n\t\treturn x;\n\n\t/**\n\t\tAccess to the List of elements with the given name.\n\t\t```haxe\n\t\tvar fast = new haxe.xml.Access(Xml.parse(\"\n\t\t\t<users>\n\t\t\t\t<user name='John'/>\n\t\t\t\t<user name='Andy'/>\n\t\t\t\t<user name='Dan'/>\n\t\t\t</users>\"\n\t\t));\n\n\t\tvar users = fast.node.users;\n\t\tfor (user in users.nodes.user) {\n\t\t\ttrace(user.att.name);\n\t\t}\n\t\t```\n\t**/\n\tpublic var nodes(get, never):NodeListAccess;\n\n\tinline function get_nodes():NodeListAccess\n\t\treturn this;\n\n\t/**\n\t\tAccess to a given attribute.\n\n\t\tAn exception is thrown if the attribute doesn't exists.\n\t\tUse `has` to check the existence of an attribute.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user name='Mark'></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.has.name) {\n\t\t\ttrace(user.att.name); // Mark\n\t\t}\n\t\t```\n\t**/\n\tpublic var att(get, never):AttribAccess;\n\n\tinline function get_att():AttribAccess\n\t\treturn this;\n\n\t/**\n\t\tCheck the existence of an attribute with the given name.\n\t**/\n\tpublic var has(get, never):HasAttribAccess;\n\n\tinline function get_has():HasAttribAccess\n\t\treturn this;\n\n\t/**\n\t\tCheck the existence of a sub node with the given name.\n\n\t\t```haxe\n\t\tvar f = new haxe.xml.Access(Xml.parse(\"<user><age>31</age></user>\"));\n\t\tvar user = f.node.user;\n\t\tif (user.hasNode.age) {\n\t\t\ttrace(user.node.age.innerData); // 31\n\t\t}\n\t\t```\n\t**/\n\tpublic var hasNode(get, never):HasNodeAccess;\n\n\tinline function get_hasNode():HasNodeAccess\n\t\treturn x;\n\n\t/**\n\t\tThe list of all sub-elements which are the nodes with type `Xml.Element`.\n\t**/\n\tpublic var elements(get, never):Iterator<Access>;\n\n\tinline function get_elements():Iterator<Access>\n\t\treturn cast this.elements();\n\n\tpublic inline function new(x:Xml) {\n\t\tif (x.nodeType != Xml.Document && x.nodeType != Xml.Element)\n\t\t\tthrow \"Invalid nodeType \" + x.nodeType;\n\t\tthis = x;\n\t}\n\n\tfunction get_innerData() {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext())\n\t\t\tthrow name + \" does not have data\";\n\t\tvar v = it.next();\n\t\tif (it.hasNext()) {\n\t\t\tvar n = it.next();\n\t\t\t// handle <spaces>CDATA<spaces>\n\t\t\tif (v.nodeType == Xml.PCData && n.nodeType == Xml.CData && StringTools.trim(v.nodeValue) == \"\") {\n\t\t\t\tif (!it.hasNext())\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t\tvar n2 = it.next();\n\t\t\t\tif (n2.nodeType == Xml.PCData && StringTools.trim(n2.nodeValue) == \"\" && !it.hasNext())\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t}\n\t\t\tthrow name + \" does not only have data\";\n\t\t}\n\t\tif (v.nodeType != Xml.PCData && v.nodeType != Xml.CData)\n\t\t\tthrow name + \" does not have data\";\n\t\treturn v.nodeValue;\n\t}\n\n\tfunction get_innerHTML() {\n\t\tvar s = new StringBuf();\n\t\tfor (x in this)\n\t\t\ts.add(x.toString());\n\t\treturn s.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\n/**\n\tThe (dot-)path of the runtime type.\n**/\ntypedef Path = String;\n\n/**\n\tA list of strings representing the targets where the type is available.\n**/\ntypedef Platforms = Array<String>;\n\n/**\n\tThe function argument runtime type information.\n**/\ntypedef FunctionArgument = {name:String, opt:Bool, t:CType, ?value:String};\n\n/**\n\tThe runtime member types.\n**/\nenum CType {\n\tCUnknown;\n\tCEnum(name:Path, params:Array<CType>);\n\tCClass(name:Path, params:Array<CType>);\n\tCTypedef(name:Path, params:Array<CType>);\n\tCFunction(args:Array<FunctionArgument>, ret:CType);\n\tCAnonymous(fields:Array<ClassField>);\n\tCDynamic(?t:CType);\n\tCAbstract(name:Path, params:Array<CType>);\n}\n\n/**\n\tThe type parameters in the runtime type information.\n**/\ntypedef PathParams = {\n\t/**\n\t\tThe path of the type.\n\t**/\n\tvar path:Path;\n\n\t/**\n\t\tThe array of parameters types.\n\t**/\n\tvar params:Array<CType>;\n};\n\n/**\n\tAn array of strings representing the names of the type parameters the type\n\thas. As of Haxe 3.2.0, this does not include the constraints.\n**/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\n\tRepresents the runtime rights of a type.\n**/\nenum Rights {\n\tRNormal;\n\tRNo;\n\tRCall(m:String);\n\tRMethod;\n\tRDynamic;\n\tRInline;\n}\n\n/**\n\tThe list of runtime metadata.\n**/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\n\tThe runtime class field information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n**/\ntypedef ClassField = {\n\t/**\n\t\tThe name of the field.\n\t**/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the field.\n\t**/\n\tvar type:CType;\n\n\t/**\n\t\tWhether or not the field is `public`.\n\t**/\n\tvar isPublic:Bool;\n\n\t/**\n\t\tWhether or not the field is `final`.\n\t**/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the field overrides another field.\n\t**/\n\tvar isOverride:Bool;\n\n\t/**\n\t\tThe documentation of the field. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or\n\t\tif the field has no documentation, the value is `null`.\n\t**/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\n\t\tbehavior of the field.\n\t**/\n\tvar get:Rights;\n\n\t/**\n\t\tThe [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\n\t\tbehavior of the field.\n\t**/\n\tvar set:Rights;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters\n\t\tthe field has.\n\t**/\n\tvar params:TypeParams;\n\n\t/**\n\t\tA list of strings representing the targets where the field is available.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the field was annotated with.\n\t**/\n\tvar meta:MetaData;\n\n\t/**\n\t\tThe line number where the field is defined. This information is only\n\t\tavailable if the field has an expression.\n\t\tOtherwise the value is `null`.\n\t**/\n\tvar line:Null<Int>;\n\n\t/**\n\t\tThe list of available overloads for the fields or `null` if no overloads\n\t\texists.\n\t**/\n\tvar overloads:Null<Array<ClassField>>;\n\n\t/**\n\t\tThe actual expression of the field or `null` if there is no expression.\n\t**/\n\tvar expr:Null<String>;\n};\n\n/**\n\tThe general runtime type information.\n**/\ntypedef TypeInfos = {\n\t/**\n\t\tThe type path of the type.\n\t**/\n\tvar path:Path;\n\n\t/**\n\t\tThe type path of the module containing the type.\n\t**/\n\tvar module:Path;\n\n\t/**\n\t\tThe full slash path of the .hx file containing the type.\n\t\tThis might be `null` in case there is no such file, e.g. if the\n\t\ttype is defined through a macro.\n\t**/\n\tvar file:Null<String>;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters the\n\t\ttype has.\n\t**/\n\tvar params:TypeParams;\n\n\t/**\n\t\tThe documentation of the type. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n\t**/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tWhether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).\n\t**/\n\tvar isPrivate:Bool;\n\n\t/**\n\t\tA list of strings representing the targets where the type is available.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe [metadata](https://haxe.org/manual/lf-metadata.html) the type was\n\t\tannotated with.\n\t**/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe runtime class definition information.\n**/\ntypedef Classdef = TypeInfos & {\n\t/**\n\t\tWhether or not the class is [extern](https://haxe.org/manual/lf-externs.html).\n\t**/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tWhether or not the class is `final`.\n\t**/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n\t**/\n\tvar isInterface:Bool;\n\n\t/**\n\t\tThe class' parent class defined by its type path and list of type\n\t\tparameters.\n\t**/\n\tvar superClass:Null<PathParams>;\n\n\t/**\n\t\tThe list of interfaces defined by their type path and list of type\n\t\tparameters.\n\t**/\n\tvar interfaces:Array<PathParams>;\n\n\t/**\n\t\tThe list of member [class fields](https://haxe.org/manual/class-field.html).\n\t**/\n\tvar fields:Array<ClassField>;\n\n\t/**\n\t\tThe list of static class fields.\n\t**/\n\tvar statics:Array<ClassField>;\n\n\t/**\n\t\tThe type which is dynamically implemented by the class or `null` if no\n\t\tsuch type exists.\n\t**/\n\tvar tdynamic:Null<CType>;\n};\n\n/**\n\tThe runtime enum constructor information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n**/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the constructor.\n\t**/\n\tvar name:String;\n\n\t/**\n\t\tThe list of arguments the constructor has or `null` if no arguments are\n\t\tavailable.\n\t**/\n\tvar args:Null<Array<{name:String, opt:Bool, t:CType}>>;\n\n\t/**\n\t\tThe documentation of the constructor. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n\t**/\n\tvar doc:String;\n\n\t/**\n\t\tA list of strings representing the targets where the constructor is\n\t\tavailable.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the constructor was annotated with.\n\t**/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe enum runtime type information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n**/\ntypedef Enumdef = TypeInfos & {\n\t/**\n\t\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n\t**/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tThe list of enum constructors.\n\t**/\n\tvar constructors:Array<EnumField>;\n};\n\n/**\n\tThe typedef runtime information.\n**/\ntypedef Typedef = TypeInfos & {\n\t/**\n\t\tThe type of the typedef.\n\t**/\n\tvar type:CType;\n\n\t/**\n\t\tThe types of the typedef, by platform.\n\t**/\n\tvar types:Map<String, CType>; // by platform\n\n};\n\n/**\n\tThe abstract type runtime information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>\n**/\ntypedef Abstractdef = TypeInfos & {\n\tvar to:Array<{t:CType, field:Null<String>}>;\n\tvar from:Array<{t:CType, field:Null<String>}>;\n\tvar impl:Classdef;\n\tvar athis:CType;\n};\n\n/**\n\tThe tree types of the runtime type.\n**/\nenum TypeTree {\n\tTPackage(name:String, full:String, subs:Array<TypeTree>);\n\tTClassdecl(c:Classdef);\n\tTEnumdecl(e:Enumdef);\n\tTTypedecl(t:Typedef);\n\tTAbstractdecl(a:Abstractdef);\n}\n\n/**\n\tArray of `TypeTree`.\n**/\ntypedef TypeRoot = Array<TypeTree>;\n\n/**\n\tContains type and equality checks functionalities for RTTI.\n**/\nclass TypeApi {\n\tpublic static function typeInfos(t:TypeTree):TypeInfos {\n\t\tvar inf:TypeInfos;\n\t\tswitch (t) {\n\t\t\tcase TClassdecl(c):\n\t\t\t\tinf = c;\n\t\t\tcase TEnumdecl(e):\n\t\t\t\tinf = e;\n\t\t\tcase TTypedecl(t):\n\t\t\t\tinf = t;\n\t\t\tcase TAbstractdecl(a):\n\t\t\t\tinf = a;\n\t\t\tcase TPackage(_, _, _):\n\t\t\t\tthrow \"Unexpected Package\";\n\t\t}\n\t\treturn inf;\n\t}\n\n\t/**\n\t\tReturns `true` if the given `CType` is a variable or `false` if it is a\n\t\tfunction.\n\t**/\n\tpublic static function isVar(t:CType) {\n\t\treturn switch (t) {\n\t\t\tcase CFunction(_, _): false;\n\t\t\tdefault: true;\n\t\t}\n\t}\n\n\tstatic function leq<T>(f:T->T->Bool, l1:Array<T>, l2:Array<T>) {\n\t\tvar it = l2.iterator();\n\t\tfor (e1 in l1) {\n\t\t\tif (!it.hasNext())\n\t\t\t\treturn false;\n\t\t\tvar e2 = it.next();\n\t\t\tif (!f(e1, e2))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (it.hasNext())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `r1 == r2`, this function performs a deep equality check on\n\t\tthe given `Rights` instances.\n\n\t\tIf `r1` or `r2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function rightsEq(r1:Rights, r2:Rights) {\n\t\tif (r1 == r2)\n\t\t\treturn true;\n\t\tswitch (r1) {\n\t\t\tcase RCall(m1):\n\t\t\t\tswitch (r2) {\n\t\t\t\t\tcase RCall(m2):\n\t\t\t\t\t\treturn m1 == m2;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tdefault:\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `t1 == t2`, this function performs a deep equality check on\n\t\tthe given `CType` instances.\n\n\t\tIf `t1` or `t2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function typeEq(t1:CType, t2:CType) {\n\t\tswitch (t1) {\n\t\t\tcase CUnknown:\n\t\t\t\treturn t2 == CUnknown;\n\t\t\tcase CEnum(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CEnum(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CClass(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CClass(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAbstract(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAbstract(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CTypedef(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CTypedef(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CFunction(args2, ret2):\n\t\t\t\t\t\treturn leq(function(a:FunctionArgument, b:FunctionArgument) {\n\t\t\t\t\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t\t\t\t\t}, args, args2) && typeEq(ret, ret2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAnonymous(fields2):\n\t\t\t\t\t\treturn leq(function(a, b) return fieldEq(a, b), fields, fields2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CDynamic(t):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CDynamic(t2):\n\t\t\t\t\t\tif ((t == null) != (t2 == null))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\treturn t == null || typeEq(t, t2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `f1 == f2`, this function performs a deep equality check on\n\t\tthe given `ClassField` instances.\n\n\t\tIf `f1` or `f2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function fieldEq(f1:ClassField, f2:ClassField) {\n\t\tif (f1.name != f2.name)\n\t\t\treturn false;\n\t\tif (!typeEq(f1.type, f2.type))\n\t\t\treturn false;\n\t\tif (f1.isPublic != f2.isPublic)\n\t\t\treturn false;\n\t\tif (f1.doc != f2.doc)\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.get, f2.get))\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.set, f2.set))\n\t\t\treturn false;\n\t\tif ((f1.params == null) != (f2.params == null))\n\t\t\treturn false;\n\t\tif (f1.params != null && f1.params.join(\":\") != f2.params.join(\":\"))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `c1 == c2`, this function performs a deep equality check on\n\t\tthe arguments of the enum constructors, if exists.\n\n\t\tIf `c1` or `c2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function constructorEq(c1:EnumField, c2:EnumField) {\n\t\tif (c1.name != c2.name)\n\t\t\treturn false;\n\t\tif (c1.doc != c2.doc)\n\t\t\treturn false;\n\t\tif ((c1.args == null) != (c2.args == null))\n\t\t\treturn false;\n\t\tif (c1.args != null && !leq(function(a, b) {\n\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t}, c1.args, c2.args))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n\n/**\n\tThe `CTypeTools` class contains some extra functionalities for handling\n\t`CType` instances.\n**/\nclass CTypeTools {\n\t/**\n\t\tGet the string representation of `CType`.\n\t**/\n\tstatic public function toString(t:CType):String {\n\t\treturn switch (t) {\n\t\t\tcase CUnknown:\n\t\t\t\t\"unknown\";\n\t\t\tcase CClass(name, params), CEnum(name, params), CTypedef(name, params), CAbstract(name, params):\n\t\t\t\tnameWithParams(name, params);\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tif (args.length == 0) {\n\t\t\t\t\t\"Void -> \" + toString(ret);\n\t\t\t\t} else {\n\t\t\t\t\targs.map(functionArgumentName).join(\" -> \") + \" -> \" + toString(ret);\n\t\t\t\t}\n\t\t\tcase CDynamic(d):\n\t\t\t\tif (d == null) {\n\t\t\t\t\t\"Dynamic\";\n\t\t\t\t} else {\n\t\t\t\t\t\"Dynamic<\" + toString(d) + \">\";\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\t\"{ \" + fields.map(classField).join(\", \") + \"}\";\n\t\t}\n\t}\n\n\tstatic function nameWithParams(name:String, params:Array<CType>) {\n\t\tif (params.length == 0) {\n\t\t\treturn name;\n\t\t}\n\t\treturn name + \"<\" + params.map(toString).join(\", \") + \">\";\n\t}\n\n\tstatic function functionArgumentName(arg:FunctionArgument) {\n\t\treturn (arg.opt ? \"?\" : \"\")\n\t\t\t+ (arg.name == \"\" ? \"\" : arg.name + \":\")\n\t\t\t+ toString(arg.t)\n\t\t\t+ (arg.value == null ? \"\" : \" = \" + arg.value);\n\t}\n\n\tstatic function classField(cf:ClassField) {\n\t\treturn cf.name + \":\" + toString(cf.type);\n\t}\n}\n","/*\n * Copyright (C)2005-2018 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.iterators;\n\n/**\n\tThis iterator is used only when `Array<T>` is passed to `Iterable<T>`\n**/\nclass ArrayIterator<T> {\n\tfinal array:Array<T>;\n\tvar current:Int = 0;\n\n\t/**\n\t\tCreate a new `ArrayIterator`.\n\t**/\n\t#if !hl inline #end\n\tpublic function new(array:Array<T>) {\n\t\tthis.array = array;\n\t}\n\n\t/**\n\t\tSee `Iterator.hasNext`\n\t**/\n\t#if !hl inline #end\n\tpublic function hasNext() {\n\t\treturn current < array.length;\n\t}\n\n\t/**\n\t\tSee `Iterator.next`\n\t**/\n\t#if !hl inline #end\n\tpublic function next() {\n\t\treturn array[current++];\n\t}\n}\n","package haxe.ds;\n\n#if !js\nextern class StringMap<T> implements haxe.Constraints.IMap<String, T> {\n  public function new(): Void;\n  public function set(key: String, value: T): Void;\n  public function get(key: String): Null<T>;\n  public function exists(key: String): Bool;\n  public function remove(key: String): Bool;\n  public function keys(): Iterator<String>;\n  public function iterator(): Iterator<T>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): StringMap<T>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass StringMap<T> extends genes.util.EsMap<String, T> implements haxe.Constraints.IMap<String, T> {\n  public inline function copy(): StringMap<T> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tXml node types.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nenum abstract XmlType(Int) {\n\t/**\n\t\tRepresents an XML element type.\n\t**/\n\tvar Element = 0;\n\n\t/**\n\t\tRepresents XML parsed character data type.\n\t**/\n\tvar PCData = 1;\n\n\t/**\n\t\tRepresents XML character data type.\n\t**/\n\tvar CData = 2;\n\n\t/**\n\t\tRepresents an XML comment type.\n\t**/\n\tvar Comment = 3;\n\n\t/**\n\t\tRepresents an XML doctype element type.\n\t**/\n\tvar DocType = 4;\n\n\t/**\n\t\tRepresents an XML processing instruction type.\n\t**/\n\tvar ProcessingInstruction = 5;\n\n\t/**\n\t\tRepresents an XML document type.\n\t**/\n\tvar Document = 6;\n\n\tpublic function toString():String {\n\t\treturn switch (cast this : XmlType) {\n\t\t\tcase Element: \"Element\";\n\t\t\tcase PCData: \"PCData\";\n\t\t\tcase CData: \"CData\";\n\t\t\tcase Comment: \"Comment\";\n\t\t\tcase DocType: \"DocType\";\n\t\t\tcase ProcessingInstruction: \"ProcessingInstruction\";\n\t\t\tcase Document: \"Document\";\n\t\t};\n\t}\n}\n\n/**\n\tCross-platform Xml API.\n\n\t@see https://haxe.org/manual/std-Xml.html\n**/\nclass Xml {\n\t/**\n\t\tXML element type.\n\t**/\n\tstatic public var Element(default, never) = XmlType.Element;\n\n\t/**\n\t\tXML parsed character data type.\n\t**/\n\tstatic public var PCData(default, never) = XmlType.PCData;\n\n\t/**\n\t\tXML character data type.\n\t**/\n\tstatic public var CData(default, never) = XmlType.CData;\n\n\t/**\n\t\tXML comment type.\n\t**/\n\tstatic public var Comment(default, never) = XmlType.Comment;\n\n\t/**\n\t\tXML doctype element type.\n\t**/\n\tstatic public var DocType(default, never) = XmlType.DocType;\n\n\t/**\n\t\tXML processing instruction type.\n\t**/\n\tstatic public var ProcessingInstruction(default, never) = XmlType.ProcessingInstruction;\n\n\t/**\n\t\tXML document type.\n\t**/\n\tstatic public var Document(default, never) = XmlType.Document;\n\n\t/**\n\t\tParses the String into an Xml document.\n\t**/\n\tstatic public function parse(str:String):Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\t/**\n\t\tReturns the type of the Xml Node. This should be used before\n\t\taccessing other functions since some might raise an exception\n\t\tif the node type is not correct.\n\t**/\n\tpublic var nodeType(default, null):XmlType;\n\n\t/**\n\t\tReturns the node name of an Element.\n\t**/\n\t@:isVar public var nodeName(get, set):String;\n\n\t/**\n\t\tReturns the node value. Only works if the Xml node is not an Element or a Document.\n\t**/\n\t@:isVar public var nodeValue(get, set):String;\n\n\t/**\n\t\tReturns the parent object in the Xml hierarchy.\n\t\tThe parent can be `null`, an Element or a Document.\n\t**/\n\tpublic var parent(default, null):Xml;\n\n\tvar children:Array<Xml>;\n\tvar attributeMap:Map<String, String>;\n\n\t#if !cppia inline #end function get_nodeName() {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn nodeName;\n\t}\n\n\t#if !cppia inline #end function set_nodeName(v) {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn this.nodeName = v;\n\t}\n\n\t#if !cppia inline #end function get_nodeValue() {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn nodeValue;\n\t}\n\n\t#if !cppia inline #end function set_nodeValue(v) {\n\t\tif (nodeType == Document || nodeType == Element) {\n\t\t\tthrow 'Bad node type, unexpected $nodeType';\n\t\t}\n\t\treturn this.nodeValue = v;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createElement(name:String):Xml {\n\t\tvar xml = new Xml(Element);\n\t\txml.nodeName = name;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createPCData(data:String):Xml {\n\t\tvar xml = new Xml(PCData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createCData(data:String):Xml {\n\t\tvar xml = new Xml(CData);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createComment(data:String):Xml {\n\t\tvar xml = new Xml(Comment);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocType(data:String):Xml {\n\t\tvar xml = new Xml(DocType);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createProcessingInstruction(data:String):Xml {\n\t\tvar xml = new Xml(ProcessingInstruction);\n\t\txml.nodeValue = data;\n\t\treturn xml;\n\t}\n\n\t/**\n\t\tCreates a node of the given type.\n\t**/\n\tstatic public function createDocument():Xml {\n\t\treturn new Xml(Document);\n\t}\n\n\t/**\n\t\tGet the given attribute of an Element node. Returns `null` if not found.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function get(att:String):String {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap[att];\n\t}\n\n\t/**\n\t\tSet the given attribute value for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function set(att:String, value:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.set(att, value);\n\t}\n\n\t/**\n\t\tRemoves an attribute for an Element node.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function remove(att:String):Void {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\tattributeMap.remove(att);\n\t}\n\n\t/**\n\t\tTells if the Element node has a given attribute.\n\t\tAttributes are case-sensitive.\n\t**/\n\tpublic function exists(att:String):Bool {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.exists(att);\n\t}\n\n\t/**\n\t\tReturns an `Iterator` on all the attribute names.\n\t**/\n\tpublic function attributes():Iterator<String> {\n\t\tif (nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element but found $nodeType';\n\t\t}\n\t\treturn attributeMap.keys();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic #if !cppia inline #end function iterator():Iterator<Xml> {\n\t\tensureElementType();\n\t\treturn children.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elements():Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [for (child in children) if (child.nodeType == Element) child];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns an iterator of all child nodes which are Elements with the given nodeName.\n\t\tOnly works if the current node is an Element or a Document.\n\t**/\n\tpublic function elementsNamed(name:String):Iterator<Xml> {\n\t\tensureElementType();\n\t\tvar ret = [\n\t\t\tfor (child in children)\n\t\t\t\tif (child.nodeType == Element && child.nodeName == name) child\n\t\t];\n\t\treturn ret.iterator();\n\t}\n\n\t/**\n\t\tReturns the first child node.\n\t**/\n\tpublic #if !cppia inline #end function firstChild():Xml {\n\t\tensureElementType();\n\t\treturn children[0];\n\t}\n\n\t/**\n\t\tReturns the first child node which is an Element.\n\t**/\n\tpublic function firstElement():Xml {\n\t\tensureElementType();\n\t\tfor (child in children) {\n\t\t\tif (child.nodeType == Element) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tAdds a child node to the Document or Element.\n\t\tA child node can only be inside one given parent node, which is indicated by the `parent` property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function addChild(x:Xml):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.removeChild(x);\n\t\t}\n\t\tchildren.push(x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tRemoves a child from the Document or Element.\n\t\tReturns true if the child was successfuly removed.\n\t**/\n\tpublic function removeChild(x:Xml):Bool {\n\t\tensureElementType();\n\t\tif (children.remove(x)) {\n\t\t\tx.parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tInserts a child at the given position among the other childs.\n\t\tA child node can only be inside one given parent node, which is indicated by the [parent] property.\n\t\tIf the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.\n\t\tIf the child node was previously inside a different node, it will be moved to this Document or Element.\n\t**/\n\tpublic function insertChild(x:Xml, pos:Int):Void {\n\t\tensureElementType();\n\t\tif (x.parent != null) {\n\t\t\tx.parent.children.remove(x);\n\t\t}\n\t\tchildren.insert(pos, x);\n\t\tx.parent = this;\n\t}\n\n\t/**\n\t\tReturns a String representation of the Xml node.\n\t**/\n\tpublic #if !cppia inline #end function toString():String {\n\t\treturn haxe.xml.Printer.print(this);\n\t}\n\n\tfunction new(nodeType:XmlType) {\n\t\tthis.nodeType = nodeType;\n\t\tchildren = [];\n\t\tattributeMap = new Map();\n\t}\n\n\tinline function ensureElementType() {\n\t\tif (nodeType != Document && nodeType != Element) {\n\t\t\tthrow 'Bad node type, expected Element or Document but found $nodeType';\n\t\t}\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass(c:Class<Dynamic>);\n\tTEnum(e:Enum<Dynamic>);\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\tpublic static inline function getClass<T>(o:T):Class<T> {\n\t\treturn @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum(o:EnumValue):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn null;\n\t\t\t#if js_enums_as_arrays\n\t\t\treturn o.__enum__;\n\t\t\t#else\n\t\t\treturn $hxEnums[o.__enum__];\n\t\t\t#end\n\t\t}\n\n\tpublic static inline function getSuperClass(c:Class<Dynamic>):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.getSuperClass\", c.__super__);\n\t}\n\n\tpublic static inline function getClassName(c:Class<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getClassName\", c.__name__);\n\t}\n\n\tpublic static inline function getEnumName(e:Enum<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getEnumName\", e.__ename__);\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic static function resolveClass(name:String):Class<Dynamic>\n\t\tuntyped {\n\t\t\tvar cl:Class<Dynamic> = $hxClasses[name];\n\t\t\t// ensure that this is a class\n\t\t\tif (cl == null || !js.Boot.isClass(cl))\n\t\t\t\treturn null;\n\t\t\treturn cl;\n\t\t}\n\n\tpublic static function resolveEnum(name:String):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tvar e:Dynamic = $hxClasses[name];\n\t\t\t// ensure that this is an enum\n\t\t\tif (e == null || !js.Boot.isEnum(e))\n\t\t\t\treturn null;\n\t\t\treturn e;\n\t\t}\n\t#else\n\tpublic static inline function resolveClass(name:String):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveClass\", $hxClasses[name]);\n\t}\n\n\tpublic static inline function resolveEnum(name:String):Enum<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveEnum\", $hxEnums[name]);\n\t}\n\t#end\n\n\t#if (js_es < 5)\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T {\n\t\tswitch (args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn js.Syntax.construct(cl);\n\t\t\tcase 1:\n\t\t\t\treturn js.Syntax.construct(cl, args[0]);\n\t\t\tcase 2:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1]);\n\t\t\tcase 3:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2]);\n\t\t\tcase 4:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3]);\n\t\t\tcase 5:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4]);\n\t\t\tcase 6:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5]);\n\t\t\tcase 7:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t\t\tcase 8:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n\t\t\tcase 9:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n\t\t\tcase 10:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n\t\t\tcase 11:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\n\t\t\tcase 12:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\n\t\t\tcase 13:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12]);\n\t\t\tcase 14:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12], args[13]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t}\n\n\tpublic static function createEmptyInstance<T>(cl:Class<T>):T\n\t\tuntyped {\n\t\t\tjs.Syntax.code(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\t\treturn js.Syntax.code(\"new empty()\");\n\t\t}\n\t#else\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T {\n\t\tvar ctor = ((cast js.lib.Function).prototype.bind : js.lib.Function).apply(cl, [null].concat(args));\n\t\treturn js.Syntax.code(\"new ({0})\", ctor); // cannot use `js.Syntax.construct` because we need parens if `ctor` is fused in\n\t}\n\n\tpublic static inline function createEmptyInstance<T>(cl:Class<T>):T {\n\t\treturn js.lib.Object.create((cast cl).prototype);\n\t}\n\t#end\n\n\tpublic static function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\n\t\tvar f:Dynamic = Reflect.field(e, constr);\n\t\tif (f == null)\n\t\t\tthrow \"No such constructor \" + constr;\n\t\tif (Reflect.isFunction(f)) {\n\t\t\tif (params == null)\n\t\t\t\tthrow \"Constructor \" + constr + \" need parameters\";\n\t\t\treturn Reflect.callMethod(e, f, params);\n\t\t}\n\t\tif (params != null && params.length != 0)\n\t\t\tthrow \"Constructor \" + constr + \" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\n\t\tvar c:String = (untyped e.__constructs__)[index];\n\t\tif (c == null)\n\t\t\tthrow index + \" is not a valid enum constructor index\";\n\t\treturn createEnum(e, c, params);\n\t}\n\n\t#if (js_es >= 6)\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar result = [];\n\t\twhile (c != null) {\n\t\t\tfor (name in js.lib.Object.getOwnPropertyNames((cast c).prototype)) {\n\t\t\t\tswitch name {\n\t\t\t\t\tcase \"constructor\" | \"__class__\" | \"__properties__\":\n\t\t\t\t\t// skip special names\n\t\t\t\t\tcase _:\n\t\t\t\t\t\tif (result.indexOf(name) == -1)\n\t\t\t\t\t\t\tresult.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = getSuperClass(c);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = js.lib.Object.getOwnPropertyNames(cast c);\n\t\ta.remove(\"__id__\");\n\t\ta.remove(\"hx__closures__\");\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__isInterface__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__instanceFields__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\ta.remove(\"name\");\n\t\ta.remove(\"length\");\n\t\treturn a;\n\t}\n\t#else\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = [];\n\t\tjs.Syntax.code(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\t#end\n\n\tpublic static inline function getEnumConstructs(e:Enum<Dynamic>):Array<String> {\n\t\treturn ((cast e).__constructs__ : Array<String>).copy();\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function typeof(v:Dynamic):ValueType {\n\t\tswitch (js.Syntax.typeof(v)) {\n\t\t\tcase \"boolean\":\n\t\t\t\treturn TBool;\n\t\t\tcase \"string\":\n\t\t\t\treturn TClass(String);\n\t\t\tcase \"number\":\n\t\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\t\tif (Math.ceil(v) == v % 2147483648.0)\n\t\t\t\t\treturn TInt;\n\t\t\t\treturn TFloat;\n\t\t\tcase \"object\":\n\t\t\t\tif (v == null)\n\t\t\t\t\treturn TNull;\n\t\t\t\tvar e = v.__enum__;\n\t\t\t\tif (e != null) {\n\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\treturn TEnum(e);\n\t\t\t\t\t#else\n\t\t\t\t\treturn TEnum(untyped $hxEnums[e]);\n\t\t\t\t\t#end\n\t\t\t\t}\n\t\t\t\tvar c = js.Boot.getClass(v);\n\t\t\t\tif (c != null)\n\t\t\t\t\treturn TClass(c);\n\t\t\t\treturn TObject;\n\t\t\tcase \"function\":\n\t\t\t\tif (js.Boot.isClass(v) || js.Boot.isEnum(v))\n\t\t\t\t\treturn TObject;\n\t\t\t\treturn TFunction;\n\t\t\tcase \"undefined\":\n\t\t\t\treturn TNull;\n\t\t\tdefault:\n\t\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T:EnumValue>(a:T, b:T):Bool\n\t\tuntyped {\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\ttry {\n\t\t\t\tvar e = a.__enum__;\n\t\t\t\tif (e == null || e != b.__enum__)\n\t\t\t\t\treturn false;\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\tif (a[0] != b[0])\n\t\t\t\t\treturn false;\n\t\t\t\tfor (i in 2...a.length)\n\t\t\t\t\tif (!enumEq(a[i], b[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t#else\n\t\t\t\tif (a._hx_index != b._hx_index)\n\t\t\t\t\treturn false;\n\t\t\t\tvar enm = $hxEnums[e];\n\t\t\t\tvar ctorName = enm.__constructs__[a._hx_index];\n\t\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\t\tfor (f in params) {\n\t\t\t\t\tif (!enumEq(a[f], b[f])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t} catch (e:Dynamic) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\tpublic inline static function enumConstructor(e:EnumValue):String {\n\t\t#if js_enums_as_arrays\n\t\treturn untyped e[0];\n\t\t#else\n\t\treturn untyped $hxEnums[e.__enum__].__constructs__[e._hx_index];\n\t\t#end\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic inline static function enumParameters(e:EnumValue):Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\t#else\n\tpublic static function enumParameters(e:EnumValue):Array<Dynamic>\n\t\tuntyped {\n\t\t\tvar enm:Enum<Dynamic> = $hxEnums[e.__enum__];\n\t\t\tvar ctorName:String = enm.__constructs__[e._hx_index];\n\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\treturn params != null ? [for (p in params) e[p]] : [];\n\t\t}\n\t#end\n\n\tpublic inline static function enumIndex(e:EnumValue):Int {\n\t\t#if !js_enums_as_arrays\n\t\treturn untyped e._hx_index;\n\t\t#else\n\t\treturn untyped e[1];\n\t\t#end\n\t}\n\n\tpublic inline static function allEnums<T>(e:Enum<T>):Array<T> {\n\t\treturn untyped __define_feature__(\"Type.allEnums\", e.__empty_constructs__.slice());\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\nimport haxe.rtti.CType;\nimport haxe.xml.Access;\n\n/**\n\tXmlParser processes the runtime type information (RTTI) which\n\tis stored as a XML string in a static field `__rtti`.\n\n\t@see <https://haxe.org/manual/cr-rtti.html>\n**/\nclass XmlParser {\n\tpublic var root:TypeRoot;\n\n\tvar curplatform:String;\n\n\tpublic function new() {\n\t\troot = new Array();\n\t}\n\n\tpublic function sort(?l:TypeRoot) {\n\t\tif (l == null)\n\t\t\tl = root;\n\t\tl.sort(function(e1, e2) {\n\t\t\tvar n1 = switch e1 {\n\t\t\t\tcase TPackage(p, _, _): \" \" + p;\n\t\t\t\tdefault: TypeApi.typeInfos(e1).path;\n\t\t\t};\n\t\t\tvar n2 = switch e2 {\n\t\t\t\tcase TPackage(p, _, _): \" \" + p;\n\t\t\t\tdefault: TypeApi.typeInfos(e2).path;\n\t\t\t};\n\t\t\tif (n1 > n2)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t});\n\t\tfor (x in l)\n\t\t\tswitch (x) {\n\t\t\t\tcase TPackage(_, _, l):\n\t\t\t\t\tsort(l);\n\t\t\t\tcase TClassdecl(c):\n\t\t\t\t\tsortFields(c.fields);\n\t\t\t\t\tsortFields(c.statics);\n\t\t\t\tcase TEnumdecl(_):\n\t\t\t\tcase TAbstractdecl(_):\n\t\t\t\tcase TTypedecl(_):\n\t\t\t}\n\t}\n\n\tfunction sortFields(a:Array<ClassField>) {\n\t\ta.sort(function(f1:ClassField, f2:ClassField) {\n\t\t\tvar v1 = TypeApi.isVar(f1.type);\n\t\t\tvar v2 = TypeApi.isVar(f2.type);\n\t\t\tif (v1 && !v2)\n\t\t\t\treturn -1;\n\t\t\tif (v2 && !v1)\n\t\t\t\treturn 1;\n\t\t\tif (f1.name == \"new\")\n\t\t\t\treturn -1;\n\t\t\tif (f2.name == \"new\")\n\t\t\t\treturn 1;\n\t\t\tif (f1.name > f2.name)\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t});\n\t}\n\n\tpublic function process(x:Xml, platform:String) {\n\t\tcurplatform = platform;\n\t\txroot(new Access(x));\n\t}\n\n\t// merge inline and not inline\n\tfunction mergeRights(f1:ClassField, f2:ClassField) {\n\t\tif (f1.get == RInline && f1.set == RNo && f2.get == RNormal && f2.set == RMethod) {\n\t\t\tf1.get = RNormal;\n\t\t\tf1.set = RMethod;\n\t\t\treturn true;\n\t\t}\n\t\treturn Type.enumEq(f1.get, f2.get) && Type.enumEq(f1.set, f2.set);\n\t}\n\n\tfunction mergeDoc(f1:ClassField, f2:ClassField) {\n\t\tif (f1.doc == null)\n\t\t\tf1.doc = f2.doc;\n\t\telse if (f2.doc == null)\n\t\t\tf2.doc = f1.doc;\n\t\treturn true;\n\t}\n\n\tfunction mergeFields(f:ClassField, f2:ClassField) {\n\t\treturn TypeApi.fieldEq(f, f2)\n\t\t\t|| (f.name == f2.name && (mergeRights(f, f2) || mergeRights(f2, f)) && mergeDoc(f, f2) && TypeApi.fieldEq(f, f2));\n\t}\n\n\tpublic dynamic function newField(c:Classdef, f:ClassField) {}\n\n\tfunction mergeClasses(c:Classdef, c2:Classdef) {\n\t\t// todo : compare supers & interfaces\n\t\tif (c.isInterface != c2.isInterface)\n\t\t\treturn false;\n\t\tif (curplatform != null)\n\t\t\tc.platforms.push(curplatform);\n\t\tif (c.isExtern != c2.isExtern)\n\t\t\tc.isExtern = false;\n\n\t\tfor (f2 in c2.fields) {\n\t\t\tvar found = null;\n\t\t\tfor (f in c.fields)\n\t\t\t\tif (mergeFields(f, f2)) {\n\t\t\t\t\tfound = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null) {\n\t\t\t\tnewField(c, f2);\n\t\t\t\tc.fields.push(f2);\n\t\t\t} else if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\tfor (f2 in c2.statics) {\n\t\t\tvar found = null;\n\t\t\tfor (f in c.statics)\n\t\t\t\tif (mergeFields(f, f2)) {\n\t\t\t\t\tfound = f;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null) {\n\t\t\t\tnewField(c, f2);\n\t\t\t\tc.statics.push(f2);\n\t\t\t} else if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mergeEnums(e:Enumdef, e2:Enumdef) {\n\t\tif (e.isExtern != e2.isExtern)\n\t\t\treturn false;\n\t\tif (curplatform != null)\n\t\t\te.platforms.push(curplatform);\n\t\tfor (c2 in e2.constructors) {\n\t\t\tvar found = null;\n\t\t\tfor (c in e.constructors)\n\t\t\t\tif (TypeApi.constructorEq(c, c2)) {\n\t\t\t\t\tfound = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (found == null)\n\t\t\t\te.constructors.push(c2);\n\t\t\telse if (curplatform != null)\n\t\t\t\tfound.platforms.push(curplatform);\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction mergeTypedefs(t:Typedef, t2:Typedef) {\n\t\tif (curplatform == null)\n\t\t\treturn false;\n\t\tt.platforms.push(curplatform);\n\t\tt.types.set(curplatform, t2.type);\n\t\treturn true;\n\t}\n\n\tfunction mergeAbstracts(a:Abstractdef, a2:Abstractdef) {\n\t\tif (curplatform == null)\n\t\t\treturn false;\n\t\tif (a.to.length != a2.to.length || a.from.length != a2.from.length)\n\t\t\treturn false;\n\t\tfor (i in 0...a.to.length)\n\t\t\tif (!TypeApi.typeEq(a.to[i].t, a2.to[i].t))\n\t\t\t\treturn false;\n\t\tfor (i in 0...a.from.length)\n\t\t\tif (!TypeApi.typeEq(a.from[i].t, a2.from[i].t))\n\t\t\t\treturn false;\n\t\tif (a2.impl != null)\n\t\t\tmergeClasses(a.impl, a2.impl);\n\t\ta.platforms.push(curplatform);\n\t\treturn true;\n\t}\n\n\tfunction merge(t:TypeTree) {\n\t\tvar inf = TypeApi.typeInfos(t);\n\t\tvar pack = inf.path.split(\".\");\n\t\tvar cur = root;\n\t\tvar curpack = new Array();\n\t\tpack.pop();\n\t\tfor (p in pack) {\n\t\t\tvar found = false;\n\t\t\tfor (pk in cur)\n\t\t\t\tswitch (pk) {\n\t\t\t\t\tcase TPackage(pname, _, subs):\n\t\t\t\t\t\tif (pname == p) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tcur = subs;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcurpack.push(p);\n\t\t\tif (!found) {\n\t\t\t\tvar pk = new Array();\n\t\t\t\tcur.push(TPackage(p, curpack.join(\".\"), pk));\n\t\t\t\tcur = pk;\n\t\t\t}\n\t\t}\n\t\tfor (ct in cur) {\n\t\t\tif (ct.match(TPackage(_)))\n\t\t\t\tcontinue;\n\t\t\tvar tinf = TypeApi.typeInfos(ct);\n\n\t\t\t// compare params ?\n\t\t\tif (tinf.path == inf.path) {\n\t\t\t\tvar sameType = true;\n\t\t\t\tif ((tinf.doc == null) != (inf.doc == null)) {\n\t\t\t\t\tif (inf.doc == null)\n\t\t\t\t\t\tinf.doc = tinf.doc;\n\t\t\t\t\telse\n\t\t\t\t\t\ttinf.doc = inf.doc;\n\t\t\t\t}\n\t\t\t\tif (tinf.path == \"haxe._Int64.NativeInt64\")\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tinf.module == inf.module && tinf.doc == inf.doc && tinf.isPrivate == inf.isPrivate)\n\t\t\t\t\tswitch (ct) {\n\t\t\t\t\t\tcase TClassdecl(c):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TClassdecl(c2):\n\t\t\t\t\t\t\t\t\tif (mergeClasses(c, c2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TEnumdecl(e):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TEnumdecl(e2):\n\t\t\t\t\t\t\t\t\tif (mergeEnums(e, e2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TTypedecl(td):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TTypedecl(td2):\n\t\t\t\t\t\t\t\t\tif (mergeTypedefs(td, td2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TAbstractdecl(a):\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\t\tcase TAbstractdecl(a2):\n\t\t\t\t\t\t\t\t\tif (mergeAbstracts(a, a2))\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase TPackage(_, _, _):\n\t\t\t\t\t\t\tsameType = false;\n\t\t\t\t\t}\n\t\t\t\t// we already have a mapping, but which is incompatible\n\t\t\t\tvar msg = if (tinf.module != inf.module) \"module \" + inf.module + \" should be \" + tinf.module; else if (tinf.doc != inf.doc)\n\t\t\t\t\t\"documentation is different\";\n\t\t\t\telse if (tinf.isPrivate != inf.isPrivate)\n\t\t\t\t\t\"private flag is different\";\n\t\t\t\telse if (!sameType)\n\t\t\t\t\t\"type kind is different\";\n\t\t\t\telse\n\t\t\t\t\t\"could not merge definition\";\n\t\t\t\tthrow \"Incompatibilities between \" + tinf.path + \" in \" + tinf.platforms.join(\",\") + \" and \" + curplatform + \" (\" + msg + \")\";\n\t\t\t}\n\t\t}\n\t\tcur.push(t);\n\t}\n\n\tfunction mkPath(p:String):Path {\n\t\treturn p;\n\t}\n\n\tfunction mkTypeParams(p:String):TypeParams {\n\t\tvar pl = p.split(\":\");\n\t\tif (pl[0] == \"\")\n\t\t\treturn new Array();\n\t\treturn pl;\n\t}\n\n\tfunction mkRights(r:String):Rights {\n\t\treturn switch (r) {\n\t\t\tcase \"null\": RNo;\n\t\t\tcase \"method\": RMethod;\n\t\t\tcase \"dynamic\": RDynamic;\n\t\t\tcase \"inline\": RInline;\n\t\t\tdefault: RCall(r);\n\t\t}\n\t}\n\n\tfunction xerror(c:Access):Dynamic {\n\t\treturn throw \"Invalid \" + c.name;\n\t}\n\n\tfunction xroot(x:Access) {\n\t\tfor (c in x.x.elements())\n\t\t\tmerge(processElement(c));\n\t}\n\n\tpublic function processElement(x:Xml) {\n\t\tvar c = new haxe.xml.Access(x);\n\t\treturn switch (c.name) {\n\t\t\tcase \"class\": TClassdecl(xclass(c));\n\t\t\tcase \"enum\": TEnumdecl(xenum(c));\n\t\t\tcase \"typedef\": TTypedecl(xtypedef(c));\n\t\t\tcase \"abstract\": TAbstractdecl(xabstract(c));\n\t\t\tdefault: xerror(c);\n\t\t}\n\t}\n\n\tfunction xmeta(x:Access):MetaData {\n\t\tvar ml = [];\n\t\tfor (m in x.nodes.m) {\n\t\t\tvar pl = [];\n\t\t\tfor (p in m.nodes.e)\n\t\t\t\tpl.push(p.innerHTML);\n\t\t\tml.push({name: m.att.n, params: pl});\n\t\t}\n\t\treturn ml;\n\t}\n\n\tfunction xoverloads(x:Access):Array<ClassField> {\n\t\tvar l = new Array();\n\t\tfor (m in x.elements) {\n\t\t\tl.push(xclassfield(m));\n\t\t}\n\t\treturn l;\n\t}\n\n\tfunction xpath(x:Access):PathParams {\n\t\tvar path = mkPath(x.att.path);\n\t\tvar params = new Array();\n\t\tfor (c in x.elements)\n\t\t\tparams.push(xtype(c));\n\t\treturn {\n\t\t\tpath: path,\n\t\t\tparams: params,\n\t\t};\n\t}\n\n\tfunction xclass(x:Access):Classdef {\n\t\tvar csuper = null;\n\t\tvar doc = null;\n\t\tvar tdynamic = null;\n\t\tvar interfaces = new Array();\n\t\tvar fields = new Array();\n\t\tvar statics = new Array();\n\t\tvar meta = [];\n\t\tvar isInterface = x.x.exists(\"interface\");\n\t\tfor (c in x.elements)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"extends\":\n\t\t\t\t\tif (isInterface) {\n\t\t\t\t\t\tinterfaces.push(xpath(c));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcsuper = xpath(c);\n\t\t\t\t\t}\n\t\t\t\tcase \"implements\":\n\t\t\t\t\tinterfaces.push(xpath(c));\n\t\t\t\tcase \"haxe_dynamic\":\n\t\t\t\t\ttdynamic = xtype(new Access(c.x.firstElement()));\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tdefault:\n\t\t\t\t\tif (c.x.exists(\"static\"))\n\t\t\t\t\t\tstatics.push(xclassfield(c));\n\t\t\t\t\telse\n\t\t\t\t\t\tfields.push(xclassfield(c));\n\t\t\t}\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tisExtern: x.x.exists(\"extern\"),\n\t\t\tisFinal: x.x.exists(\"final\"),\n\t\t\tisInterface: isInterface,\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tsuperClass: csuper,\n\t\t\tinterfaces: interfaces,\n\t\t\tfields: fields,\n\t\t\tstatics: statics,\n\t\t\ttdynamic: tdynamic,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xclassfield(x:Access, ?defPublic = false):ClassField {\n\t\tvar e = x.elements;\n\t\tvar t = xtype(e.next());\n\t\tvar doc = null;\n\t\tvar meta = [];\n\t\tvar overloads = null;\n\t\tfor (c in e)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tcase \"overloads\":\n\t\t\t\t\toverloads = xoverloads(c);\n\t\t\t\tdefault:\n\t\t\t\t\txerror(c);\n\t\t\t}\n\t\treturn {\n\t\t\tname:x.name, type:t, isPublic:x.x.exists(\"public\") || defPublic, isFinal:x.x.exists(\"final\"), isOverride:x.x.exists(\"override\"),\n\t\t\tline:if (x.has.line) Std.parseInt(x.att.line) else null, doc:doc, get:if (x.has.get) mkRights(x.att.get) else RNormal, set:if (x.has.set)\n\t\t\t\tmkRights(x.att.set)\n\t\t\telse\n\t\t\t\tRNormal, params:if (x.has.params) mkTypeParams(x.att.params) else [], platforms:defplat(), meta:meta, overloads:overloads, expr:if (x.has.expr)\n\t\t\t\tx.att.expr\n\t\t\telse\n\t\t\t\tnull\n\t\t};\n\t}\n\n\tfunction xenum(x:Access):Enumdef {\n\t\tvar cl = new Array();\n\t\tvar doc = null;\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tif (c.name == \"haxe_doc\")\n\t\t\t\tdoc = c.innerData;\n\t\t\telse if (c.name == \"meta\")\n\t\t\t\tmeta = xmeta(c);\n\t\t\telse\n\t\t\t\tcl.push(xenumfield(c));\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tisExtern: x.x.exists(\"extern\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tconstructors: cl,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xenumfield(x:Access):EnumField {\n\t\tvar args = null;\n\t\tvar docElements = x.x.elementsNamed(\"haxe_doc\");\n\t\tvar xdoc = if (docElements.hasNext()) docElements.next() else null;\n\t\tvar meta = if (x.hasNode.meta) xmeta(x.node.meta) else [];\n\t\tif (x.has.a) {\n\t\t\tvar names = x.att.a.split(\":\");\n\t\t\tvar elts = x.elements;\n\t\t\targs = new Array();\n\t\t\tfor (c in names) {\n\t\t\t\tvar opt = false;\n\t\t\t\tif (c.charAt(0) == \"?\") {\n\t\t\t\t\topt = true;\n\t\t\t\t\tc = c.substr(1);\n\t\t\t\t}\n\t\t\t\targs.push({\n\t\t\t\t\tname: c,\n\t\t\t\t\topt: opt,\n\t\t\t\t\tt: xtype(elts.next()),\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: x.name,\n\t\t\targs: args,\n\t\t\tdoc: if (xdoc == null) null else new Access(xdoc).innerData,\n\t\t\tmeta: meta,\n\t\t\tplatforms: defplat(),\n\t\t};\n\t}\n\n\tfunction xabstract(x:Access):Abstractdef {\n\t\tvar doc = null, impl = null, athis = null;\n\t\tvar meta = [], to = [], from = [];\n\t\tfor (c in x.elements)\n\t\t\tswitch (c.name) {\n\t\t\t\tcase \"haxe_doc\":\n\t\t\t\t\tdoc = c.innerData;\n\t\t\t\tcase \"meta\":\n\t\t\t\t\tmeta = xmeta(c);\n\t\t\t\tcase \"to\":\n\t\t\t\t\tfor (t in c.elements)\n\t\t\t\t\t\tto.push({t: xtype(new Access(t.x.firstElement())), field: t.has.field ? t.att.field : null});\n\t\t\t\tcase \"from\":\n\t\t\t\t\tfor (t in c.elements)\n\t\t\t\t\t\tfrom.push({t: xtype(new Access(t.x.firstElement())), field: t.has.field ? t.att.field : null});\n\t\t\t\tcase \"impl\":\n\t\t\t\t\timpl = xclass(c.node.resolve(\"class\"));\n\t\t\t\tcase \"this\":\n\t\t\t\t\tathis = xtype(new Access(c.x.firstElement()));\n\t\t\t\tdefault:\n\t\t\t\t\txerror(c);\n\t\t\t}\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t\tathis: athis,\n\t\t\tto: to,\n\t\t\tfrom: from,\n\t\t\timpl: impl\n\t\t};\n\t}\n\n\tfunction xtypedef(x:Access):Typedef {\n\t\tvar doc = null;\n\t\tvar t = null;\n\t\tvar meta = [];\n\t\tfor (c in x.elements)\n\t\t\tif (c.name == \"haxe_doc\")\n\t\t\t\tdoc = c.innerData;\n\t\t\telse if (c.name == \"meta\")\n\t\t\t\tmeta = xmeta(c);\n\t\t\telse\n\t\t\t\tt = xtype(c);\n\t\tvar types = new haxe.ds.StringMap();\n\t\tif (curplatform != null)\n\t\t\ttypes.set(curplatform, t);\n\t\treturn {\n\t\t\tfile: if (x.has.file) x.att.file else null,\n\t\t\tpath: mkPath(x.att.path),\n\t\t\tmodule: if (x.has.module) mkPath(x.att.module) else null,\n\t\t\tdoc: doc,\n\t\t\tisPrivate: x.x.exists(\"private\"),\n\t\t\tparams: mkTypeParams(x.att.params),\n\t\t\ttype: t,\n\t\t\ttypes: types,\n\t\t\tplatforms: defplat(),\n\t\t\tmeta: meta,\n\t\t};\n\t}\n\n\tfunction xtype(x:Access):CType {\n\t\treturn switch (x.name) {\n\t\t\tcase \"unknown\":\n\t\t\t\tCUnknown;\n\t\t\tcase \"e\":\n\t\t\t\tCEnum(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"c\":\n\t\t\t\tCClass(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"t\":\n\t\t\t\tCTypedef(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"x\":\n\t\t\t\tCAbstract(mkPath(x.att.path), xtypeparams(x));\n\t\t\tcase \"f\":\n\t\t\t\tvar args = new Array();\n\t\t\t\tvar aname = x.att.a.split(\":\");\n\t\t\t\tvar eargs = aname.iterator();\n\t\t\t\tvar evalues = x.has.v ? x.att.v.split(\":\").iterator() : null;\n\t\t\t\tfor (e in x.elements) {\n\t\t\t\t\tvar opt = false;\n\t\t\t\t\tvar a = eargs.hasNext() ? eargs.next() : null;\n\t\t\t\t\tif (a == null)\n\t\t\t\t\t\ta = \"\";\n\t\t\t\t\tif (a.charAt(0) == \"?\") {\n\t\t\t\t\t\topt = true;\n\t\t\t\t\t\ta = a.substr(1);\n\t\t\t\t\t}\n\t\t\t\t\tvar v = evalues == null || !evalues.hasNext() ? null : evalues.next();\n\t\t\t\t\targs.push({\n\t\t\t\t\t\tname: a,\n\t\t\t\t\t\topt: opt,\n\t\t\t\t\t\tt: xtype(e),\n\t\t\t\t\t\tvalue: v == \"\" ? null : v\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tvar ret = args[args.length - 1];\n\t\t\t\targs.remove(ret);\n\t\t\t\tCFunction(args, ret.t);\n\t\t\tcase \"a\":\n\t\t\t\tvar fields = new Array();\n\t\t\t\tfor (f in x.elements) {\n\t\t\t\t\tvar f = xclassfield(f, true);\n\t\t\t\t\tf.platforms = new Array(); // platforms selection are on the type itself, not on fields\n\t\t\t\t\tfields.push(f);\n\t\t\t\t}\n\t\t\t\tCAnonymous(fields);\n\t\t\tcase \"d\":\n\t\t\t\tvar t = null;\n\t\t\t\tvar tx = x.x.firstElement();\n\t\t\t\tif (tx != null)\n\t\t\t\t\tt = xtype(new Access(tx));\n\t\t\t\tCDynamic(t);\n\t\t\tdefault:\n\t\t\t\txerror(x);\n\t\t}\n\t}\n\n\tfunction xtypeparams(x:Access):Array<CType> {\n\t\tvar p = new Array();\n\t\tfor (c in x.elements)\n\t\t\tp.push(xtype(c));\n\t\treturn p;\n\t}\n\n\tfunction defplat() {\n\t\tvar l = new Array();\n\t\tif (curplatform != null)\n\t\t\tl.push(curplatform);\n\t\treturn l;\n\t}\n}\n"]}