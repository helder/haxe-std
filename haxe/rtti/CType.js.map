{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"CType.js.map","sources":["../../../../../../../haxe/versions/4.2.1/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.2.1/std/haxe/rtti/CType.hx","../../../../../../../haxe/versions/4.2.1/std/js/_std/Array.hx"],"sourcesContent":["package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.rtti;\n\n/**\n\tThe (dot-)path of the runtime type.\n**/\ntypedef Path = String;\n\n/**\n\tA list of strings representing the targets where the type is available.\n**/\ntypedef Platforms = Array<String>;\n\n/**\n\tThe function argument runtime type information.\n**/\ntypedef FunctionArgument = {name:String, opt:Bool, t:CType, ?value:String};\n\n/**\n\tThe runtime member types.\n**/\nenum CType {\n\tCUnknown;\n\tCEnum(name:Path, params:Array<CType>);\n\tCClass(name:Path, params:Array<CType>);\n\tCTypedef(name:Path, params:Array<CType>);\n\tCFunction(args:Array<FunctionArgument>, ret:CType);\n\tCAnonymous(fields:Array<ClassField>);\n\tCDynamic(?t:CType);\n\tCAbstract(name:Path, params:Array<CType>);\n}\n\n/**\n\tThe type parameters in the runtime type information.\n**/\ntypedef PathParams = {\n\t/**\n\t\tThe path of the type.\n\t**/\n\tvar path:Path;\n\n\t/**\n\t\tThe array of parameters types.\n\t**/\n\tvar params:Array<CType>;\n};\n\n/**\n\tAn array of strings representing the names of the type parameters the type\n\thas. As of Haxe 3.2.0, this does not include the constraints.\n**/\ntypedef TypeParams = Array<String>; // no constraints\n\n/**\n\tRepresents the runtime rights of a type.\n**/\nenum Rights {\n\tRNormal;\n\tRNo;\n\tRCall(m:String);\n\tRMethod;\n\tRDynamic;\n\tRInline;\n}\n\n/**\n\tThe list of runtime metadata.\n**/\ntypedef MetaData = Array<{name:String, params:Array<String>}>;\n\n/**\n\tThe runtime class field information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#class-field-information>\n**/\ntypedef ClassField = {\n\t/**\n\t\tThe name of the field.\n\t**/\n\tvar name:String;\n\n\t/**\n\t\tThe type of the field.\n\t**/\n\tvar type:CType;\n\n\t/**\n\t\tWhether or not the field is `public`.\n\t**/\n\tvar isPublic:Bool;\n\n\t/**\n\t\tWhether or not the field is `final`.\n\t**/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the field overrides another field.\n\t**/\n\tvar isOverride:Bool;\n\n\t/**\n\t\tThe documentation of the field. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or\n\t\tif the field has no documentation, the value is `null`.\n\t**/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tThe [read access](https://haxe.org/manual/class-field-property.html#define-read-access)\n\t\tbehavior of the field.\n\t**/\n\tvar get:Rights;\n\n\t/**\n\t\tThe [write access](https://haxe.org/manual/class-field-property.html#define-write-access)\n\t\tbehavior of the field.\n\t**/\n\tvar set:Rights;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters\n\t\tthe field has.\n\t**/\n\tvar params:TypeParams;\n\n\t/**\n\t\tA list of strings representing the targets where the field is available.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the field was annotated with.\n\t**/\n\tvar meta:MetaData;\n\n\t/**\n\t\tThe line number where the field is defined. This information is only\n\t\tavailable if the field has an expression.\n\t\tOtherwise the value is `null`.\n\t**/\n\tvar line:Null<Int>;\n\n\t/**\n\t\tThe list of available overloads for the fields or `null` if no overloads\n\t\texists.\n\t**/\n\tvar overloads:Null<Array<ClassField>>;\n\n\t/**\n\t\tThe actual expression of the field or `null` if there is no expression.\n\t**/\n\tvar expr:Null<String>;\n};\n\n/**\n\tThe general runtime type information.\n**/\ntypedef TypeInfos = {\n\t/**\n\t\tThe type path of the type.\n\t**/\n\tvar path:Path;\n\n\t/**\n\t\tThe type path of the module containing the type.\n\t**/\n\tvar module:Path;\n\n\t/**\n\t\tThe full slash path of the .hx file containing the type.\n\t\tThis might be `null` in case there is no such file, e.g. if the\n\t\ttype is defined through a macro.\n\t**/\n\tvar file:Null<String>;\n\n\t/**\n\t\tAn array of strings representing the names of the type parameters the\n\t\ttype has.\n\t**/\n\tvar params:TypeParams;\n\n\t/**\n\t\tThe documentation of the type. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n\t**/\n\tvar doc:Null<String>;\n\n\t/**\n\t\tWhether or not the type is [`private`](https://haxe.org/manual/type-system-module-sub-types.html#define-private-type).\n\t**/\n\tvar isPrivate:Bool;\n\n\t/**\n\t\tA list of strings representing the targets where the type is available.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe [metadata](https://haxe.org/manual/lf-metadata.html) the type was\n\t\tannotated with.\n\t**/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe runtime class definition information.\n**/\ntypedef Classdef = TypeInfos & {\n\t/**\n\t\tWhether or not the class is [extern](https://haxe.org/manual/lf-externs.html).\n\t**/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tWhether or not the class is `final`.\n\t**/\n\tvar isFinal:Bool;\n\n\t/**\n\t\tWhether or not the class is actually an [interface](https://haxe.org/manual/types-interfaces.html).\n\t**/\n\tvar isInterface:Bool;\n\n\t/**\n\t\tThe class' parent class defined by its type path and list of type\n\t\tparameters.\n\t**/\n\tvar superClass:Null<PathParams>;\n\n\t/**\n\t\tThe list of interfaces defined by their type path and list of type\n\t\tparameters.\n\t**/\n\tvar interfaces:Array<PathParams>;\n\n\t/**\n\t\tThe list of member [class fields](https://haxe.org/manual/class-field.html).\n\t**/\n\tvar fields:Array<ClassField>;\n\n\t/**\n\t\tThe list of static class fields.\n\t**/\n\tvar statics:Array<ClassField>;\n\n\t/**\n\t\tThe type which is dynamically implemented by the class or `null` if no\n\t\tsuch type exists.\n\t**/\n\tvar tdynamic:Null<CType>;\n};\n\n/**\n\tThe runtime enum constructor information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-constructor-information>\n**/\ntypedef EnumField = {\n\t/**\n\t\tThe name of the constructor.\n\t**/\n\tvar name:String;\n\n\t/**\n\t\tThe list of arguments the constructor has or `null` if no arguments are\n\t\tavailable.\n\t**/\n\tvar args:Null<Array<{name:String, opt:Bool, t:CType}>>;\n\n\t/**\n\t\tThe documentation of the constructor. This information is only available\n\t\tif the compiler flag `-D use_rtti_doc` was in place. Otherwise, or if\n\t\tthe constructor has no documentation, the value is `null`.\n\t**/\n\tvar doc:String;\n\n\t/**\n\t\tA list of strings representing the targets where the constructor is\n\t\tavailable.\n\t**/\n\tvar platforms:Platforms;\n\n\t/**\n\t\tThe meta data the constructor was annotated with.\n\t**/\n\tvar meta:MetaData;\n};\n\n/**\n\tThe enum runtime type information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#enum-type-information>\n**/\ntypedef Enumdef = TypeInfos & {\n\t/**\n\t\tWhether or not the enum is [extern](https://haxe.org/manual/lf-externs.html).\n\t**/\n\tvar isExtern:Bool;\n\n\t/**\n\t\tThe list of enum constructors.\n\t**/\n\tvar constructors:Array<EnumField>;\n};\n\n/**\n\tThe typedef runtime information.\n**/\ntypedef Typedef = TypeInfos & {\n\t/**\n\t\tThe type of the typedef.\n\t**/\n\tvar type:CType;\n\n\t/**\n\t\tThe types of the typedef, by platform.\n\t**/\n\tvar types:Map<String, CType>; // by platform\n\n};\n\n/**\n\tThe abstract type runtime information.\n\n\t@see <https://haxe.org/manual/cr-rtti-structure.html#abstract-type-information>\n**/\ntypedef Abstractdef = TypeInfos & {\n\tvar to:Array<{t:CType, field:Null<String>}>;\n\tvar from:Array<{t:CType, field:Null<String>}>;\n\tvar impl:Classdef;\n\tvar athis:CType;\n};\n\n/**\n\tThe tree types of the runtime type.\n**/\nenum TypeTree {\n\tTPackage(name:String, full:String, subs:Array<TypeTree>);\n\tTClassdecl(c:Classdef);\n\tTEnumdecl(e:Enumdef);\n\tTTypedecl(t:Typedef);\n\tTAbstractdecl(a:Abstractdef);\n}\n\n/**\n\tArray of `TypeTree`.\n**/\ntypedef TypeRoot = Array<TypeTree>;\n\n/**\n\tContains type and equality checks functionalities for RTTI.\n**/\nclass TypeApi {\n\tpublic static function typeInfos(t:TypeTree):TypeInfos {\n\t\tvar inf:TypeInfos;\n\t\tswitch (t) {\n\t\t\tcase TClassdecl(c):\n\t\t\t\tinf = c;\n\t\t\tcase TEnumdecl(e):\n\t\t\t\tinf = e;\n\t\t\tcase TTypedecl(t):\n\t\t\t\tinf = t;\n\t\t\tcase TAbstractdecl(a):\n\t\t\t\tinf = a;\n\t\t\tcase TPackage(_, _, _):\n\t\t\t\tthrow \"Unexpected Package\";\n\t\t}\n\t\treturn inf;\n\t}\n\n\t/**\n\t\tReturns `true` if the given `CType` is a variable or `false` if it is a\n\t\tfunction.\n\t**/\n\tpublic static function isVar(t:CType) {\n\t\treturn switch (t) {\n\t\t\tcase CFunction(_, _): false;\n\t\t\tdefault: true;\n\t\t}\n\t}\n\n\tstatic function leq<T>(f:T->T->Bool, l1:Array<T>, l2:Array<T>) {\n\t\tvar it = l2.iterator();\n\t\tfor (e1 in l1) {\n\t\t\tif (!it.hasNext())\n\t\t\t\treturn false;\n\t\t\tvar e2 = it.next();\n\t\t\tif (!f(e1, e2))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (it.hasNext())\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `r1 == r2`, this function performs a deep equality check on\n\t\tthe given `Rights` instances.\n\n\t\tIf `r1` or `r2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function rightsEq(r1:Rights, r2:Rights) {\n\t\tif (r1 == r2)\n\t\t\treturn true;\n\t\tswitch (r1) {\n\t\t\tcase RCall(m1):\n\t\t\t\tswitch (r2) {\n\t\t\t\t\tcase RCall(m2):\n\t\t\t\t\t\treturn m1 == m2;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tdefault:\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `t1 == t2`, this function performs a deep equality check on\n\t\tthe given `CType` instances.\n\n\t\tIf `t1` or `t2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function typeEq(t1:CType, t2:CType) {\n\t\tswitch (t1) {\n\t\t\tcase CUnknown:\n\t\t\t\treturn t2 == CUnknown;\n\t\t\tcase CEnum(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CEnum(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CClass(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CClass(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAbstract(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAbstract(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CTypedef(name, params):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CTypedef(name2, params2):\n\t\t\t\t\t\treturn name == name2 && leq(typeEq, params, params2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CFunction(args2, ret2):\n\t\t\t\t\t\treturn leq(function(a:FunctionArgument, b:FunctionArgument) {\n\t\t\t\t\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t\t\t\t\t}, args, args2) && typeEq(ret, ret2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CAnonymous(fields2):\n\t\t\t\t\t\treturn leq(function(a, b) return fieldEq(a, b), fields, fields2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\tcase CDynamic(t):\n\t\t\t\tswitch (t2) {\n\t\t\t\t\tcase CDynamic(t2):\n\t\t\t\t\t\tif ((t == null) != (t2 == null))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\treturn t == null || typeEq(t, t2);\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tUnlike `f1 == f2`, this function performs a deep equality check on\n\t\tthe given `ClassField` instances.\n\n\t\tIf `f1` or `f2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function fieldEq(f1:ClassField, f2:ClassField) {\n\t\tif (f1.name != f2.name)\n\t\t\treturn false;\n\t\tif (!typeEq(f1.type, f2.type))\n\t\t\treturn false;\n\t\tif (f1.isPublic != f2.isPublic)\n\t\t\treturn false;\n\t\tif (f1.doc != f2.doc)\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.get, f2.get))\n\t\t\treturn false;\n\t\tif (!rightsEq(f1.set, f2.set))\n\t\t\treturn false;\n\t\tif ((f1.params == null) != (f2.params == null))\n\t\t\treturn false;\n\t\tif (f1.params != null && f1.params.join(\":\") != f2.params.join(\":\"))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tUnlike `c1 == c2`, this function performs a deep equality check on\n\t\tthe arguments of the enum constructors, if exists.\n\n\t\tIf `c1` or `c2` are `null`, the result is unspecified.\n\t**/\n\tpublic static function constructorEq(c1:EnumField, c2:EnumField) {\n\t\tif (c1.name != c2.name)\n\t\t\treturn false;\n\t\tif (c1.doc != c2.doc)\n\t\t\treturn false;\n\t\tif ((c1.args == null) != (c2.args == null))\n\t\t\treturn false;\n\t\tif (c1.args != null && !leq(function(a, b) {\n\t\t\treturn a.name == b.name && a.opt == b.opt && typeEq(a.t, b.t);\n\t\t}, c1.args, c2.args))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n\n/**\n\tThe `CTypeTools` class contains some extra functionalities for handling\n\t`CType` instances.\n**/\nclass CTypeTools {\n\t/**\n\t\tGet the string representation of `CType`.\n\t**/\n\tstatic public function toString(t:CType):String {\n\t\treturn switch (t) {\n\t\t\tcase CUnknown:\n\t\t\t\t\"unknown\";\n\t\t\tcase CClass(name, params), CEnum(name, params), CTypedef(name, params), CAbstract(name, params):\n\t\t\t\tnameWithParams(name, params);\n\t\t\tcase CFunction(args, ret):\n\t\t\t\tif (args.length == 0) {\n\t\t\t\t\t\"Void -> \" + toString(ret);\n\t\t\t\t} else {\n\t\t\t\t\targs.map(functionArgumentName).join(\" -> \") + \" -> \" + toString(ret);\n\t\t\t\t}\n\t\t\tcase CDynamic(d):\n\t\t\t\tif (d == null) {\n\t\t\t\t\t\"Dynamic\";\n\t\t\t\t} else {\n\t\t\t\t\t\"Dynamic<\" + toString(d) + \">\";\n\t\t\t\t}\n\t\t\tcase CAnonymous(fields):\n\t\t\t\t\"{ \" + fields.map(classField).join(\", \") + \"}\";\n\t\t}\n\t}\n\n\tstatic function nameWithParams(name:String, params:Array<CType>) {\n\t\tif (params.length == 0) {\n\t\t\treturn name;\n\t\t}\n\t\treturn name + \"<\" + params.map(toString).join(\", \") + \">\";\n\t}\n\n\tstatic function functionArgumentName(arg:FunctionArgument) {\n\t\treturn (arg.opt ? \"?\" : \"\")\n\t\t\t+ (arg.name == \"\" ? \"\" : arg.name + \":\")\n\t\t\t+ toString(arg.t)\n\t\t\t+ (arg.value == null ? \"\" : \" = \" + arg.value);\n\t}\n\n\tstatic function classField(cf:ClassField) {\n\t\treturn cf.name + \":\" + toString(cf.type);\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.ArrayKeyValueIterator;\n\n@:coreApi\nextern class Array<T> {\n\tvar length(default, null):Int;\n\n\tfunction new():Void;\n\tfunction concat(a:Array<T>):Array<T>;\n\tfunction join(sep:String):String;\n\tfunction pop():Null<T>;\n\tfunction push(x:T):Int;\n\tfunction reverse():Void;\n\tfunction shift():Null<T>;\n\tfunction slice(pos:Int, ?end:Int):Array<T>;\n\tfunction sort(f:T->T->Int):Void;\n\tfunction splice(pos:Int, len:Int):Array<T>;\n\tfunction toString():String;\n\tfunction unshift(x:T):Void;\n\n\tinline function insert(pos:Int, x:T):Void {\n\t\t(cast this).splice(pos, 0, x);\n\t}\n\n\tinline function remove(x:T):Bool {\n\t\treturn @:privateAccess HxOverrides.remove(this, x);\n\t}\n\n\tinline function contains(x:T):Bool {\n\t\t#if (js_es >= 6)\n\t\treturn (cast this).includes(x);\n\t\t#else\n\t\treturn this.indexOf(x) != -1;\n\t\t#end\n\t}\n\n\t#if (js_es >= 5)\n\t@:pure function indexOf(x:T, ?fromIndex:Int):Int;\n\t@:pure function lastIndexOf(x:T, ?fromIndex:Int):Int;\n\t#else\n\tinline function indexOf(x:T, ?fromIndex:Int):Int {\n\t\treturn @:privateAccess HxOverrides.indexOf(this, x, (fromIndex != null) ? fromIndex : 0);\n\t}\n\n\tinline function lastIndexOf(x:T, ?fromIndex:Int):Int {\n\t\treturn @:privateAccess HxOverrides.lastIndexOf(this, x, (fromIndex != null) ? fromIndex : length - 1);\n\t}\n\t#end\n\n\t@:pure\n\tinline function copy():Array<T> {\n\t\treturn (cast this).slice();\n\t}\n\n\t@:runtime inline function map<S>(f:T->S):Array<S> {\n\t\tvar result:Array<S> = js.Syntax.construct(Array, length);\n\t\tfor(i in 0...length) {\n\t\t\tresult[i] = f(this[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@:runtime inline function filter(f:T->Bool):Array<T> {\n\t\treturn [for (v in this) if (f(v)) v];\n\t}\n\n\t@:runtime inline function iterator():haxe.iterators.ArrayIterator<T> {\n\t\treturn new haxe.iterators.ArrayIterator(this);\n\t}\n\n\t@:runtime inline function keyValueIterator():ArrayKeyValueIterator<T> {\n\t\treturn new ArrayKeyValueIterator(this);\n\t}\n\n\tinline function resize(len:Int):Void {\n\t\tthis.length = len;\n\t}\n}\n"]}