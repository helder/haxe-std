{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Bytes.js.map","sources":["../../../../../../../haxe/versions/4.1.3/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/io/Encoding.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/Int64.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/io/Bytes.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\n#if eval\n@:keep\n#end\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tString binary encoding supported by Haxe I/O\n**/\nenum Encoding {\n\tUTF8;\n\n\t/**\n\t\tOutput the string the way the platform represent it in memory. This is the most efficient but is platform-specific\n\t**/\n\tRawNative;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\n/**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n**/\n#if flash\n@:notNull\n#end\nabstract Int64(__Int64) from __Int64 to __Int64 {\n\tprivate inline function new(x:__Int64)\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make(high, low);\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make(high:Int32, low:Int32):Int64\n\t\treturn new Int64(new __Int64(high, low));\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt(x:Int):Int64\n\t\t#if lua return make((x : Int32) >> 31, (x : Int32)); #else return make(x >> 31, x); #end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt(x:Int64):Int {\n\t\tif (x.high != x.low >> 31)\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t@:deprecated('haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead')\n\tinline public static function is(val:Dynamic):Bool {\n\t\treturn isInt64(val);\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function isInt64(val:Dynamic):Bool\n\t\treturn Std.isOfType(val, __Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh(x:Int64):Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow(x:Int64):Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg(x:Int64):Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero(x:Int64):Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare(a:Int64, b:Int64):Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare(a:Int64, b:Int64):Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64):String\n\t\treturn x.toString();\n\n\tfunction toString():String {\n\t\tvar i:Int64 = cast this;\n\t\tif (i == 0)\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif (i.isNeg()) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten:Int64 = 10;\n\t\twhile (i != 0) {\n\t\t\tvar r = i.divMod(ten);\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif (neg)\n\t\t\tstr = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString(sParam:String):Int64 {\n\t\treturn Int64Helper.parseString(sParam);\n\t}\n\n\tpublic static inline function fromFloat(f:Float):Int64 {\n\t\treturn Int64Helper.fromFloat(f);\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod(dividend:Int64, divisor:Int64):{quotient:Int64, modulus:Int64} {\n\t\t// Handle special cases of 0 and 1\n\t\tif (divisor.high == 0) {\n\t\t\tswitch (divisor.low) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow \"divide by zero\";\n\t\t\t\tcase 1:\n\t\t\t\t\treturn {quotient: dividend.copy(), modulus: 0};\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient:Int64 = 0;\n\t\tvar mask:Int64 = 1;\n\n\t\twhile (!divisor.isNeg()) {\n\t\t\tvar cmp = ucompare(divisor, modulus);\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif (cmp >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (mask != 0) {\n\t\t\tif (ucompare(modulus, divisor) >= 0) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif (divSign)\n\t\t\tquotient = -quotient;\n\t\tif (dividend.isNeg())\n\t\t\tmodulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient: quotient,\n\t\t\tmodulus: modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg(x:Int64):Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif (low == 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(++A) private inline function preIncrement():Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif (this.low == 0)\n\t\t\tthis.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement():Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int64 {\n\t\tthis = copy();\n\t\tif (this.low == 0)\n\t\t\tthis.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement():Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif (Int32.ucompare(low, a.low) < 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int64, b:Int):Int64\n\t\treturn add(a, b);\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif (Int32.ucompare(a.low, b.low) < 0)\n\t\t\thigh--;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A - B) private static inline function subInt(a:Int64, b:Int):Int64\n\t\treturn sub(a, b);\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int64):Int64\n\t\treturn sub(a, b);\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B)\n\tpublic static #if !lua inline #end function mul(a:Int64, b:Int64):Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif (Int32.ucompare(low, p01) < 0)\n\t\t\thigh++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif (Int32.ucompare(low, p10) < 0)\n\t\t\thigh++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int64, b:Int):Int64\n\t\treturn mul(a, b);\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt(a:Int64, b:Int):Int64\n\t\treturn div(a, b);\n\n\t@:op(A / B) private static inline function intDiv(a:Int, b:Int64):Int64\n\t\treturn div(a, b).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt(a:Int64, b:Int):Int64\n\t\treturn mod(a, b).toInt();\n\n\t@:op(A % B) private static inline function intMod(a:Int, b:Int64):Int64\n\t\treturn mod(a, b).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq(a:Int64, b:Int64):Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt(a:Int64, b:Int):Bool\n\t\treturn eq(a, b);\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq(a:Int64, b:Int64):Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt(a:Int64, b:Int):Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt(a:Int64, b:Int):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt(a:Int, b:Int64):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt(a:Int64, b:Int):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte(a:Int, b:Int64):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt(a:Int64, b:Int):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt(a:Int, b:Int64):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A >= B) private static inline function gte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt(a:Int64, b:Int):Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte(a:Int, b:Int64):Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement(a:Int64):Int64\n\t\treturn make(~a.high, ~a.low);\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and(a:Int64, b:Int64):Int64\n\t\treturn make(a.high & b.high, a.low & b.low);\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or(a:Int64, b:Int64):Int64\n\t\treturn make(a.high | b.high, a.low | b.low);\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor(a:Int64, b:Int64):Int64\n\t\treturn make(a.high ^ b.high, a.low ^ b.low);\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make((a.high << b) | (a.low >>> (32 - b)), a.low << b) else make(a.low << (b - 32), 0);\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >> b, (a.high << (32 - b)) | (a.low >>> b)); else make(a.high >> 31, a.high >> (b - 32));\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >>> b, (a.high << (32 - b)) | (a.low >>> b)); else make(0, a.high >>> (b - 32));\n\t}\n\n\tpublic var high(get, never):Int32;\n\n\tprivate inline function get_high()\n\t\treturn this.high;\n\n\tprivate inline function set_high(x)\n\t\treturn this.high = x;\n\n\tpublic var low(get, never):Int32;\n\n\tprivate inline function get_low()\n\t\treturn this.low;\n\n\tprivate inline function set_low(x)\n\t\treturn this.low = x;\n}\n\n/**\n\tThis typedef will fool `@:coreApi` into thinking that we are using\n\tthe same underlying type, even though it might be different on\n\tspecific platforms.\n**/\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high:Int32;\n\tpublic var low:Int32;\n\n\tpublic inline function new(high, low) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling `Std.string`. This tends not to happen when\n\t\t`toString` is only in the abstract.\n\t**/\n\tpublic function toString():String\n\t\treturn Int64.toStr(cast this);\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n"]}