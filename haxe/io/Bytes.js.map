{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Bytes.js.map","sources":["../../../../../../../haxe/versions/4.0.0/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/Int64.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/haxe/io/Bytes.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\n/**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n**/\n#if flash\n@:notNull\n#end\nabstract Int64(__Int64) from __Int64 to __Int64 {\n\tprivate inline function new(x:__Int64)\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make(high, low);\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make(high:Int32, low:Int32):Int64\n\t\treturn new Int64(new __Int64(high, low));\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt(x:Int):Int64\n\t\t#if lua return make((x : Int32) >> 31, (x : Int32)); #else return make(x >> 31, x); #end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt(x:Int64):Int {\n\t\tif (x.high != x.low >> 31)\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function is(val:Dynamic):Bool\n\t\treturn Std.is(val, __Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh(x:Int64):Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow(x:Int64):Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg(x:Int64):Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero(x:Int64):Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare(a:Int64, b:Int64):Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare(a:Int64, b:Int64):Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64):String\n\t\treturn x.toString();\n\n\t#if as3 public #else private #end function toString():String {\n\t\tvar i:Int64 = cast this;\n\t\tif (i == 0)\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif (i.isNeg()) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten:Int64 = 10;\n\t\twhile (i != 0) {\n\t\t\tvar r = i.divMod(ten);\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif (neg)\n\t\t\tstr = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString(sParam:String):Int64 {\n\t\treturn Int64Helper.parseString(sParam);\n\t}\n\n\tpublic static inline function fromFloat(f:Float):Int64 {\n\t\treturn Int64Helper.fromFloat(f);\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod(dividend:Int64, divisor:Int64):{quotient:Int64, modulus:Int64} {\n\t\t// Handle special cases of 0 and 1\n\t\tif (divisor.high == 0) {\n\t\t\tswitch (divisor.low) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow \"divide by zero\";\n\t\t\t\tcase 1:\n\t\t\t\t\treturn {quotient: dividend.copy(), modulus: 0};\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient:Int64 = 0;\n\t\tvar mask:Int64 = 1;\n\n\t\twhile (!divisor.isNeg()) {\n\t\t\tvar cmp = ucompare(divisor, modulus);\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif (cmp >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (mask != 0) {\n\t\t\tif (ucompare(modulus, divisor) >= 0) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif (divSign)\n\t\t\tquotient = -quotient;\n\t\tif (dividend.isNeg())\n\t\t\tmodulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient: quotient,\n\t\t\tmodulus: modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg(x:Int64):Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif (low == 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(++A) private inline function preIncrement():Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif (this.low == 0)\n\t\t\tthis.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement():Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int64 {\n\t\tthis = copy();\n\t\tif (this.low == 0)\n\t\t\tthis.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement():Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif (Int32.ucompare(low, a.low) < 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int64, b:Int):Int64\n\t\treturn add(a, b);\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif (Int32.ucompare(a.low, b.low) < 0)\n\t\t\thigh--;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A - B) private static inline function subInt(a:Int64, b:Int):Int64\n\t\treturn sub(a, b);\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int64):Int64\n\t\treturn sub(a, b);\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B)\n\tpublic static #if !lua inline #end function mul(a:Int64, b:Int64):Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif (Int32.ucompare(low, p01) < 0)\n\t\t\thigh++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif (Int32.ucompare(low, p10) < 0)\n\t\t\thigh++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int64, b:Int):Int64\n\t\treturn mul(a, b);\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt(a:Int64, b:Int):Int64\n\t\treturn div(a, b);\n\n\t@:op(A / B) private static inline function intDiv(a:Int, b:Int64):Int64\n\t\treturn div(a, b).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt(a:Int64, b:Int):Int64\n\t\treturn mod(a, b).toInt();\n\n\t@:op(A % B) private static inline function intMod(a:Int, b:Int64):Int64\n\t\treturn mod(a, b).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq(a:Int64, b:Int64):Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt(a:Int64, b:Int):Bool\n\t\treturn eq(a, b);\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq(a:Int64, b:Int64):Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt(a:Int64, b:Int):Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt(a:Int64, b:Int):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt(a:Int, b:Int64):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt(a:Int64, b:Int):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte(a:Int, b:Int64):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt(a:Int64, b:Int):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt(a:Int, b:Int64):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A >= B) private static inline function gte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt(a:Int64, b:Int):Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte(a:Int, b:Int64):Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement(a:Int64):Int64\n\t\treturn make(~a.high, ~a.low);\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and(a:Int64, b:Int64):Int64\n\t\treturn make(a.high & b.high, a.low & b.low);\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or(a:Int64, b:Int64):Int64\n\t\treturn make(a.high | b.high, a.low | b.low);\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor(a:Int64, b:Int64):Int64\n\t\treturn make(a.high ^ b.high, a.low ^ b.low);\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make((a.high << b) | (a.low >>> (32 - b)), a.low << b) else make(a.low << (b - 32), 0);\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >> b, (a.high << (32 - b)) | (a.low >>> b)); else make(a.high >> 31, a.high >> (b - 32));\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >>> b, (a.high << (32 - b)) | (a.low >>> b)); else make(0, a.high >>> (b - 32));\n\t}\n\n\tpublic var high(get, never):Int32;\n\n\tprivate inline function get_high()\n\t\treturn this.high;\n\n\tprivate inline function set_high(x)\n\t\treturn this.high = x;\n\n\tpublic var low(get, never):Int32;\n\n\tprivate inline function get_low()\n\t\treturn this.low;\n\n\tprivate inline function set_low(x)\n\t\treturn this.low = x;\n}\n\n/**\n\tThis typedef will fool `@:coreApi` into thinking that we are using\n\tthe same underlying type, even though it might be different on\n\tspecific platforms.\n**/\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high:Int32;\n\tpublic var low:Int32;\n\n\tpublic inline function new(high, low) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling `Std.string`. This tends not to happen when\n\t\t`toString` is only in the abstract.\n\t**/\n\tpublic function toString():String\n\t\treturn Int64.toStr(cast this);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) __js__(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) __js__(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n"]}