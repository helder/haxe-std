{"sourceRoot":"","names":[],"mappings":"QAkdQ;;;;;;ACtbR;QAwGC,cCxEmC,SAfA;QDmInC,cCnImC,SAeA;QDyJnC,iBCzJmC,uBAfA;;;;;;;QD8NnC,eC9NmC,SFqa5B","version":3,"file":"FPHelper.d.ts.map","sources":["../../../../../../../haxe/versions/4.2.1/std/haxe/Int64.hx","../../../../../../../haxe/versions/4.2.1/std/haxe/io/FPHelper.hx","../../../../../../../haxe/versions/4.2.1/std/StdTypes.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nusing haxe.Int64;\n\n/**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n**/\n#if flash\n@:notNull\n#end\n@:transitive\nabstract Int64(__Int64) from __Int64 to __Int64 {\n\tprivate inline function new(x:__Int64)\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make(high, low);\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make(high:Int32, low:Int32):Int64\n\t\treturn new Int64(new __Int64(high, low));\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt(x:Int):Int64\n\t\t#if lua return make((x : Int32) >> 31, (x : Int32)); #else return make(x >> 31, x); #end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt(x:Int64):Int {\n\t\tif (x.high != x.low >> 31)\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t@:deprecated('haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead')\n\tinline public static function is(val:Dynamic):Bool {\n\t\treturn isInt64(val);\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function isInt64(val:Dynamic):Bool\n\t\treturn Std.isOfType(val, __Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh(x:Int64):Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow(x:Int64):Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg(x:Int64):Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero(x:Int64):Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare(a:Int64, b:Int64):Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare(a:Int64, b:Int64):Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if (v != 0) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64):String\n\t\treturn x.toString();\n\n\tfunction toString():String {\n\t\tvar i:Int64 = cast this;\n\t\tif (i == 0)\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif (i.isNeg()) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten:Int64 = 10;\n\t\twhile (i != 0) {\n\t\t\tvar r = i.divMod(ten);\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif (neg)\n\t\t\tstr = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString(sParam:String):Int64 {\n\t\treturn Int64Helper.parseString(sParam);\n\t}\n\n\tpublic static inline function fromFloat(f:Float):Int64 {\n\t\treturn Int64Helper.fromFloat(f);\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod(dividend:Int64, divisor:Int64):{quotient:Int64, modulus:Int64} {\n\t\t// Handle special cases of 0 and 1\n\t\tif (divisor.high == 0) {\n\t\t\tswitch (divisor.low) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthrow \"divide by zero\";\n\t\t\t\tcase 1:\n\t\t\t\t\treturn {quotient: dividend.copy(), modulus: 0};\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient:Int64 = 0;\n\t\tvar mask:Int64 = 1;\n\n\t\twhile (!divisor.isNeg()) {\n\t\t\tvar cmp = ucompare(divisor, modulus);\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif (cmp >= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\twhile (mask != 0) {\n\t\t\tif (ucompare(modulus, divisor) >= 0) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif (divSign)\n\t\t\tquotient = -quotient;\n\t\tif (dividend.isNeg())\n\t\t\tmodulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient: quotient,\n\t\t\tmodulus: modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg(x:Int64):Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif (low == 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(++A) private inline function preIncrement():Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif (this.low == 0)\n\t\t\tthis.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement():Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement():Int64 {\n\t\tthis = copy();\n\t\tif (this.low == 0)\n\t\t\tthis.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement():Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif (Int32.ucompare(low, a.low) < 0)\n\t\t\thigh++;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt(a:Int64, b:Int):Int64\n\t\treturn add(a, b);\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub(a:Int64, b:Int64):Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif (Int32.ucompare(a.low, b.low) < 0)\n\t\t\thigh--;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A - B) private static inline function subInt(a:Int64, b:Int):Int64\n\t\treturn sub(a, b);\n\n\t@:op(A - B) private static inline function intSub(a:Int, b:Int64):Int64\n\t\treturn sub(a, b);\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B)\n\tpublic static #if !lua inline #end function mul(a:Int64, b:Int64):Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif (Int32.ucompare(low, p01) < 0)\n\t\t\thigh++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif (Int32.ucompare(low, p10) < 0)\n\t\t\thigh++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make(high, low);\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt(a:Int64, b:Int):Int64\n\t\treturn mul(a, b);\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt(a:Int64, b:Int):Int64\n\t\treturn div(a, b);\n\n\t@:op(A / B) private static inline function intDiv(a:Int, b:Int64):Int64\n\t\treturn div(a, b).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod(a:Int64, b:Int64):Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt(a:Int64, b:Int):Int64\n\t\treturn mod(a, b).toInt();\n\n\t@:op(A % B) private static inline function intMod(a:Int, b:Int64):Int64\n\t\treturn mod(a, b).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq(a:Int64, b:Int64):Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt(a:Int64, b:Int):Bool\n\t\treturn eq(a, b);\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq(a:Int64, b:Int64):Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt(a:Int64, b:Int):Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt(a:Int64, b:Int):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt(a:Int, b:Int64):Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt(a:Int64, b:Int):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte(a:Int, b:Int64):Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt(a:Int64, b:Int):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt(a:Int, b:Int64):Bool\n\t\treturn gt(a, b);\n\n\t@:op(A >= B) private static inline function gte(a:Int64, b:Int64):Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt(a:Int64, b:Int):Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte(a:Int, b:Int64):Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement(a:Int64):Int64\n\t\treturn make(~a.high, ~a.low);\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and(a:Int64, b:Int64):Int64\n\t\treturn make(a.high & b.high, a.low & b.low);\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or(a:Int64, b:Int64):Int64\n\t\treturn make(a.high | b.high, a.low | b.low);\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor(a:Int64, b:Int64):Int64\n\t\treturn make(a.high ^ b.high, a.low ^ b.low);\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make((a.high << b) | (a.low >>> (32 - b)), a.low << b) else make(a.low << (b - 32), 0);\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >> b, (a.high << (32 - b)) | (a.low >>> b)); else make(a.high >> 31, a.high >> (b - 32));\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr(a:Int64, b:Int):Int64 {\n\t\tb &= 63;\n\t\treturn if (b == 0) a.copy() else if (b < 32) make(a.high >>> b, (a.high << (32 - b)) | (a.low >>> b)); else make(0, a.high >>> (b - 32));\n\t}\n\n\tpublic var high(get, never):Int32;\n\n\tprivate inline function get_high()\n\t\treturn this.high;\n\n\tprivate inline function set_high(x)\n\t\treturn this.high = x;\n\n\tpublic var low(get, never):Int32;\n\n\tprivate inline function get_low()\n\t\treturn this.low;\n\n\tprivate inline function set_low(x)\n\t\treturn this.low = x;\n}\n\n/**\n\tThis typedef will fool `@:coreApi` into thinking that we are using\n\tthe same underlying type, even though it might be different on\n\tspecific platforms.\n**/\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high:Int32;\n\tpublic var low:Int32;\n\n\tpublic inline function new(high, low) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling `Std.string`. This tends not to happen when\n\t\t`toString` is only in the abstract.\n\t**/\n\tpublic function toString():String\n\t\treturn Int64.toStr(cast this);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new sys.thread.Tls<Int64>();\n\t#elseif !(java || cs || cpp)\n\tstatic var i64tmp = Int64.ofInt(0);\n\n\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\n\tstatic inline function _i32ToFloat(i:Int):Float {\n\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\tvar e = (i >> 23) & 0xff;\n\t\tif (e == 255)\n\t\t\treturn i & 0x7fffff == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = e == 0 ? (i & 0x7fffff) << 1 : (i & 0x7fffff) | 0x800000;\n\t\treturn sign * m * Math.pow(2, e - 150);\n\t}\n\n\tstatic inline function _i64ToDouble(lo:Int, hi:Int):Float {\n\t\tvar sign = 1 - ((hi >>> 31) << 1);\n\t\tvar e = (hi >> 20) & 0x7ff;\n\t\tif (e == 2047)\n\t\t\treturn lo == 0 && (hi & 0xFFFFF) == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = 2.220446049250313e-16 * ((hi & 0xFFFFF) * 4294967296. + (lo >>> 31) * 2147483648. + (lo & 0x7FFFFFFF));\n\t\tm = e == 0 ? m * 2.0 : m + 1.0;\n\t\treturn sign * m * Math.pow(2, e - 1023);\n\t}\n\n\tstatic inline function _floatToI32(f:Float):Int {\n\t\tif (f == 0)\n\t\t\treturn 0;\n\t\tvar af = f < 0 ? -f : f;\n\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\tif (exp > 127) {\n\t\t\treturn 0x7F800000;\n\t\t} else {\n\t\t\tif (exp <= -127) {\n\t\t\t\texp = -127;\n\t\t\t\taf *= 7.1362384635298e+44; // af * 0.5 * 0x800000 / Math.pow(2, -127)\n\t\t\t} else {\n\t\t\t\taf = (af / Math.pow(2, exp) - 1.0) * 0x800000;\n\t\t\t}\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | Math.round(af);\n\t\t}\n\t}\n\n\tstatic inline function _doubleToI64(v:Float):Int64@:privateAccess {\n\t\tvar i64 = i64tmp;\n\t\tif (v == 0) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(0);\n\t\t} else if (!Math.isFinite(v)) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(v > 0 ? 0x7FF00000 : 0xFFF00000);\n\t\t} else {\n\t\t\tvar av = v < 0 ? -v : v;\n\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\tif (exp > 1023) {\n\t\t\t\ti64.set_low(0xFFFFFFFF);\n\t\t\t\ti64.set_high(0x7FEFFFFF);\n\t\t\t} else {\n\t\t\t\tif (exp <= -1023) {\n\t\t\t\t\texp = -1023;\n\t\t\t\t\tav = av / 2.2250738585072014e-308;\n\t\t\t\t} else {\n\t\t\t\t\tav = av / Math.pow(2, exp) - 1.0;\n\t\t\t\t}\n\t\t\t\tvar sig = Math.fround(av * 4503599627370496.); // 2^52\n\t\t\t\t// Note: If \"sig\" is outside of the signed Int32 range, the result is unspecified in HL, C#, Java and Neko,\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\ti64.set_low(sig_l);\n\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t}\n\t\t}\n\t\treturn i64;\n\t}\n\t#end\n\n\t#if neko\n\t#if neko_v21\n\tstatic var helpers = new sys.thread.Tls<neko.NativeArray<Dynamic>>();\n\t#else\n\tstatic var helperf = new sys.thread.Tls<neko.NativeString>();\n\tstatic var helperd = new sys.thread.Tls<neko.NativeString>();\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\tstatic var _float_bytes = neko.Lib.load(\"std\", \"float_bytes\", 2);\n\tstatic var _double_bytes = neko.Lib.load(\"std\", \"double_bytes\", 2);\n\t#end\n\t#elseif flash\n\tstatic var helper = {\n\t\tvar b = new flash.utils.ByteArray();\n\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\tb;\n\t}\n\t#elseif js\n\tstatic var helper = new js.lib.DataView(new js.lib.ArrayBuffer(8));\n\t#end\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i32ToFloat(i:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itof(i, false);\n\t\t#else\n\t\tvar helper = helperf.value;\n\t\tif (helper == null)\n\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\tuntyped $sset(helper, 0, i & 0xFF);\n\t\tuntyped $sset(helper, 1, (i >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (i >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, i >>> 24);\n\t\treturn _float_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = i;\n\t\t} else {\n\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(i);\n\t\thelper.position = 0;\n\t\treturn helper.readFloat();\n\t\t#elseif js\n\t\thelper.setInt32(0, i, true);\n\t\treturn helper.getFloat32(0, true);\n\t\t#else\n\t\treturn _i32ToFloat(i);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function floatToI32(f:Float):Int {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $ftoi(f, false);\n\t\t#else\n\t\tvar r = _float_bytes(f, false);\n\t\treturn untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(f);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeFloat(f);\n\t\thelper.position = 0;\n\t\treturn helper.readUnsignedInt();\n\t\t#elseif js\n\t\thelper.setFloat32(0, f, true);\n\t\treturn helper.getInt32(0, true);\n\t\t#else\n\t\treturn _floatToI32(f);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i64ToDouble(low:Int, high:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itod(low, high, false);\n\t\t#else\n\t\tvar helper = helperd.value;\n\t\tif (helper == null)\n\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\tuntyped $sset(helper, 0, low & 0xFF);\n\t\tuntyped $sset(helper, 1, (low >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (low >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, low >>> 24);\n\t\tuntyped $sset(helper, 4, high & 0xFF);\n\t\tuntyped $sset(helper, 5, (high >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 6, (high >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 7, high >>> 24);\n\t\treturn _double_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low, high);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = haxe.Int64.make(high, low);\n\t\t} else {\n\t\t\tvar i1 = high, i2 = low;\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\thelper.i = haxe.Int64.make(j1, j2);\n\t\t}\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.longBitsToDouble(Int64.make(high, low));\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(low);\n\t\thelper.writeUnsignedInt(high);\n\t\thelper.position = 0;\n\t\treturn helper.readDouble();\n\t\t#elseif js\n\t\thelper.setInt32(0, low, true);\n\t\thelper.setInt32(4, high, true);\n\t\treturn helper.getFloat64(0, true);\n\t\t#else\n\t\treturn _i64ToDouble(low, high);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64(v:Float):Int64 {\n\t\t#if neko\n\t\t#if neko_v21\n\t\tvar helper = helpers.value;\n\t\tif (helper == null) {\n\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t}\n\t\tvar i64:haxe.Int64 = helper[1], int2 = helper[0];\n\t\tuntyped $dtoi(v, int2, false);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(int2[0]);\n\t\t\ti64.set_high(int2[1]);\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\tvar r = _double_bytes(v, false), i64 = i64tmp.value;\n\t\tif (i64 == null)\n\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24));\n\t\t\ti64.set_high(untyped $sget(r, 4) | ($sget(r, 5) << 8) | ($sget(r, 6) << 16) | ($sget(r, 7) << 24));\n\t\t}\n\t\treturn i64;\n\t\t#end\n\t\t#elseif cpp\n\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\tuntyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v));\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(v);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\tvar i1 = haxe.Int64.getHigh(i), i2 = haxe.Int64.getLow(i);\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\treturn haxe.Int64.make(j1, j2);\n\t\t}\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeDouble(v);\n\t\thelper.position = 0;\n\t\tvar i64 = i64tmp;\n\t\t@:privateAccess {\n\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t}\n\t\treturn i64;\n\t\t#elseif js\n\t\tvar i64 = i64tmp;\n\t\thelper.setFloat64(0, v, true);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(helper.getInt32(0, true));\n\t\t\ti64.set_high(helper.getInt32(4, true));\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\treturn _doubleToI64(v);\n\t\t#end\n\t}\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single) {\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float) {\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n// standard Haxe types\n\n/**\n\tThe standard `Void` type. Only `null` values can be of the type `Void`.\n\n\t@see https://haxe.org/manual/types-void.html\n**/\n#if jvm\n@:runtimeValue\n#end\n@:coreType abstract Void {}\n\n/**\n\tThe standard `Float` type, this is a double-precision IEEE 64bit float.\n\n\tOn static targets, `null` cannot be assigned to Float. If this is necessary,\n\t`Null<Float>` can be used instead.\n\n\t`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n\t`Std.parseFloat` converts a `String` to a `Float`.\n\n\t@see https://haxe.org/manual/types-basic-types.html\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:coreType @:notNull @:runtimeValue abstract Float {}\n\n/**\n\tThe standard `Int` type. Its precision depends on the platform.\n\n\tOn static targets, `null` cannot be assigned to `Int`. If this is necessary,\n\t`Null<Int>` can be used instead.\n\n\t`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n\t`Std.parseInt` converts a `String` to an `Int`.\n\n\t@see https://haxe.org/manual/types-basic-types.html\n\t@see https://haxe.org/manual/std-math-integer-math.html\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:coreType @:notNull @:runtimeValue abstract Int to Float {}\n\n#if (java || cs || hl || cpp)\n/**\n\tSingle-precision IEEE 32bit float (4-byte).\n**/\n@:coreType @:notNull @:runtimeValue abstract Single to Float from Float {}\n#end\n\n/**\n\t`Null<T>` is a wrapper that can be used to make the basic types `Int`,\n\t`Float` and `Bool` nullable on static targets.\n\n\tIf null safety is enabled, only types wrapped in `Null<T>` are nullable.\n\n\tOtherwise, it has no effect on non-basic-types, but it can be useful as a way to document\n\tthat `null` is an acceptable value for a method argument, return value or variable.\n\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:forward\n@:coreType\nabstract Null<T> from T to T {}\n\n/**\n\tThe standard Boolean type, which can either be `true` or `false`.\n\n\tOn static targets, `null` cannot be assigned to `Bool`. If this is necessary,\n\t`Null<Bool>` can be used instead.\n\n\t@see https://haxe.org/manual/types-bool.html\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:coreType @:notNull @:runtimeValue abstract Bool {}\n\n/**\n\t`Dynamic` is a special type which is compatible with all other types.\n\n\tUse of `Dynamic` should be minimized as it prevents several compiler\n\tchecks and optimizations. See `Any` type for a safer alternative for\n\trepresenting values of any type.\n\n\t@see https://haxe.org/manual/types-dynamic.html\n**/\n@:coreType @:runtimeValue abstract Dynamic<T> {}\n\n/**\n\tAn `Iterator` is a structure that permits iteration over elements of type `T`.\n\n\tAny class with matching `hasNext()` and `next()` fields is considered an `Iterator`\n\tand can then be used e.g. in `for`-loops. This makes it easy to implement\n\tcustom iterators.\n\n\t@see https://haxe.org/manual/lf-iterators.html\n**/\ntypedef Iterator<T> = {\n\t/**\n\t\tReturns `false` if the iteration is complete, `true` otherwise.\n\n\t\tUsually iteration is considered to be complete if all elements of the\n\t\tunderlying data structure were handled through calls to `next()`. However,\n\t\tin custom iterators any logic may be used to determine the completion\n\t\tstate.\n\t**/\n\tfunction hasNext():Bool;\n\n\t/**\n\t\tReturns the current item of the `Iterator` and advances to the next one.\n\n\t\tThis method is not required to check `hasNext()` first. A call to this\n\t\tmethod while `hasNext()` is `false` yields unspecified behavior.\n\n\t\tOn the other hand, iterators should not require a call to `hasNext()`\n\t\tbefore the first call to `next()` if an element is available.\n\t**/\n\tfunction next():T;\n}\n\n/**\n\tAn `Iterable` is a data structure which has an `iterator()` method.\n\tSee `Lambda` for generic functions on iterable structures.\n\n\t@see https://haxe.org/manual/lf-iterators.html\n**/\ntypedef Iterable<T> = {\n\tfunction iterator():Iterator<T>;\n}\n\n/**\n\tA `KeyValueIterator` is an `Iterator` that has a key and a value.\n**/\ntypedef KeyValueIterator<K, V> = Iterator<{key:K, value:V}>;\n\n/**\n\tA `KeyValueIterable` is a data structure which has a `keyValueIterator()`\n\tmethod to iterate over key-value-pairs.\n**/\ntypedef KeyValueIterable<K, V> = {\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n}\n\n/**\n\t`ArrayAccess` is used to indicate a class that can be accessed using brackets.\n\tThe type parameter represents the type of the elements stored.\n\n\tThis interface should be used for externs only. Haxe does not support custom\n\tarray access on classes. However, array access can be implemented for\n\tabstract types.\n\n\t@see https://haxe.org/manual/types-abstract-array-access.html\n**/\nextern interface ArrayAccess<T> {}\n"]}