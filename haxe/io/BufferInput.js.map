{"sourceRoot":"","names":[],"mappings":"QA+BA;QC1BA;ACmBA;;;CAMC,kBAAmC,eAAgB,GAAG,CACrD;WAAS,EACT;aAAW,IACX;aAAW,IACX;mBAAiB;;CAGlB,SAAyB,CACxB;KAAI,YAAM,GAAG,CACZ;iBAAS,GAAG,UAAK,UAAK,gBACtB;cAAM;IAEP;oBAAa,iBAAY,UAAK,gBAAW,kBAAa;;CAGvD,WAA6B,CAC5B;KAAI,mBAAa,GAChB;;IACD;UAAQ,WAAQ,UAChB;aACA;mBACA;EAAO;;CAGR,yBAAiE,CAChE;KAAI,mBAAa,GAChB;;IACD;aAAW,AAAI,OAAM,kBAAW,iBAAe,IAC/C;WAAS,KAAK,UAAU,UAAU,MAClC;cAAY,KACZ;oBAAkB,KAClB;EAAO","version":3,"file":"BufferInput.js.map","sources":["../../../../../../../haxe/versions/4.0.0/std/haxe/io/Input.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/io/BufferInput.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte():Int {\n\t\t#if cpp\n\t\tthrow \"Not implemented\";\n\t\t#else\n\t\treturn throw \"Not implemented\";\n\t\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile (k > 0) {\n\t\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b, pos, readByte());\n\t\t\t\t#elseif php\n\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof:haxe.io.Eof) {}\n\t\treturn len - k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close():Void {}\n\n\tfunction set_bigEndian(b:Bool):Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll(?bufsize:Int):Bytes {\n\t\tif (bufsize == null)\n\t\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf, 0, len);\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes(s:Bytes, pos:Int, len:Int):Void {\n\t\twhile (len > 0) {\n\t\t\tvar k = readBytes(s, pos, len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read(nbytes:Int):Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile (nbytes > 0) {\n\t\t\tvar k = readBytes(s, p, nbytes);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil(end:Int):String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\twhile ((last = readByte()) != end)\n\t\t\tbuf.addByte(last);\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine():String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile ((last = readByte()) != 10)\n\t\t\t\tbuf.addByte(last);\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.charCodeAt(s.length - 1) == 13)\n\t\t\t\ts = s.substr(0, -1);\n\t\t} catch (e:Eof) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.length == 0)\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat():Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble():Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2, i1) : FPHelper.i64ToDouble(i1, i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8():Int {\n\t\tvar n = readByte();\n\t\tif (n >= 128)\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif (n & 0x8000 != 0)\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif (n & 0x800000 != 0)\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n\t\t#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn (n | 0x80000000);\n\t\telse\n\t\t\treturn n;\n\t\t#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clampInt32(n);\n\t\t#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\t#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString(len:Int, ?encoding:Encoding):String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b, 0, len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tInput.prototype.bigEndian = false;\n\t\t}\n\t#end\n\n\t#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>) {\n\t\treturn (((bytes[1] & 0xF) << 16) | (bytes[2] << 8) | bytes[3]) * 4294967296.\n\t\t\t+ (bytes[4] >> 7) * 2147483648\n\t\t\t+ (((bytes[4] & 0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n\t#end\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\nclass BufferInput extends haxe.io.Input {\n\tpublic var i:haxe.io.Input;\n\tpublic var buf:haxe.io.Bytes;\n\tpublic var available:Int;\n\tpublic var pos:Int;\n\n\tpublic function new(i, buf, ?pos = 0, ?available = 0) {\n\t\tthis.i = i;\n\t\tthis.buf = buf;\n\t\tthis.pos = pos;\n\t\tthis.available = available;\n\t}\n\n\tpublic function refill() {\n\t\tif (pos > 0) {\n\t\t\tbuf.blit(0, buf, pos, available);\n\t\t\tpos = 0;\n\t\t}\n\t\tavailable += i.readBytes(buf, available, buf.length - available);\n\t}\n\n\toverride function readByte() {\n\t\tif (available == 0)\n\t\t\trefill();\n\t\tvar c = buf.get(pos);\n\t\tpos++;\n\t\tavailable--;\n\t\treturn c;\n\t}\n\n\toverride function readBytes(buf:haxe.io.Bytes, pos:Int, len:Int) {\n\t\tif (available == 0)\n\t\t\trefill();\n\t\tvar size = if (len > available) available else len;\n\t\tbuf.blit(pos, this.buf, this.pos, size);\n\t\tthis.pos += size;\n\t\tthis.available -= size;\n\t\treturn size;\n\t}\n}\n"]}