{"sourceRoot":"","names":[],"mappings":"QA0BQ;QCER;QCDA;;QCFA;;QCaA;QCjCA;QCiBA;ACSA;;;;;;;;;;CAiBC;;;;YAIQ;QAAM;;CAWd;;;;;;;;wBAAyD,CACxD;UAAQ,IACR;UAAuC,IACvC;KAAI,OAAM,KAAK,MAAM,KAAK,MAAM,MAAM,UACrC;SAAM;IACP;MACC;SAAO,KAAI,GAAX,CAQC;MAAE,OAAO,AAAK,gBAEd;UACA;;;eAZF;;;gCAc0B;eAd1B;;;;IAeA;EAAO,aAAM;;CAQd;;;;;;SAA6B;;CAE7B,iBAAoC,CACnC;mBAAY,EACZ;EAAO;;CAUR;;;;;;;yBAA4C,CAC3C;KAAI,YAAW,MAId;aAAU;IAGX;YAAU,0BAAY,UACtB;cAAY,kBACZ;MACC;SAAO,OAAM,CACZ;cAAU,eAAU,KAAK,GAAG,SAC5B;OAAI,QAAO,GACV;WAAM;MACP;mBAAe,KAAK,GAAG;;aALzB;;;8BAOgB;aAPhB;;;;IAQA;EAAO;;CAQR;;;;;;4BACC;QAAO,OAAM,GAAb,CACC;WAAQ,eAAU,GAAG,KAAK,KAC1B;MAAI,MAAK,GACR;UAAM;KACP;UAAO,EACP;UAAO;;;CAOT;;;;cAAuC,CACtC;UAAQ,0BAAY,SACpB;UAAQ,EACR;QAAO,UAAS,GAAhB,CACC;WAAQ,eAAU,GAAG,GAAG,QACxB;MAAI,MAAK,GACR;UAAM;KACP;QAAK,EACL;aAAU;IAEX;EAAO;;CAQR;;;;;;gBAA0C,CACzC;YAAU,kBACV;WACA;gBAAO;GAAC,OAAO,gBAAf;MAAO,GAAC,QAAsB,MAA9B;;KACC;eAAY;IACb;EAAO;;CAQR;;;;;;YAAkC,CACjC;YAAU,kBACV;WACA;QACA;MAAI,CACH;iBAAO;IAAC,OAAO,gBAAf;OAAO,GAAC,QAAsB,KAA9B;;MACC;gBAAY;KACb;OAAI,0BACJ;MAAI,oBAAa,WAAW,MAAM,IACjC;QAAI,sBAAS,GAAG;;aALlB;;;8BAMgB,CACf;QAAI,0BACJ;OAAI,aAAY,GACiB;WAAW,cAT7C;;;;;IAWA;EAAO;;CAQR;;;;;;aACC;EAAO,2BAAoB;;CAQ5B;;;;;;cAAmC,CAClC;WAAS,iBACT;WAAS,iBACF;sBAAY;+BAAqB,IAAI;GAAM;+BAAqB,IAAI;;;CAM5E;;;;YAA+B,CAC9B;UAAQ,gBACR;KAAI,MAAK,KACR;GAAO,WAAI;IACZ;EAAO;;CAQR;;;;;;aAAgC,CAC/B;YAAU,gBACV;YAAU,gBACV;UAAQ,mBAAY,MAAM,AAAC,OAAO,IAAK,MAAM,AAAC,OAAO,EACrD;KAAI,MAAI,UAAU,GACjB;GAAO,WAAI;IACZ;EAAO;;CAQR;;;;;;cAAiC,CAChC;YAAU,gBACV;YAAU,gBACH;sBAAY;gBAAM,AAAC,OAAO;GAAK;gBAAM,AAAC,OAAO;;;CAQrD;;;;;;aAAgC,CAC/B;YAAU,gBACV;YAAU,gBACV;YAAU,gBACV;UAAQ,mBAAY,MAAM,AAAC,OAAO,IAAK,AAAC,OAAO,KAAM,MAAM,AAAC,OAAO,IAAK,AAAC,OAAO,GAChF;KAAI,MAAI,YAAY,GACnB;GAAO,WAAI;IACZ;EAAO;;CAQR;;;;;;cAAiC,CAChC;YAAU,gBACV;YAAU,gBACV;YAAU,gBACH;sBAAY;gBAAM,AAAC,OAAO,IAAK,AAAC,OAAO;GAAM;gBAAM,AAAC,OAAO,IAAK,AAAC,OAAO;;;CAQhF;;;;;;aAAgC,CAC/B;YAAU,gBACV;YAAU,gBACV;YAAU,gBACV;YAAU,gBAYH;sBAAY;gBAAM,AAAC,OAAO,IAAK,AAAC,OAAO,KAAM,AAAC,OAAO;GAAM;gBAAM,AAAC,OAAO,IAAK,AAAC,OAAO,KAAM,AAAC,OAAO;;;CAO5G;;;;kCAA+D,CAC9D;UAAQ,0BAAY,MACpB;qBAAc,GAAG,GAAG,KAIpB;EAAO,mBAAY,GAAG,KAAK;;CAe5B,oBACC;EAAO,QAAC,AAAC,CAAC,MAAM,KAAK,OAAQ,KAAM,AAAC,MAAM,MAAM,IAAK,MAAM,MAAM,cAC9D,CAAC,MAAM,MAAM,KAAK,aAClB,CAAC,AAAC,CAAC,MAAM,KAAK,QAAS,KAAM,AAAC,MAAM,MAAM,KAAM,AAAC,MAAM,MAAM,IAAK,MAAM","version":3,"file":"Input.js.map","sources":["../../../../../../../haxe/versions/4.0.0/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/io/FPHelper.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/CallStack.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.0/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.0.0/std/haxe/io/Input.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new sys.thread.Tls<Int64>();\n\t#elseif !(java || cs || cpp)\n\tstatic var i64tmp = Int64.ofInt(0);\n\n\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\n\tstatic inline function _i32ToFloat(i:Int):Float {\n\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\tvar e = (i >> 23) & 0xff;\n\t\tif (e == 255)\n\t\t\treturn i & 0x7fffff == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = e == 0 ? (i & 0x7fffff) << 1 : (i & 0x7fffff) | 0x800000;\n\t\treturn sign * m * Math.pow(2, e - 150);\n\t}\n\n\tstatic inline function _i64ToDouble(lo:Int, hi:Int):Float {\n\t\tvar sign = 1 - ((hi >>> 31) << 1);\n\t\tvar e = (hi >> 20) & 0x7ff;\n\t\tif (e == 2047)\n\t\t\treturn lo == 0 && (hi & 0xFFFFF) == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = 2.220446049250313e-16 * ((hi & 0xFFFFF) * 4294967296. + (lo >>> 31) * 2147483648. + (lo & 0x7FFFFFFF));\n\t\tm = e == 0 ? m * 2.0 : m + 1.0;\n\t\treturn sign * m * Math.pow(2, e - 1023);\n\t}\n\n\tstatic inline function _floatToI32(f:Float):Int {\n\t\tif (f == 0)\n\t\t\treturn 0;\n\t\tvar af = f < 0 ? -f : f;\n\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\tif (exp > 127) {\n\t\t\treturn 0x7F800000;\n\t\t} else {\n\t\t\tif (exp <= -127) {\n\t\t\t\texp = -127;\n\t\t\t\taf *= 7.1362384635298e+44; // af * 0.5 * 0x800000 / Math.pow(2, -127)\n\t\t\t} else {\n\t\t\t\taf = (af / Math.pow(2, exp) - 1.0) * 0x800000;\n\t\t\t}\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | Math.round(af);\n\t\t}\n\t}\n\n\tstatic inline function _doubleToI64(v:Float):Int64@:privateAccess {\n\t\tvar i64 = i64tmp;\n\t\tif (v == 0) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(0);\n\t\t} else if (!Math.isFinite(v)) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(v > 0 ? 0x7FF00000 : 0xFFF00000);\n\t\t} else {\n\t\t\tvar av = v < 0 ? -v : v;\n\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\tif (exp > 1023) {\n\t\t\t\ti64.set_low(0xFFFFFFFF);\n\t\t\t\ti64.set_high(0x7FEFFFFF);\n\t\t\t} else {\n\t\t\t\tif (exp <= -1023) {\n\t\t\t\t\texp = -1023;\n\t\t\t\t\tav = av / 2.2250738585072014e-308;\n\t\t\t\t} else {\n\t\t\t\t\tav = av / Math.pow(2, exp) - 1.0;\n\t\t\t\t}\n\t\t\t\tvar sig = Math.fround(av * 4503599627370496.); // 2^52\n\t\t\t\t// Note: If \"sig\" is outside of the signed Int32 range, the result is unspecified in HL, C#, Java and Neko,\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\ti64.set_low(sig_l);\n\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t}\n\t\t}\n\t\treturn i64;\n\t}\n\t#end\n\n\t#if neko\n\t#if neko_v21\n\tstatic var helpers = new sys.thread.Tls<neko.NativeArray<Dynamic>>();\n\t#else\n\tstatic var helperf = new sys.thread.Tls<neko.NativeString>();\n\tstatic var helperd = new sys.thread.Tls<neko.NativeString>();\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\tstatic var _float_bytes = neko.Lib.load(\"std\", \"float_bytes\", 2);\n\tstatic var _double_bytes = neko.Lib.load(\"std\", \"double_bytes\", 2);\n\t#end\n\t#elseif flash\n\tstatic var helper = {\n\t\tvar b = new flash.utils.ByteArray();\n\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\tb;\n\t}\n\t#elseif js\n\tstatic var helper = new js.lib.DataView(new js.lib.ArrayBuffer(8));\n\t#end\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i32ToFloat(i:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itof(i, false);\n\t\t#else\n\t\tvar helper = helperf.value;\n\t\tif (helper == null)\n\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\tuntyped $sset(helper, 0, i & 0xFF);\n\t\tuntyped $sset(helper, 1, (i >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (i >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, i >>> 24);\n\t\treturn _float_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = i;\n\t\t} else {\n\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(i);\n\t\thelper.position = 0;\n\t\treturn helper.readFloat();\n\t\t#elseif js\n\t\thelper.setInt32(0, i, true);\n\t\treturn helper.getFloat32(0, true);\n\t\t#else\n\t\treturn _i32ToFloat(i);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function floatToI32(f:Float):Int {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $ftoi(f, false);\n\t\t#else\n\t\tvar r = _float_bytes(f, false);\n\t\treturn untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(f);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeFloat(f);\n\t\thelper.position = 0;\n\t\treturn helper.readUnsignedInt();\n\t\t#elseif js\n\t\thelper.setFloat32(0, f, true);\n\t\treturn helper.getInt32(0, true);\n\t\t#else\n\t\treturn _floatToI32(f);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i64ToDouble(low:Int, high:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itod(low, high, false);\n\t\t#else\n\t\tvar helper = helperd.value;\n\t\tif (helper == null)\n\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\tuntyped $sset(helper, 0, low & 0xFF);\n\t\tuntyped $sset(helper, 1, (low >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (low >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, low >>> 24);\n\t\tuntyped $sset(helper, 4, high & 0xFF);\n\t\tuntyped $sset(helper, 5, (high >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 6, (high >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 7, high >>> 24);\n\t\treturn _double_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low, high);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = haxe.Int64.make(high, low);\n\t\t} else {\n\t\t\tvar i1 = high, i2 = low;\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\thelper.i = haxe.Int64.make(j1, j2);\n\t\t}\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.longBitsToDouble(Int64.make(high, low));\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(low);\n\t\thelper.writeUnsignedInt(high);\n\t\thelper.position = 0;\n\t\treturn helper.readDouble();\n\t\t#elseif js\n\t\thelper.setInt32(0, low, true);\n\t\thelper.setInt32(4, high, true);\n\t\treturn helper.getFloat64(0, true);\n\t\t#else\n\t\treturn _i64ToDouble(low, high);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64(v:Float):Int64 {\n\t\t#if neko\n\t\t#if neko_v21\n\t\tvar helper = helpers.value;\n\t\tif (helper == null) {\n\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t}\n\t\tvar i64:haxe.Int64 = helper[1], int2 = helper[0];\n\t\tuntyped $dtoi(v, int2, false);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(int2[0]);\n\t\t\ti64.set_high(int2[1]);\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\tvar r = _double_bytes(v, false), i64 = i64tmp.value;\n\t\tif (i64 == null)\n\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24));\n\t\t\ti64.set_high(untyped $sget(r, 4) | ($sget(r, 5) << 8) | ($sget(r, 6) << 16) | ($sget(r, 7) << 24));\n\t\t}\n\t\treturn i64;\n\t\t#end\n\t\t#elseif cpp\n\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\tuntyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v));\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(v);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\tvar i1 = haxe.Int64.getHigh(i), i2 = haxe.Int64.getLow(i);\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\treturn haxe.Int64.make(j1, j2);\n\t\t}\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeDouble(v);\n\t\thelper.position = 0;\n\t\tvar i64 = i64tmp;\n\t\t@:privateAccess {\n\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t}\n\t\treturn i64;\n\t\t#elseif js\n\t\tvar i64 = i64tmp;\n\t\thelper.setFloat64(0, v, true);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(helper.getInt32(0, true));\n\t\t\ti64.set_high(helper.getInt32(4, true));\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\treturn _doubleToI64(v);\n\t\t#end\n\t}\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single) {\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float) {\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule(m:String);\n\tFilePos(s:Null<StackItem>, file:String, line:Int, ?column:Null<Int>);\n\tMethod(classname:Null<String>, method:String);\n\tLocalFunction(?v:Int);\n}\n\n/**\n\tGet information about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.lib.Error;\n\n\tstatic function getStack(e:js.lib.Error):Array<StackItem> {\n\t\tif (e == null)\n\t\t\treturn [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function(error, callsites:Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null)\n\t\t\t\t\tsite = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName:String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx + 1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar fileName:String = site.getFileName();\n\t\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\t\tfileName = fileName.substr(fileAddr + 6);\n\t\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t#if eval\n\tstatic function getCallStack() {\n\t\treturn [];\n\t}\n\n\tstatic function getExceptionStack() {\n\t\treturn [];\n\t}\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack():Array<StackItem> {\n\t\t#if neko\n\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\ta.shift(); // remove Stack.callStack()\n\t\treturn a;\n\t\t#elseif flash\n\t\tvar a = makeStack(new flash.errors.Error().getStackTrace());\n\t\ta.shift(); // remove Stack.callStack()\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\treturn makeStack(s);\n\t\t#elseif js\n\t\ttry {\n\t\t\tthrow new js.lib.Error();\n\t\t} catch (e:Dynamic) {\n\t\t\tvar a = getStack(js.Lib.getOriginalException());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t}\n\t\t#elseif java\n\t\tvar stack = [];\n\t\tfor (el in java.lang.Thread.currentThread().getStackTrace()) {\n\t\t\tvar className = el.getClassName();\n\t\t\tvar methodName = el.getMethodName();\n\t\t\tvar fileName = el.getFileName();\n\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\tvar method = Method(className, methodName);\n\t\t\tif (fileName != null || lineNumber >= 0) {\n\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t} else {\n\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t}\n\t\tstack.shift();\n\t\tstack.shift();\n\t\tstack.pop();\n\t\treturn stack;\n\t\t#elseif cs\n\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\tvar stack = [];\n\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\tinfos.pop();\n\t\tinfos.reverse();\n\t\tfor (elem in infos)\n\t\t\tstack.push(FilePos(Method(null, elem._3), elem._1, elem._2));\n\t\treturn stack;\n\t\t#elseif lua\n\t\tvar stack = [];\n\t\tvar infos = lua.Debug.traceback();\n\t\tvar luastack = infos.split(\"\\n\").slice(2, -1);\n\t\tfor (s in luastack) {\n\t\t\tvar parts = s.split(\":\");\n\t\t\tvar file = parts[0];\n\t\t\tvar line = parts[1];\n\t\t\tvar method = if(parts.length <= 2) {\n\t\t\t\tnull;\n\t\t\t} else {\n\t\t\t\tvar methodPos = parts[2].indexOf(\"'\");\n\t\t\t\tif(methodPos < 0) {\n\t\t\t\t\tnull;\n\t\t\t\t} else {\n\t\t\t\t\tMethod(null, parts[2].substring(methodPos + 1, parts[2].length - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.push(FilePos(method, file, Std.parseInt(line)));\n\t\t}\n\t\treturn stack;\n\t\t#elseif hl\n\t\ttry {\n\t\t\tthrow null;\n\t\t} catch (e:Dynamic) {\n\t\t\tvar st = _getExceptionStack();\n\t\t\treturn makeStack(st.length > 2 ? st.sub(2, st.length - 2) : st);\n\t\t}\n\t\t#elseif eval\n\t\treturn getCallStack();\n\t\t#else\n\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t#if hl\n\t@:hlNative(\"std\", \"exception_stack\") static function _getExceptionStack():hl.NativeArray<hl.Bytes> {\n\t\treturn null;\n\t}\n\t#end\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp\n\t@:noDebug /* Do not mess up the exception stack */\n\t#end\n\tpublic static function exceptionStack():Array<StackItem> {\n\t\t#if neko\n\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\treturn new Array();\n\t\t#elseif hl\n\t\treturn makeStack(_getExceptionStack());\n\t\t#elseif flash\n\t\tvar err:flash.errors.Error = untyped flash.Boot.lastError;\n\t\tif (err == null)\n\t\t\treturn new Array();\n\t\tvar a = makeStack(err.getStackTrace());\n\t\tvar c = callStack();\n\t\tvar i = c.length - 1;\n\t\twhile (i > 0) {\n\t\t\tif (Std.string(a[a.length - 1]) == Std.string(c[i]))\n\t\t\t\ta.pop();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\treturn makeStack(s);\n\t\t#elseif java\n\t\tvar stack = [];\n\t\tswitch (#if jvm jvm.Exception #else java.internal.Exceptions #end.currentException()) {\n\t\t\tcase null:\n\t\t\tcase current:\n\t\t\t\tfor (el in current.getStackTrace()) {\n\t\t\t\t\tvar className = el.getClassName();\n\t\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\t\tvar method = Method(className, methodName);\n\t\t\t\t\tif (fileName != null || lineNumber >= 0) {\n\t\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack.push(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn stack;\n\t\t#elseif cs\n\t\treturn cs.internal.Exceptions.exception == null ? [] : makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\tvar stack = [];\n\t\tvar exc = python.lib.Sys.exc_info();\n\t\tif (exc._3 != null) {\n\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(Method(null, elem._3), elem._1, elem._2));\n\t\t}\n\t\treturn stack;\n\t\t#elseif js\n\t\treturn getStack(lastException);\n\t\t#elseif eval\n\t\treturn getExceptionStack();\n\t\t#else\n\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString(stack:Array<StackItem>) {\n\t\tvar b = new StringBuf();\n\t\tfor (s in stack) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b, s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString(b:StringBuf, s) {\n\t\tswitch (s) {\n\t\t\tcase CFunction:\n\t\t\t\tb.add(\"a C function\");\n\t\t\tcase Module(m):\n\t\t\t\tb.add(\"module \");\n\t\t\t\tb.add(m);\n\t\t\tcase FilePos(s, file, line, col):\n\t\t\t\tif (s != null) {\n\t\t\t\t\titemToString(b, s);\n\t\t\t\t\tb.add(\" (\");\n\t\t\t\t}\n\t\t\t\tb.add(file);\n\t\t\t\tb.add(\" line \");\n\t\t\t\tb.add(line);\n\t\t\t\tif (col != null) {\n\t\t\t\t\tb.add(\" column \");\n\t\t\t\t\tb.add(col);\n\t\t\t\t}\n\t\t\t\tif (s != null)\n\t\t\t\t\tb.add(\")\");\n\t\t\tcase Method(cname, meth):\n\t\t\t\tb.add(cname == null ? \"<unknown>\" : cname);\n\t\t\t\tb.add(\".\");\n\t\t\t\tb.add(meth);\n\t\t\tcase LocalFunction(n):\n\t\t\t\tb.add(\"local function #\");\n\t\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp\n\t@:noDebug /* Do not mess up the exception stack */\n\t#end\n\tprivate static function makeStack(s #if cs:cs.system.diagnostics.StackTrace #elseif hl:hl.NativeArray<hl.Bytes> #else:Dynamic #end) {\n\t\t#if neko\n\t\tvar a = new Array();\n\t\tvar l = untyped __dollar__asize(s);\n\t\tvar i = 0;\n\t\twhile (i < l) {\n\t\t\tvar x = s[i++];\n\t\t\tif (x == null)\n\t\t\t\ta.unshift(CFunction);\n\t\t\telse if (untyped __dollar__typeof(x) == __dollar__tstring)\n\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\telse\n\t\t\t\ta.unshift(FilePos(null, new String(untyped x[0]), untyped x[1]));\n\t\t}\n\t\treturn a;\n\t\t#elseif flash\n\t\tvar a = new Array();\n\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\twhile (r.match(s)) {\n\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\tvar meth = r.matched(2);\n\t\t\tvar item;\n\t\t\tif (meth == null) {\n\t\t\t\tif (rlambda.match(cl))\n\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\telse\n\t\t\t\t\titem = Method(cl, \"new\");\n\t\t\t} else\n\t\t\t\titem = Method(cl, meth.substr(1));\n\t\t\tif (r.matched(3) != null)\n\t\t\t\titem = FilePos(item, r.matched(4), Std.parseInt(r.matched(5)));\n\t\t\ta.push(item);\n\t\t\ts = r.matchedRight();\n\t\t}\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar stack:Array<String> = s;\n\t\tvar m = new Array<StackItem>();\n\t\tfor (func in stack) {\n\t\t\tvar words = func.split(\"::\");\n\t\t\tif (words.length == 0)\n\t\t\t\tm.push(CFunction)\n\t\t\telse if (words.length == 2)\n\t\t\t\tm.push(Method(words[0], words[1]));\n\t\t\telse if (words.length == 4)\n\t\t\t\tm.push(FilePos(Method(words[0], words[1]), words[2], Std.parseInt(words[3])));\n\t\t}\n\t\treturn m;\n\t\t#elseif js\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (js.Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = s.split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\tfor (line in stack) {\n\t\t\t\tif (rie10.match(line)) {\n\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\tvar column = Std.parseInt(rie10.matched(4));\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t}\n\t\t\treturn m;\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t\t#elseif cs\n\t\tvar stack = [];\n\t\tfor (i in 0...s.FrameCount) {\n\t\t\tvar frame = s.GetFrame(i);\n\t\t\tvar m = frame.GetMethod();\n\n\t\t\tif (m == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\tvar fileName = frame.GetFileName();\n\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\telse\n\t\t\t\tstack.push(method);\n\t\t}\n\t\treturn stack;\n\t\t#elseif hl\n\t\tvar stack = [];\n\t\tvar r = ~/^([A-Za-z0-9.$_]+)\\.([~A-Za-z0-9_]+(\\.[0-9]+)?)\\((.+):([0-9]+)\\)$/;\n\t\tvar r_fun = ~/^fun\\$([0-9]+)\\((.+):([0-9]+)\\)$/;\n\t\tfor (i in 0...s.length - 1) {\n\t\t\tvar str = @:privateAccess String.fromUCS2(s[i]);\n\t\t\tif (r.match(str))\n\t\t\t\tstack.push(FilePos(Method(r.matched(1), r.matched(2)), r.matched(4), Std.parseInt(r.matched(5))));\n\t\t\telse if (r_fun.match(str))\n\t\t\t\tstack.push(FilePos(LocalFunction(Std.parseInt(r_fun.matched(1))), r_fun.matched(2), Std.parseInt(r_fun.matched(3))));\n\t\t\telse\n\t\t\t\tstack.push(Module(str));\n\t\t}\n\t\treturn stack;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) __js__(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) __js__(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte():Int {\n\t\t#if cpp\n\t\tthrow \"Not implemented\";\n\t\t#else\n\t\treturn throw \"Not implemented\";\n\t\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile (k > 0) {\n\t\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b, pos, readByte());\n\t\t\t\t#elseif php\n\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof:haxe.io.Eof) {}\n\t\treturn len - k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close():Void {}\n\n\tfunction set_bigEndian(b:Bool):Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll(?bufsize:Int):Bytes {\n\t\tif (bufsize == null)\n\t\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf, 0, len);\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes(s:Bytes, pos:Int, len:Int):Void {\n\t\twhile (len > 0) {\n\t\t\tvar k = readBytes(s, pos, len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read(nbytes:Int):Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile (nbytes > 0) {\n\t\t\tvar k = readBytes(s, p, nbytes);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil(end:Int):String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\twhile ((last = readByte()) != end)\n\t\t\tbuf.addByte(last);\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine():String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile ((last = readByte()) != 10)\n\t\t\t\tbuf.addByte(last);\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.charCodeAt(s.length - 1) == 13)\n\t\t\t\ts = s.substr(0, -1);\n\t\t} catch (e:Eof) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.length == 0)\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat():Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble():Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2, i1) : FPHelper.i64ToDouble(i1, i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8():Int {\n\t\tvar n = readByte();\n\t\tif (n >= 128)\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif (n & 0x8000 != 0)\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif (n & 0x800000 != 0)\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n\t\t#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn (n | 0x80000000);\n\t\telse\n\t\t\treturn n;\n\t\t#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clampInt32(n);\n\t\t#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\t#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString(len:Int, ?encoding:Encoding):String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b, 0, len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tInput.prototype.bigEndian = false;\n\t\t}\n\t#end\n\n\t#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>) {\n\t\treturn (((bytes[1] & 0xF) << 16) | (bytes[2] << 8) | bytes[3]) * 4294967296.\n\t\t\t+ (bytes[4] >> 7) * 2147483648\n\t\t\t+ (((bytes[4] & 0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n\t#end\n}\n"]}