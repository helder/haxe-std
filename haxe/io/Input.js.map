{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Input.js.map","sources":["../../../../../../../haxe/versions/4.1.3/std/haxe/io/FPHelper.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/io/Eof.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/io/Input.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new sys.thread.Tls<Int64>();\n\t#elseif !(java || cs || cpp)\n\tstatic var i64tmp = Int64.ofInt(0);\n\n\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\n\tstatic inline function _i32ToFloat(i:Int):Float {\n\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\tvar e = (i >> 23) & 0xff;\n\t\tif (e == 255)\n\t\t\treturn i & 0x7fffff == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = e == 0 ? (i & 0x7fffff) << 1 : (i & 0x7fffff) | 0x800000;\n\t\treturn sign * m * Math.pow(2, e - 150);\n\t}\n\n\tstatic inline function _i64ToDouble(lo:Int, hi:Int):Float {\n\t\tvar sign = 1 - ((hi >>> 31) << 1);\n\t\tvar e = (hi >> 20) & 0x7ff;\n\t\tif (e == 2047)\n\t\t\treturn lo == 0 && (hi & 0xFFFFF) == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = 2.220446049250313e-16 * ((hi & 0xFFFFF) * 4294967296. + (lo >>> 31) * 2147483648. + (lo & 0x7FFFFFFF));\n\t\tm = e == 0 ? m * 2.0 : m + 1.0;\n\t\treturn sign * m * Math.pow(2, e - 1023);\n\t}\n\n\tstatic inline function _floatToI32(f:Float):Int {\n\t\tif (f == 0)\n\t\t\treturn 0;\n\t\tvar af = f < 0 ? -f : f;\n\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\tif (exp > 127) {\n\t\t\treturn 0x7F800000;\n\t\t} else {\n\t\t\tif (exp <= -127) {\n\t\t\t\texp = -127;\n\t\t\t\taf *= 7.1362384635298e+44; // af * 0.5 * 0x800000 / Math.pow(2, -127)\n\t\t\t} else {\n\t\t\t\taf = (af / Math.pow(2, exp) - 1.0) * 0x800000;\n\t\t\t}\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | Math.round(af);\n\t\t}\n\t}\n\n\tstatic inline function _doubleToI64(v:Float):Int64@:privateAccess {\n\t\tvar i64 = i64tmp;\n\t\tif (v == 0) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(0);\n\t\t} else if (!Math.isFinite(v)) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(v > 0 ? 0x7FF00000 : 0xFFF00000);\n\t\t} else {\n\t\t\tvar av = v < 0 ? -v : v;\n\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\tif (exp > 1023) {\n\t\t\t\ti64.set_low(0xFFFFFFFF);\n\t\t\t\ti64.set_high(0x7FEFFFFF);\n\t\t\t} else {\n\t\t\t\tif (exp <= -1023) {\n\t\t\t\t\texp = -1023;\n\t\t\t\t\tav = av / 2.2250738585072014e-308;\n\t\t\t\t} else {\n\t\t\t\t\tav = av / Math.pow(2, exp) - 1.0;\n\t\t\t\t}\n\t\t\t\tvar sig = Math.fround(av * 4503599627370496.); // 2^52\n\t\t\t\t// Note: If \"sig\" is outside of the signed Int32 range, the result is unspecified in HL, C#, Java and Neko,\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\ti64.set_low(sig_l);\n\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t}\n\t\t}\n\t\treturn i64;\n\t}\n\t#end\n\n\t#if neko\n\t#if neko_v21\n\tstatic var helpers = new sys.thread.Tls<neko.NativeArray<Dynamic>>();\n\t#else\n\tstatic var helperf = new sys.thread.Tls<neko.NativeString>();\n\tstatic var helperd = new sys.thread.Tls<neko.NativeString>();\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\tstatic var _float_bytes = neko.Lib.load(\"std\", \"float_bytes\", 2);\n\tstatic var _double_bytes = neko.Lib.load(\"std\", \"double_bytes\", 2);\n\t#end\n\t#elseif flash\n\tstatic var helper = {\n\t\tvar b = new flash.utils.ByteArray();\n\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\tb;\n\t}\n\t#elseif js\n\tstatic var helper = new js.lib.DataView(new js.lib.ArrayBuffer(8));\n\t#end\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i32ToFloat(i:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itof(i, false);\n\t\t#else\n\t\tvar helper = helperf.value;\n\t\tif (helper == null)\n\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\tuntyped $sset(helper, 0, i & 0xFF);\n\t\tuntyped $sset(helper, 1, (i >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (i >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, i >>> 24);\n\t\treturn _float_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = i;\n\t\t} else {\n\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(i);\n\t\thelper.position = 0;\n\t\treturn helper.readFloat();\n\t\t#elseif js\n\t\thelper.setInt32(0, i, true);\n\t\treturn helper.getFloat32(0, true);\n\t\t#else\n\t\treturn _i32ToFloat(i);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function floatToI32(f:Float):Int {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $ftoi(f, false);\n\t\t#else\n\t\tvar r = _float_bytes(f, false);\n\t\treturn untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(f);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeFloat(f);\n\t\thelper.position = 0;\n\t\treturn helper.readUnsignedInt();\n\t\t#elseif js\n\t\thelper.setFloat32(0, f, true);\n\t\treturn helper.getInt32(0, true);\n\t\t#else\n\t\treturn _floatToI32(f);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i64ToDouble(low:Int, high:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itod(low, high, false);\n\t\t#else\n\t\tvar helper = helperd.value;\n\t\tif (helper == null)\n\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\tuntyped $sset(helper, 0, low & 0xFF);\n\t\tuntyped $sset(helper, 1, (low >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (low >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, low >>> 24);\n\t\tuntyped $sset(helper, 4, high & 0xFF);\n\t\tuntyped $sset(helper, 5, (high >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 6, (high >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 7, high >>> 24);\n\t\treturn _double_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low, high);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = haxe.Int64.make(high, low);\n\t\t} else {\n\t\t\tvar i1 = high, i2 = low;\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\thelper.i = haxe.Int64.make(j1, j2);\n\t\t}\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.longBitsToDouble(Int64.make(high, low));\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(low);\n\t\thelper.writeUnsignedInt(high);\n\t\thelper.position = 0;\n\t\treturn helper.readDouble();\n\t\t#elseif js\n\t\thelper.setInt32(0, low, true);\n\t\thelper.setInt32(4, high, true);\n\t\treturn helper.getFloat64(0, true);\n\t\t#else\n\t\treturn _i64ToDouble(low, high);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64(v:Float):Int64 {\n\t\t#if neko\n\t\t#if neko_v21\n\t\tvar helper = helpers.value;\n\t\tif (helper == null) {\n\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t}\n\t\tvar i64:haxe.Int64 = helper[1], int2 = helper[0];\n\t\tuntyped $dtoi(v, int2, false);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(int2[0]);\n\t\t\ti64.set_high(int2[1]);\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\tvar r = _double_bytes(v, false), i64 = i64tmp.value;\n\t\tif (i64 == null)\n\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24));\n\t\t\ti64.set_high(untyped $sget(r, 4) | ($sget(r, 5) << 8) | ($sget(r, 6) << 16) | ($sget(r, 7) << 24));\n\t\t}\n\t\treturn i64;\n\t\t#end\n\t\t#elseif cpp\n\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\tuntyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v));\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(v);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\tvar i1 = haxe.Int64.getHigh(i), i2 = haxe.Int64.getLow(i);\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\treturn haxe.Int64.make(j1, j2);\n\t\t}\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeDouble(v);\n\t\thelper.position = 0;\n\t\tvar i64 = i64tmp;\n\t\t@:privateAccess {\n\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t}\n\t\treturn i64;\n\t\t#elseif js\n\t\tvar i64 = i64tmp;\n\t\thelper.setFloat64(0, v, true);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(helper.getInt32(0, true));\n\t\t\ti64.set_high(helper.getInt32(4, true));\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\treturn _doubleToI64(v);\n\t\t#end\n\t}\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single) {\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float) {\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\n#if eval\n@:keep\n#end\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n**/\nclass Eof {\n\tpublic function new() {}\n\n\t@:ifFeature(\"haxe.io.Eof.*\")\n\tfunction toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte():Int {\n\t\t#if cpp\n\t\tthrow \"Not implemented\";\n\t\t#else\n\t\treturn throw \"Not implemented\";\n\t\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile (k > 0) {\n\t\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b, pos, readByte());\n\t\t\t\t#elseif php\n\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof:haxe.io.Eof) {}\n\t\treturn len - k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close():Void {}\n\n\tfunction set_bigEndian(b:Bool):Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll(?bufsize:Int):Bytes {\n\t\tif (bufsize == null)\n\t\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf, 0, len);\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes(s:Bytes, pos:Int, len:Int):Void {\n\t\twhile (len > 0) {\n\t\t\tvar k = readBytes(s, pos, len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read(nbytes:Int):Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile (nbytes > 0) {\n\t\t\tvar k = readBytes(s, p, nbytes);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil(end:Int):String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\twhile ((last = readByte()) != end)\n\t\t\tbuf.addByte(last);\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine():String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile ((last = readByte()) != 10)\n\t\t\t\tbuf.addByte(last);\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.charCodeAt(s.length - 1) == 13)\n\t\t\t\ts = s.substr(0, -1);\n\t\t} catch (e:Eof) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.length == 0)\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat():Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble():Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2, i1) : FPHelper.i64ToDouble(i1, i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8():Int {\n\t\tvar n = readByte();\n\t\tif (n >= 128)\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif (n & 0x8000 != 0)\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif (n & 0x800000 != 0)\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n\t\t#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn (n | 0x80000000);\n\t\telse\n\t\t\treturn n;\n\t\t#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clampInt32(n);\n\t\t#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\t#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString(len:Int, ?encoding:Encoding):String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b, 0, len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tInput.prototype.bigEndian = false;\n\t\t}\n\t#end\n\n\t#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>) {\n\t\treturn (((bytes[1] & 0xF) << 16) | (bytes[2] << 8) | bytes[3]) * 4294967296.\n\t\t\t+ (bytes[4] >> 7) * 2147483648\n\t\t\t+ (((bytes[4] & 0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n\t#end\n}\n"]}