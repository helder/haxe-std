{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Input.js.map","sources":["../../../../../../../haxe/versions/4.0.1/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/io/FPHelper.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/io/Eof.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/haxe/io/Bytes.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/CallStack.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/HxOverrides.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/io/Input.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new sys.thread.Tls<Int64>();\n\t#elseif !(java || cs || cpp)\n\tstatic var i64tmp = Int64.ofInt(0);\n\n\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\n\tstatic inline function _i32ToFloat(i:Int):Float {\n\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\tvar e = (i >> 23) & 0xff;\n\t\tif (e == 255)\n\t\t\treturn i & 0x7fffff == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = e == 0 ? (i & 0x7fffff) << 1 : (i & 0x7fffff) | 0x800000;\n\t\treturn sign * m * Math.pow(2, e - 150);\n\t}\n\n\tstatic inline function _i64ToDouble(lo:Int, hi:Int):Float {\n\t\tvar sign = 1 - ((hi >>> 31) << 1);\n\t\tvar e = (hi >> 20) & 0x7ff;\n\t\tif (e == 2047)\n\t\t\treturn lo == 0 && (hi & 0xFFFFF) == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = 2.220446049250313e-16 * ((hi & 0xFFFFF) * 4294967296. + (lo >>> 31) * 2147483648. + (lo & 0x7FFFFFFF));\n\t\tm = e == 0 ? m * 2.0 : m + 1.0;\n\t\treturn sign * m * Math.pow(2, e - 1023);\n\t}\n\n\tstatic inline function _floatToI32(f:Float):Int {\n\t\tif (f == 0)\n\t\t\treturn 0;\n\t\tvar af = f < 0 ? -f : f;\n\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\tif (exp > 127) {\n\t\t\treturn 0x7F800000;\n\t\t} else {\n\t\t\tif (exp <= -127) {\n\t\t\t\texp = -127;\n\t\t\t\taf *= 7.1362384635298e+44; // af * 0.5 * 0x800000 / Math.pow(2, -127)\n\t\t\t} else {\n\t\t\t\taf = (af / Math.pow(2, exp) - 1.0) * 0x800000;\n\t\t\t}\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | Math.round(af);\n\t\t}\n\t}\n\n\tstatic inline function _doubleToI64(v:Float):Int64@:privateAccess {\n\t\tvar i64 = i64tmp;\n\t\tif (v == 0) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(0);\n\t\t} else if (!Math.isFinite(v)) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(v > 0 ? 0x7FF00000 : 0xFFF00000);\n\t\t} else {\n\t\t\tvar av = v < 0 ? -v : v;\n\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\tif (exp > 1023) {\n\t\t\t\ti64.set_low(0xFFFFFFFF);\n\t\t\t\ti64.set_high(0x7FEFFFFF);\n\t\t\t} else {\n\t\t\t\tif (exp <= -1023) {\n\t\t\t\t\texp = -1023;\n\t\t\t\t\tav = av / 2.2250738585072014e-308;\n\t\t\t\t} else {\n\t\t\t\t\tav = av / Math.pow(2, exp) - 1.0;\n\t\t\t\t}\n\t\t\t\tvar sig = Math.fround(av * 4503599627370496.); // 2^52\n\t\t\t\t// Note: If \"sig\" is outside of the signed Int32 range, the result is unspecified in HL, C#, Java and Neko,\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\ti64.set_low(sig_l);\n\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t}\n\t\t}\n\t\treturn i64;\n\t}\n\t#end\n\n\t#if neko\n\t#if neko_v21\n\tstatic var helpers = new sys.thread.Tls<neko.NativeArray<Dynamic>>();\n\t#else\n\tstatic var helperf = new sys.thread.Tls<neko.NativeString>();\n\tstatic var helperd = new sys.thread.Tls<neko.NativeString>();\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\tstatic var _float_bytes = neko.Lib.load(\"std\", \"float_bytes\", 2);\n\tstatic var _double_bytes = neko.Lib.load(\"std\", \"double_bytes\", 2);\n\t#end\n\t#elseif flash\n\tstatic var helper = {\n\t\tvar b = new flash.utils.ByteArray();\n\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\tb;\n\t}\n\t#elseif js\n\tstatic var helper = new js.lib.DataView(new js.lib.ArrayBuffer(8));\n\t#end\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i32ToFloat(i:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itof(i, false);\n\t\t#else\n\t\tvar helper = helperf.value;\n\t\tif (helper == null)\n\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\tuntyped $sset(helper, 0, i & 0xFF);\n\t\tuntyped $sset(helper, 1, (i >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (i >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, i >>> 24);\n\t\treturn _float_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = i;\n\t\t} else {\n\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(i);\n\t\thelper.position = 0;\n\t\treturn helper.readFloat();\n\t\t#elseif js\n\t\thelper.setInt32(0, i, true);\n\t\treturn helper.getFloat32(0, true);\n\t\t#else\n\t\treturn _i32ToFloat(i);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function floatToI32(f:Float):Int {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $ftoi(f, false);\n\t\t#else\n\t\tvar r = _float_bytes(f, false);\n\t\treturn untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(f);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeFloat(f);\n\t\thelper.position = 0;\n\t\treturn helper.readUnsignedInt();\n\t\t#elseif js\n\t\thelper.setFloat32(0, f, true);\n\t\treturn helper.getInt32(0, true);\n\t\t#else\n\t\treturn _floatToI32(f);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i64ToDouble(low:Int, high:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itod(low, high, false);\n\t\t#else\n\t\tvar helper = helperd.value;\n\t\tif (helper == null)\n\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\tuntyped $sset(helper, 0, low & 0xFF);\n\t\tuntyped $sset(helper, 1, (low >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (low >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, low >>> 24);\n\t\tuntyped $sset(helper, 4, high & 0xFF);\n\t\tuntyped $sset(helper, 5, (high >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 6, (high >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 7, high >>> 24);\n\t\treturn _double_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low, high);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = haxe.Int64.make(high, low);\n\t\t} else {\n\t\t\tvar i1 = high, i2 = low;\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\thelper.i = haxe.Int64.make(j1, j2);\n\t\t}\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.longBitsToDouble(Int64.make(high, low));\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(low);\n\t\thelper.writeUnsignedInt(high);\n\t\thelper.position = 0;\n\t\treturn helper.readDouble();\n\t\t#elseif js\n\t\thelper.setInt32(0, low, true);\n\t\thelper.setInt32(4, high, true);\n\t\treturn helper.getFloat64(0, true);\n\t\t#else\n\t\treturn _i64ToDouble(low, high);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64(v:Float):Int64 {\n\t\t#if neko\n\t\t#if neko_v21\n\t\tvar helper = helpers.value;\n\t\tif (helper == null) {\n\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t}\n\t\tvar i64:haxe.Int64 = helper[1], int2 = helper[0];\n\t\tuntyped $dtoi(v, int2, false);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(int2[0]);\n\t\t\ti64.set_high(int2[1]);\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\tvar r = _double_bytes(v, false), i64 = i64tmp.value;\n\t\tif (i64 == null)\n\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24));\n\t\t\ti64.set_high(untyped $sget(r, 4) | ($sget(r, 5) << 8) | ($sget(r, 6) << 16) | ($sget(r, 7) << 24));\n\t\t}\n\t\treturn i64;\n\t\t#end\n\t\t#elseif cpp\n\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\tuntyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v));\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(v);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\tvar i1 = haxe.Int64.getHigh(i), i2 = haxe.Int64.getLow(i);\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\treturn haxe.Int64.make(j1, j2);\n\t\t}\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeDouble(v);\n\t\thelper.position = 0;\n\t\tvar i64 = i64tmp;\n\t\t@:privateAccess {\n\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t}\n\t\treturn i64;\n\t\t#elseif js\n\t\tvar i64 = i64tmp;\n\t\thelper.setFloat64(0, v, true);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(helper.getInt32(0, true));\n\t\t\ti64.set_high(helper.getInt32(4, true));\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\treturn _doubleToI64(v);\n\t\t#end\n\t}\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single) {\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float) {\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n**/\nclass Eof {\n\tpublic function new() {}\n\n\t@:ifFeature(\"haxe.io.Eof.*\")\n\tfunction toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule(m:String);\n\tFilePos(s:Null<StackItem>, file:String, line:Int, ?column:Null<Int>);\n\tMethod(classname:Null<String>, method:String);\n\tLocalFunction(?v:Int);\n}\n\n/**\n\tGet information about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.lib.Error;\n\n\tstatic function getStack(e:js.lib.Error):Array<StackItem> {\n\t\tif (e == null)\n\t\t\treturn [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function(error, callsites:Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null)\n\t\t\t\t\tsite = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName:String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx + 1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar fileName:String = site.getFileName();\n\t\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\t\tfileName = fileName.substr(fileAddr + 6);\n\t\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t#if eval\n\tstatic function getCallStack() {\n\t\treturn [];\n\t}\n\n\tstatic function getExceptionStack() {\n\t\treturn [];\n\t}\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack():Array<StackItem> {\n\t\t#if neko\n\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\ta.shift(); // remove Stack.callStack()\n\t\treturn a;\n\t\t#elseif flash\n\t\tvar a = makeStack(new flash.errors.Error().getStackTrace());\n\t\ta.shift(); // remove Stack.callStack()\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\treturn makeStack(s);\n\t\t#elseif js\n\t\ttry {\n\t\t\tthrow new js.lib.Error();\n\t\t} catch (e:Dynamic) {\n\t\t\tvar a = getStack(js.Lib.getOriginalException());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t}\n\t\t#elseif java\n\t\tvar stack = [];\n\t\tfor (el in java.lang.Thread.currentThread().getStackTrace()) {\n\t\t\tvar className = el.getClassName();\n\t\t\tvar methodName = el.getMethodName();\n\t\t\tvar fileName = el.getFileName();\n\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\tvar method = Method(className, methodName);\n\t\t\tif (fileName != null || lineNumber >= 0) {\n\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t} else {\n\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t}\n\t\tstack.shift();\n\t\tstack.shift();\n\t\tstack.pop();\n\t\treturn stack;\n\t\t#elseif cs\n\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\tvar stack = [];\n\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\tinfos.pop();\n\t\tinfos.reverse();\n\t\tfor (elem in infos)\n\t\t\tstack.push(FilePos(Method(null, elem._3), elem._1, elem._2));\n\t\treturn stack;\n\t\t#elseif lua\n\t\tvar stack = [];\n\t\tvar infos = lua.Debug.traceback();\n\t\tvar luastack = infos.split(\"\\n\").slice(2, -1);\n\t\tfor (s in luastack) {\n\t\t\tvar parts = s.split(\":\");\n\t\t\tvar file = parts[0];\n\t\t\tvar line = parts[1];\n\t\t\tvar method = if(parts.length <= 2) {\n\t\t\t\tnull;\n\t\t\t} else {\n\t\t\t\tvar methodPos = parts[2].indexOf(\"'\");\n\t\t\t\tif(methodPos < 0) {\n\t\t\t\t\tnull;\n\t\t\t\t} else {\n\t\t\t\t\tMethod(null, parts[2].substring(methodPos + 1, parts[2].length - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.push(FilePos(method, file, Std.parseInt(line)));\n\t\t}\n\t\treturn stack;\n\t\t#elseif hl\n\t\ttry {\n\t\t\tthrow null;\n\t\t} catch (e:Dynamic) {\n\t\t\tvar st = _getExceptionStack();\n\t\t\treturn makeStack(st.length > 2 ? st.sub(2, st.length - 2) : st);\n\t\t}\n\t\t#elseif eval\n\t\treturn getCallStack();\n\t\t#else\n\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t#if hl\n\t@:hlNative(\"std\", \"exception_stack\") static function _getExceptionStack():hl.NativeArray<hl.Bytes> {\n\t\treturn null;\n\t}\n\t#end\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp\n\t@:noDebug /* Do not mess up the exception stack */\n\t#end\n\tpublic static function exceptionStack():Array<StackItem> {\n\t\t#if neko\n\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\treturn new Array();\n\t\t#elseif hl\n\t\treturn makeStack(_getExceptionStack());\n\t\t#elseif flash\n\t\tvar err:flash.errors.Error = untyped flash.Boot.lastError;\n\t\tif (err == null)\n\t\t\treturn new Array();\n\t\tvar a = makeStack(err.getStackTrace());\n\t\tvar c = callStack();\n\t\tvar i = c.length - 1;\n\t\twhile (i > 0) {\n\t\t\tif (Std.string(a[a.length - 1]) == Std.string(c[i]))\n\t\t\t\ta.pop();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t}\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\treturn makeStack(s);\n\t\t#elseif java\n\t\tvar stack = [];\n\t\tswitch (#if jvm jvm.Exception #else java.internal.Exceptions #end.currentException()) {\n\t\t\tcase null:\n\t\t\tcase current:\n\t\t\t\tfor (el in current.getStackTrace()) {\n\t\t\t\t\tvar className = el.getClassName();\n\t\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\t\tvar method = Method(className, methodName);\n\t\t\t\t\tif (fileName != null || lineNumber >= 0) {\n\t\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstack.push(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\treturn stack;\n\t\t#elseif cs\n\t\treturn cs.internal.Exceptions.exception == null ? [] : makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\tvar stack = [];\n\t\tvar exc = python.lib.Sys.exc_info();\n\t\tif (exc._3 != null) {\n\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(Method(null, elem._3), elem._1, elem._2));\n\t\t}\n\t\treturn stack;\n\t\t#elseif js\n\t\treturn getStack(lastException);\n\t\t#elseif eval\n\t\treturn getExceptionStack();\n\t\t#else\n\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString(stack:Array<StackItem>) {\n\t\tvar b = new StringBuf();\n\t\tfor (s in stack) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b, s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString(b:StringBuf, s) {\n\t\tswitch (s) {\n\t\t\tcase CFunction:\n\t\t\t\tb.add(\"a C function\");\n\t\t\tcase Module(m):\n\t\t\t\tb.add(\"module \");\n\t\t\t\tb.add(m);\n\t\t\tcase FilePos(s, file, line, col):\n\t\t\t\tif (s != null) {\n\t\t\t\t\titemToString(b, s);\n\t\t\t\t\tb.add(\" (\");\n\t\t\t\t}\n\t\t\t\tb.add(file);\n\t\t\t\tb.add(\" line \");\n\t\t\t\tb.add(line);\n\t\t\t\tif (col != null) {\n\t\t\t\t\tb.add(\" column \");\n\t\t\t\t\tb.add(col);\n\t\t\t\t}\n\t\t\t\tif (s != null)\n\t\t\t\t\tb.add(\")\");\n\t\t\tcase Method(cname, meth):\n\t\t\t\tb.add(cname == null ? \"<unknown>\" : cname);\n\t\t\t\tb.add(\".\");\n\t\t\t\tb.add(meth);\n\t\t\tcase LocalFunction(n):\n\t\t\t\tb.add(\"local function #\");\n\t\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp\n\t@:noDebug /* Do not mess up the exception stack */\n\t#end\n\tprivate static function makeStack(s #if cs:cs.system.diagnostics.StackTrace #elseif hl:hl.NativeArray<hl.Bytes> #else:Dynamic #end) {\n\t\t#if neko\n\t\tvar a = new Array();\n\t\tvar l = untyped __dollar__asize(s);\n\t\tvar i = 0;\n\t\twhile (i < l) {\n\t\t\tvar x = s[i++];\n\t\t\tif (x == null)\n\t\t\t\ta.unshift(CFunction);\n\t\t\telse if (untyped __dollar__typeof(x) == __dollar__tstring)\n\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\telse\n\t\t\t\ta.unshift(FilePos(null, new String(untyped x[0]), untyped x[1]));\n\t\t}\n\t\treturn a;\n\t\t#elseif flash\n\t\tvar a = new Array();\n\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\twhile (r.match(s)) {\n\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\tvar meth = r.matched(2);\n\t\t\tvar item;\n\t\t\tif (meth == null) {\n\t\t\t\tif (rlambda.match(cl))\n\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\telse\n\t\t\t\t\titem = Method(cl, \"new\");\n\t\t\t} else\n\t\t\t\titem = Method(cl, meth.substr(1));\n\t\t\tif (r.matched(3) != null)\n\t\t\t\titem = FilePos(item, r.matched(4), Std.parseInt(r.matched(5)));\n\t\t\ta.push(item);\n\t\t\ts = r.matchedRight();\n\t\t}\n\t\treturn a;\n\t\t#elseif cpp\n\t\tvar stack:Array<String> = s;\n\t\tvar m = new Array<StackItem>();\n\t\tfor (func in stack) {\n\t\t\tvar words = func.split(\"::\");\n\t\t\tif (words.length == 0)\n\t\t\t\tm.push(CFunction)\n\t\t\telse if (words.length == 2)\n\t\t\t\tm.push(Method(words[0], words[1]));\n\t\t\telse if (words.length == 4)\n\t\t\t\tm.push(FilePos(Method(words[0], words[1]), words[2], Std.parseInt(words[3])));\n\t\t}\n\t\treturn m;\n\t\t#elseif js\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (js.Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = s.split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\tfor (line in stack) {\n\t\t\t\tif (rie10.match(line)) {\n\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\tvar column = Std.parseInt(rie10.matched(4));\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t}\n\t\t\treturn m;\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t\t#elseif cs\n\t\tvar stack = [];\n\t\tfor (i in 0...s.FrameCount) {\n\t\t\tvar frame = s.GetFrame(i);\n\t\t\tvar m = frame.GetMethod();\n\n\t\t\tif (m == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\tvar fileName = frame.GetFileName();\n\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\telse\n\t\t\t\tstack.push(method);\n\t\t}\n\t\treturn stack;\n\t\t#elseif hl\n\t\tvar stack = [];\n\t\tvar r = ~/^([A-Za-z0-9.$_]+)\\.([~A-Za-z0-9_]+(\\.[0-9]+)?)\\((.+):([0-9]+)\\)$/;\n\t\tvar r_fun = ~/^fun\\$([0-9]+)\\((.+):([0-9]+)\\)$/;\n\t\tfor (i in 0...s.length - 1) {\n\t\t\tvar str = @:privateAccess String.fromUCS2(s[i]);\n\t\t\tif (r.match(str))\n\t\t\t\tstack.push(FilePos(Method(r.matched(1), r.matched(2)), r.matched(4), Std.parseInt(r.matched(5))));\n\t\t\telse if (r_fun.match(str))\n\t\t\t\tstack.push(FilePos(LocalFunction(Std.parseInt(r_fun.matched(1))), r_fun.matched(2), Std.parseInt(r_fun.matched(3))));\n\t\t\telse\n\t\t\t\tstack.push(Module(str));\n\t\t}\n\t\treturn stack;\n\t\t#else\n\t\treturn null;\n\t\t#end\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) __js__(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) __js__(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte():Int {\n\t\t#if cpp\n\t\tthrow \"Not implemented\";\n\t\t#else\n\t\treturn throw \"Not implemented\";\n\t\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile (k > 0) {\n\t\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b, pos, readByte());\n\t\t\t\t#elseif php\n\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof:haxe.io.Eof) {}\n\t\treturn len - k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close():Void {}\n\n\tfunction set_bigEndian(b:Bool):Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll(?bufsize:Int):Bytes {\n\t\tif (bufsize == null)\n\t\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf, 0, len);\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes(s:Bytes, pos:Int, len:Int):Void {\n\t\twhile (len > 0) {\n\t\t\tvar k = readBytes(s, pos, len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read(nbytes:Int):Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile (nbytes > 0) {\n\t\t\tvar k = readBytes(s, p, nbytes);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil(end:Int):String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\twhile ((last = readByte()) != end)\n\t\t\tbuf.addByte(last);\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine():String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile ((last = readByte()) != 10)\n\t\t\t\tbuf.addByte(last);\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.charCodeAt(s.length - 1) == 13)\n\t\t\t\ts = s.substr(0, -1);\n\t\t} catch (e:Eof) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.length == 0)\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat():Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble():Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2, i1) : FPHelper.i64ToDouble(i1, i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8():Int {\n\t\tvar n = readByte();\n\t\tif (n >= 128)\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif (n & 0x8000 != 0)\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif (n & 0x800000 != 0)\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n\t\t#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn (n | 0x80000000);\n\t\telse\n\t\t\treturn n;\n\t\t#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clampInt32(n);\n\t\t#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\t#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString(len:Int, ?encoding:Encoding):String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b, 0, len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tInput.prototype.bigEndian = false;\n\t\t}\n\t#end\n\n\t#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>) {\n\t\treturn (((bytes[1] & 0xF) << 16) | (bytes[2] << 8) | bytes[3]) * 4294967296.\n\t\t\t+ (bytes[4] >> 7) * 2147483648\n\t\t\t+ (((bytes[4] & 0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n\t#end\n}\n"]}