{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Output.js.map","sources":["../../../../../../../haxe/versions/4.2.2/std/haxe/io/FPHelper.hx","../../../../../../../haxe/versions/4.2.2/std/haxe/io/Error.hx","../../../../../../../haxe/versions/4.2.2/std/haxe/io/Eof.hx","../../../../../../../haxe/versions/4.2.2/std/js/_std/haxe/io/Bytes.hx","../../../../../../../haxe/versions/4.2.2/std/haxe/exceptions/NotImplementedException.hx","../../../../../../../haxe/versions/4.2.2/std/js/_std/haxe/NativeStackTrace.hx","../../../../../../../haxe/versions/4.2.2/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/haxe_libraries/genes/0.4.1/github/179cb495c2d785321879e8afe765aa04d639783d/src/genes/Register.hx","../../../../../../../haxe/versions/4.2.2/std/haxe/io/Output.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new sys.thread.Tls<Int64>();\n\t#elseif !(java || cs || cpp)\n\tstatic var i64tmp = Int64.ofInt(0);\n\n\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\n\tstatic inline function _i32ToFloat(i:Int):Float {\n\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\tvar e = (i >> 23) & 0xff;\n\t\tif (e == 255)\n\t\t\treturn i & 0x7fffff == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = e == 0 ? (i & 0x7fffff) << 1 : (i & 0x7fffff) | 0x800000;\n\t\treturn sign * m * Math.pow(2, e - 150);\n\t}\n\n\tstatic inline function _i64ToDouble(lo:Int, hi:Int):Float {\n\t\tvar sign = 1 - ((hi >>> 31) << 1);\n\t\tvar e = (hi >> 20) & 0x7ff;\n\t\tif (e == 2047)\n\t\t\treturn lo == 0 && (hi & 0xFFFFF) == 0 ? (sign > 0 ? Math.POSITIVE_INFINITY : Math.NEGATIVE_INFINITY) : Math.NaN;\n\t\tvar m = 2.220446049250313e-16 * ((hi & 0xFFFFF) * 4294967296. + (lo >>> 31) * 2147483648. + (lo & 0x7FFFFFFF));\n\t\tm = e == 0 ? m * 2.0 : m + 1.0;\n\t\treturn sign * m * Math.pow(2, e - 1023);\n\t}\n\n\tstatic inline function _floatToI32(f:Float):Int {\n\t\tif (f == 0)\n\t\t\treturn 0;\n\t\tvar af = f < 0 ? -f : f;\n\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\tif (exp > 127) {\n\t\t\treturn 0x7F800000;\n\t\t} else {\n\t\t\tif (exp <= -127) {\n\t\t\t\texp = -127;\n\t\t\t\taf *= 7.1362384635298e+44; // af * 0.5 * 0x800000 / Math.pow(2, -127)\n\t\t\t} else {\n\t\t\t\taf = (af / Math.pow(2, exp) - 1.0) * 0x800000;\n\t\t\t}\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | Math.round(af);\n\t\t}\n\t}\n\n\tstatic inline function _doubleToI64(v:Float):Int64@:privateAccess {\n\t\tvar i64 = i64tmp;\n\t\tif (v == 0) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(0);\n\t\t} else if (!Math.isFinite(v)) {\n\t\t\ti64.set_low(0);\n\t\t\ti64.set_high(v > 0 ? 0x7FF00000 : 0xFFF00000);\n\t\t} else {\n\t\t\tvar av = v < 0 ? -v : v;\n\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\tif (exp > 1023) {\n\t\t\t\ti64.set_low(0xFFFFFFFF);\n\t\t\t\ti64.set_high(0x7FEFFFFF);\n\t\t\t} else {\n\t\t\t\tif (exp <= -1023) {\n\t\t\t\t\texp = -1023;\n\t\t\t\t\tav = av / 2.2250738585072014e-308;\n\t\t\t\t} else {\n\t\t\t\t\tav = av / Math.pow(2, exp) - 1.0;\n\t\t\t\t}\n\t\t\t\tvar sig = Math.fround(av * 4503599627370496.); // 2^52\n\t\t\t\t// Note: If \"sig\" is outside of the signed Int32 range, the result is unspecified in HL, C#, Java and Neko,\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\ti64.set_low(sig_l);\n\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t}\n\t\t}\n\t\treturn i64;\n\t}\n\t#end\n\n\t#if neko\n\t#if neko_v21\n\tstatic var helpers = new sys.thread.Tls<neko.NativeArray<Dynamic>>();\n\t#else\n\tstatic var helperf = new sys.thread.Tls<neko.NativeString>();\n\tstatic var helperd = new sys.thread.Tls<neko.NativeString>();\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\tstatic var _float_bytes = neko.Lib.load(\"std\", \"float_bytes\", 2);\n\tstatic var _double_bytes = neko.Lib.load(\"std\", \"double_bytes\", 2);\n\t#end\n\t#elseif flash\n\tstatic var helper = {\n\t\tvar b = new flash.utils.ByteArray();\n\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\tb;\n\t}\n\t#elseif js\n\tstatic var helper = new js.lib.DataView(new js.lib.ArrayBuffer(8));\n\t#end\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i32ToFloat(i:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itof(i, false);\n\t\t#else\n\t\tvar helper = helperf.value;\n\t\tif (helper == null)\n\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\tuntyped $sset(helper, 0, i & 0xFF);\n\t\tuntyped $sset(helper, 1, (i >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (i >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, i >>> 24);\n\t\treturn _float_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = i;\n\t\t} else {\n\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(i);\n\t\thelper.position = 0;\n\t\treturn helper.readFloat();\n\t\t#elseif js\n\t\thelper.setInt32(0, i, true);\n\t\treturn helper.getFloat32(0, true);\n\t\t#else\n\t\treturn _i32ToFloat(i);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function floatToI32(f:Float):Int {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $ftoi(f, false);\n\t\t#else\n\t\tvar r = _float_bytes(f, false);\n\t\treturn untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\tvar helper = new SingleHelper(f);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t}\n\t\t#elseif java\n\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeFloat(f);\n\t\thelper.position = 0;\n\t\treturn helper.readUnsignedInt();\n\t\t#elseif js\n\t\thelper.setFloat32(0, f, true);\n\t\treturn helper.getInt32(0, true);\n\t\t#else\n\t\treturn _floatToI32(f);\n\t\t#end\n\t}\n\n\t#if neko_v21\n\tinline\n\t#end\n\tpublic static function i64ToDouble(low:Int, high:Int):Float {\n\t\t#if neko\n\t\t#if neko_v21\n\t\treturn untyped $itod(low, high, false);\n\t\t#else\n\t\tvar helper = helperd.value;\n\t\tif (helper == null)\n\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\tuntyped $sset(helper, 0, low & 0xFF);\n\t\tuntyped $sset(helper, 1, (low >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 2, (low >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 3, low >>> 24);\n\t\tuntyped $sset(helper, 4, high & 0xFF);\n\t\tuntyped $sset(helper, 5, (high >> 8) & 0xFF);\n\t\tuntyped $sset(helper, 6, (high >> 16) & 0xFF);\n\t\tuntyped $sset(helper, 7, high >>> 24);\n\t\treturn _double_of_bytes(helper, false);\n\t\t#end\n\t\t#elseif cpp\n\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low, high);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(0);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\thelper.i = haxe.Int64.make(high, low);\n\t\t} else {\n\t\t\tvar i1 = high, i2 = low;\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\thelper.i = haxe.Int64.make(j1, j2);\n\t\t}\n\t\treturn helper.f;\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.longBitsToDouble(Int64.make(high, low));\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeUnsignedInt(low);\n\t\thelper.writeUnsignedInt(high);\n\t\thelper.position = 0;\n\t\treturn helper.readDouble();\n\t\t#elseif js\n\t\thelper.setInt32(0, low, true);\n\t\thelper.setInt32(4, high, true);\n\t\treturn helper.getFloat64(0, true);\n\t\t#else\n\t\treturn _i64ToDouble(low, high);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64(v:Float):Int64 {\n\t\t#if neko\n\t\t#if neko_v21\n\t\tvar helper = helpers.value;\n\t\tif (helper == null) {\n\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t}\n\t\tvar i64:haxe.Int64 = helper[1], int2 = helper[0];\n\t\tuntyped $dtoi(v, int2, false);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(int2[0]);\n\t\t\ti64.set_high(int2[1]);\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\tvar r = _double_bytes(v, false), i64 = i64tmp.value;\n\t\tif (i64 == null)\n\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(untyped $sget(r, 0) | ($sget(r, 1) << 8) | ($sget(r, 2) << 16) | ($sget(r, 3) << 24));\n\t\t\ti64.set_high(untyped $sget(r, 4) | ($sget(r, 5) << 8) | ($sget(r, 6) << 16) | ($sget(r, 7) << 24));\n\t\t}\n\t\treturn i64;\n\t\t#end\n\t\t#elseif cpp\n\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\tuntyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v));\n\t\t#elseif java\n\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\tvar helper = new FloatHelper(v);\n\t\tif (cs.system.BitConverter.IsLittleEndian) {\n\t\t\treturn helper.i;\n\t\t} else {\n\t\t\tvar i = helper.i;\n\t\t\tvar i1 = haxe.Int64.getHigh(i), i2 = haxe.Int64.getLow(i);\n\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\treturn haxe.Int64.make(j1, j2);\n\t\t}\n\t\t#elseif flash\n\t\tvar helper = helper;\n\t\thelper.position = 0;\n\t\thelper.writeDouble(v);\n\t\thelper.position = 0;\n\t\tvar i64 = i64tmp;\n\t\t@:privateAccess {\n\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t}\n\t\treturn i64;\n\t\t#elseif js\n\t\tvar i64 = i64tmp;\n\t\thelper.setFloat64(0, v, true);\n\t\t@:privateAccess {\n\t\t\ti64.set_low(helper.getInt32(0, true));\n\t\t\ti64.set_high(helper.getInt32(4, true));\n\t\t}\n\t\treturn i64;\n\t\t#else\n\t\treturn _doubleToI64(v);\n\t\t#end\n\t}\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single) {\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper {\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float) {\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\n#if eval\n@:keep\n#end\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n**/\nclass Eof {\n\tpublic function new() {}\n\n\t@:ifFeature(\"haxe.io.Eof.*\")\n\tfunction toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n","package haxe.exceptions;\n\n/**\n\tAn exception that is thrown when requested function or operation does not have an implementation.\n**/\nclass NotImplementedException extends PosException {\n\tpublic function new(message:String = 'Not implemented', ?previous:Exception, ?pos:PosInfos):Void {\n\t\tsuper(message, previous, pos);\n\t}\n}","package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : undefined');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a)) js.Syntax.code('a.iterator()') else\n      untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Output is an abstract write. A specific output implementation will only\n\thave to override the `writeByte` and maybe the `write`, `flush` and `close`\n\tmethods. See `File.write` and `String.write` for two ways of creating an\n\tOutput.\n**/\nclass Output {\n\t/**\n\t\tEndianness (word byte order) used when writing numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tWrite one byte.\n\t**/\n\tpublic function writeByte(c:Int):Void {\n\t\tthrow new haxe.exceptions.NotImplementedException();\n\t}\n\n\t/**\n\t\tWrite `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tReturns the actual length of written data that can differ from `len`.\n\n\t\tSee `writeFullBytes` that tries to write the exact amount of specified bytes.\n\t**/\n\tpublic function writeBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\t#if !neko\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\t#end\n\t\tvar b = #if js @:privateAccess s.b #else s.getData() #end;\n\t\tvar k = len;\n\t\twhile (k > 0) {\n\t\t\t#if neko\n\t\t\twriteByte(untyped __dollar__sget(b, pos));\n\t\t\t#elseif php\n\t\t\twriteByte(b.get(pos));\n\t\t\t#elseif cpp\n\t\t\twriteByte(untyped b[pos]);\n\t\t\t#elseif hl\n\t\t\twriteByte(b[pos]);\n\t\t\t#else\n\t\t\twriteByte(untyped b[pos]);\n\t\t\t#end\n\t\t\tpos++;\n\t\t\tk--;\n\t\t}\n\t\treturn len;\n\t}\n\n\t/**\n\t\tFlush any buffered data.\n\t**/\n\tpublic function flush() {}\n\n\t/**\n\t\tClose the output.\n\n\t\tBehaviour while writing after calling this method is unspecified.\n\t**/\n\tpublic function close() {}\n\n\tfunction set_bigEndian(b) {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tWrite all bytes stored in `s`.\n\t**/\n\tpublic function write(s:Bytes):Void {\n\t\tvar l = s.length;\n\t\tvar p = 0;\n\t\twhile (l > 0) {\n\t\t\tvar k = writeBytes(s, p, l);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tl -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tUnlike `writeBytes`, this method tries to write the exact `len` amount of bytes.\n\t**/\n\tpublic function writeFullBytes(s:Bytes, pos:Int, len:Int) {\n\t\twhile (len > 0) {\n\t\t\tvar k = writeBytes(s, pos, len);\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeFloat(x:Float) {\n\t\twriteInt32(FPHelper.floatToI32(x));\n\t}\n\n\t/**\n\t\tWrite `x` as 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeDouble(x:Float) {\n\t\tvar i64 = FPHelper.doubleToI64(x);\n\t\tif (bigEndian) {\n\t\t\twriteInt32(i64.high);\n\t\t\twriteInt32(i64.low);\n\t\t} else {\n\t\t\twriteInt32(i64.low);\n\t\t\twriteInt32(i64.high);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 8-bit signed integer.\n\t**/\n\tpublic function writeInt8(x:Int) {\n\t\tif (x < -0x80 || x >= 0x80)\n\t\t\tthrow Error.Overflow;\n\t\twriteByte(x & 0xFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt16(x:Int) {\n\t\tif (x < -0x8000 || x >= 0x8000)\n\t\t\tthrow Error.Overflow;\n\t\twriteUInt16(x & 0xFFFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeUInt16(x:Int) {\n\t\tif (x < 0 || x >= 0x10000)\n\t\t\tthrow Error.Overflow;\n\t\tif (bigEndian) {\n\t\t\twriteByte(x >> 8);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte(x >> 8);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt24(x:Int) {\n\t\tif (x < -0x800000 || x >= 0x800000)\n\t\t\tthrow Error.Overflow;\n\t\twriteUInt24(x & 0xFFFFFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeUInt24(x:Int) {\n\t\tif (x < 0 || x >= 0x1000000)\n\t\t\tthrow Error.Overflow;\n\t\tif (bigEndian) {\n\t\t\twriteByte(x >> 16);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x >> 16);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt32(x:Int) {\n\t\tif (bigEndian) {\n\t\t\twriteByte(x >>> 24);\n\t\t\twriteByte((x >> 16) & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte((x >> 16) & 0xFF);\n\t\t\twriteByte(x >>> 24);\n\t\t}\n\t}\n\n\t/**\n\t\tInform that we are about to write at least `nbytes` bytes.\n\n\t\tThe underlying implementation can allocate proper working space depending\n\t\ton this information, or simply ignore it. This is not a mandatory call\n\t\tbut a tip and is only used in some specific cases.\n\t**/\n\tpublic function prepare(nbytes:Int) {}\n\n\t/**\n\t\tRead all available data from `i` and write it.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read and written. Its default value is 4096.\n\t**/\n\tpublic function writeInput(i:Input, ?bufsize:Int) {\n\t\tif (bufsize == null)\n\t\t\tbufsize = 4096;\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = i.readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\tvar p = 0;\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tvar k = writeBytes(buf, p, len);\n\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\t\tp += k;\n\t\t\t\t\tlen -= k;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t}\n\n\t/**\n\t\tWrite `s` string.\n\t**/\n\tpublic function writeString(s:String, ?encoding:Encoding) {\n\t\t#if neko\n\t\tvar b = untyped new Bytes(s.length, s.__s);\n\t\t#else\n\t\tvar b = Bytes.ofString(s, encoding);\n\t\t#end\n\t\twriteFullBytes(b, 0, b.length);\n\t}\n\n\t#if neko\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tOutput.prototype.bigEndian = false;\n\t\t}\n\t#end\n}\n"]}