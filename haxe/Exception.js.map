{"sourceRoot":"","names":[],"mappings":"QAgBA;QCSA;QCeA;QCnCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAAA;CAkCC,8CAAsE,CACrE;EAAA,iBAAM,SACN;EAAA,AAAM,eAAgB,QACtB;EAAA,2BAAsB,SACtB;EAAA,yBAAoB,YAAU,QAAO,UAAS,KACtC,AAAoC,AAC3C;EAAA,mBAAc,EACd;EAAA,UAAU,wBACV;EAAA,0DACA;EAAA,GAAG,GAAa,oBAAQ,QACvB;GAAA,AAAM,aAAc;GACd,OACN;GAAA,QAAc,KACd;GAAA,GAAI,CAAM,yBAA0B,CACnC;IAAA,AAAM,wBAAyB,MAAM,WACrC;IAAA,IAAI,AAAK;IACH,OACN;IAAA,IAAI,YAEJ;IAAA,GAAG,QAAiB,YAAY,aAAa,CAC5C;KAAA,6BACA;KAAA;;KAGF;GAAA,AAAM,aAAc;IAErB;EAAA;;CA3DF;;;CACA;;;CACA;;;CACA;;;CAIe;;;CAAA;;;CAwDf,SACC;EAAA,AAAO;;;;;;CAGR,WACC;EAAA,AAAO;;;;;;;;CAGR,UACQ;EAAA,IAAmC,uBAAnC;GAAA,0BAAmC,mBAAnC;GAAA,WAAmC,iBAAnC;GAAA;GAAA;GAAA;GAAA,QAAmC,KAAnC;GAAA;GAAA;IAAA;KAAA;KAAA;KAAA,AFgEL,SEhEK;KAAA;KAAA;KAAA,AFmEL,SEnEK;MAAA;IAAA,AFqEN,OErEM;IAAA,AFsEN,IEtEM;KAAA;GAAA;;;CAKR,eACC;EAAA;;CAGD,cACC;EAAA,AAAO,OAAM;;CAGd,eACC;EAAA,AAAO;;CAGR,aACC;EAAA,AAAO;;CAGR,YACC,CAAc;EAAA,+BACb;EAAA,GADa,aAEZ;GAAA,YAAmB,wBAAwB,2BAA2B,AAAM,aAAc,kBAA1F;GAAA;GAAA;GACD,OAAK;GAAA,QAHQ,GAGL;GAAA;;;CAKV,yBACC;EAAA,IACC;GAAA,sBAA6B,MAAM,MAAM,CAAO;cAEhD;GAAA;;;CAKF,uBACC;EAAA,AAAO,OAAM;;CAId,4BAAgE,CAC/D;EAAA,iBAAa,oBAAmB,OAChC;EAAA,AAAO;;CAIR,kBACC;EAAA,AAAO,OAAM;;CAId,uBAA+C,CAC9C;EAAA,iBAAa,eAAc,OAC3B;EAAA,AAAO;;CAIR,wBACC;EAAA,AAAO,OAAM;;CAId,6BAAqD,CACpD;EAAA,iBAAa,qBAAoB,OACjC;EAAA,AAAO;;CAIR,0BACC;EAAA,AAAO,OAAM;;CAId,+BAA+E,CAC9E;EAAA,iBAAa,uBAAsB,OACnC;EAAA,AAAO;;CA5IR,qBACC;EAAA,GAAG,GAAa,kBAAO,YACtB;GAAA,OAAO;GACD,SAAG,GAAa,kBAAO,QAC7B;GAAA,AAAO,qBAAc,AAAM,eAAsB,MAAM;GAEvD;GAAA,AAAO,0BAAmB,OAAO,MAAM;;;CAIzC,qBACC;EAAA,GAAG,GAAa,kBAAO,YACtB;GAAA,AAAO,OAAC;GACF,SAAG,GAAa,kBAAO,QAC7B;GAAA,AAAO;GACD,OACN;GAAA,QAAQ,mBAAmB,OACnB,AAAwC;GAAA,gBAChD;GAAA,OAAO","version":3,"file":"Exception.js.map","sources":["../../../../../../haxe/versions/4.1.0/std/haxe/ValueException.hx","../../../../../../haxe/versions/4.1.0/std/js/_std/haxe/NativeStackTrace.hx","../../../../../../haxe/versions/4.1.0/std/haxe/CallStack.hx","../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../haxe/versions/4.1.0/std/js/_std/haxe/Exception.hx"],"sourcesContent":["package haxe;\n\n/**\n\tAn exception containing arbitrary value.\n\n\tThis class is automatically used for throwing values, which don't extend `haxe.Exception`\n\tor native exception type.\n\tFor example:\n\t```haxe\n\tthrow \"Terrible error\";\n\t```\n\twill be compiled to\n\t```haxe\n\tthrow new ValueException(\"Terrible error\");\n\t```\n**/\nclass ValueException extends Exception {\n\t/**\n\t\tThrown value.\n\t**/\n\tpublic var value(default,null):Any;\n\n\tpublic function new(value:Any, ?previous:Exception, ?native:Any):Void {\n\t\tsuper(#if js js.Syntax.code('String({0})', value) #else Std.string(value) #end, previous, native);\n\t\tthis.value = value;\n\t}\n\n\t/**\n\t\tExtract an originally thrown value.\n\n\t\tThis method must return the same value on subsequent calls.\n\t\tUsed internally for catching non-native exceptions.\n\t\tDo _not_ override unless you know what you are doing.\n\t**/\n\toverride function unwrap():Any {\n\t\treturn value;\n\t}\n}","package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule(m:String);\n\tFilePos(s:Null<StackItem>, file:String, line:Int, ?column:Null<Int>);\n\tMethod(classname:Null<String>, method:String);\n\tLocalFunction(?v:Int);\n}\n\n/**\n\tGet information about the call stack.\n**/\n@:allow(haxe.Exception)\n@:using(haxe.CallStack)\nabstract CallStack(Array<StackItem>) from Array<StackItem> {\n\t/**\n\t\tThe length of this stack.\n\t**/\n\tpublic var length(get,never):Int;\n\tinline function get_length():Int return this.length;\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack():Array<StackItem> {\n\t\treturn NativeStackTrace.toHaxe(NativeStackTrace.callStack());\n\t}\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\n\t\tMay not work if catch type was a derivative from `haxe.Exception`.\n\t**/\n\tpublic static function exceptionStack():Array<StackItem> {\n\t\tvar eStack:CallStack = NativeStackTrace.toHaxe(NativeStackTrace.exceptionStack());\n\t\treturn eStack.subtract(callStack()).asArray();\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tstatic public function toString(stack:CallStack):String {\n\t\tvar b = new StringBuf();\n\t\tfor (s in stack.asArray()) {\n\t\t\tb.add('\\nCalled from ');\n\t\t\titemToString(b, s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\t/**\n\t\tReturns a range of entries of current stack from the beginning to the the\n\t\tcommon part of this and `stack`.\n\t**/\n\tpublic function subtract(stack:CallStack):CallStack {\n\t\tvar startIndex = -1;\n\t\tvar i = -1;\n\t\twhile(++i < this.length) {\n\t\t\tfor(j in 0...stack.length) {\n\t\t\t\tif(equalItems(this[i], stack[j])) {\n\t\t\t\t\tif(startIndex < 0) {\n\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t}\n\t\t\t\t\t++i;\n\t\t\t\t\tif(i >= this.length) break;\n\t\t\t\t} else {\n\t\t\t\t\tstartIndex = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(startIndex >= 0) break;\n\t\t}\n\t\treturn startIndex >= 0 ? this.slice(0, startIndex) : this;\n\t}\n\n\t/**\n\t\tMake a copy of the stack.\n\t**/\n\tpublic inline function copy():CallStack {\n\t\treturn this.copy();\n\t}\n\n\t@:arrayAccess public inline function get(index:Int):StackItem {\n\t\treturn this[index];\n\t}\n\n\tinline function asArray():Array<StackItem> {\n\t\treturn this;\n\t}\n\n\tstatic function equalItems(item1:Null<StackItem>, item2:Null<StackItem>):Bool {\n\t\treturn switch([item1, item2]) {\n\t\t\tcase [null, null]: true;\n\t\t\tcase [CFunction, CFunction]: true;\n\t\t\tcase [Module(m1), Module(m2)]:\n\t\t\t\tm1 == m2;\n\t\t\tcase [FilePos(item1, file1, line1, col1), FilePos(item2, file2, line2, col2)]:\n\t\t\t\tfile1 == file2 && line1 == line2 && col1 == col2 && equalItems(item1, item2);\n\t\t\tcase [Method(class1, method1), Method(class2, method2)]:\n\t\t\t\tclass1 == class2 && method1 == method2;\n\t\t\tcase [LocalFunction(v1), LocalFunction(v2)]:\n\t\t\t\tv1 == v2;\n\t\t\tcase _: false;\n\t\t}\n\t}\n\n\tstatic function exceptionToString(e:Exception):String {\n\t\tif(e.previous == null) {\n\t\t\treturn 'Exception: ${e.message}${e.stack}';\n\t\t}\n\t\tvar result = '';\n\t\tvar e:Null<Exception> = e;\n\t\tvar prev:Null<Exception> = null;\n\t\twhile(e != null) {\n\t\t\tif(prev == null) {\n\t\t\t\tresult = 'Exception: ${e.message}${e.stack}' + result;\n\t\t\t} else {\n\t\t\t\tvar prevStack = @:privateAccess e.stack.subtract(prev.stack);\n\t\t\t\tresult = 'Exception: ${e.message}${prevStack}\\n\\nNext ' + result;\n\t\t\t}\n\t\t\tprev = e;\n\t\t\te = e.previous;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic function itemToString(b:StringBuf, s) {\n\t\tswitch (s) {\n\t\t\tcase CFunction:\n\t\t\t\tb.add(\"a C function\");\n\t\t\tcase Module(m):\n\t\t\t\tb.add(\"module \");\n\t\t\t\tb.add(m);\n\t\t\tcase FilePos(s, file, line, col):\n\t\t\t\tif (s != null) {\n\t\t\t\t\titemToString(b, s);\n\t\t\t\t\tb.add(\" (\");\n\t\t\t\t}\n\t\t\t\tb.add(file);\n\t\t\t\tb.add(\" line \");\n\t\t\t\tb.add(line);\n\t\t\t\tif (col != null) {\n\t\t\t\t\tb.add(\" column \");\n\t\t\t\t\tb.add(col);\n\t\t\t\t}\n\t\t\t\tif (s != null)\n\t\t\t\t\tb.add(\")\");\n\t\t\tcase Method(cname, meth):\n\t\t\t\tb.add(cname == null ? \"<unknown>\" : cname);\n\t\t\t\tb.add(\".\");\n\t\t\t\tb.add(meth);\n\t\t\tcase LocalFunction(n):\n\t\t\t\tb.add(\"local function #\");\n\t\t\t\tb.add(n);\n\t\t}\n\t}\n}","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n"]}