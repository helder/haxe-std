{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"Unserializer.js.map","sources":["../../../../../../haxe/versions/4.1.2/std/js/_std/haxe/io/Bytes.hx","../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/haxe/ds/StringMap.hx","../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/haxe/ds/ObjectMap.hx","../../../../../../haxe/versions/4.1.2/std/haxe/ds/List.hx","../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/haxe/ds/IntMap.hx","../../../../../../haxe/versions/4.1.2/std/js/_std/haxe/Exception.hx","../../../../../../haxe/versions/4.1.2/std/js/_std/Type.hx","../../../../../../haxe/versions/4.1.2/std/js/_std/HxOverrides.hx","../../../../../../haxe/versions/4.1.2/std/haxe/Unserializer.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n","package haxe.ds;\n\n#if !js\nextern class StringMap<T> implements haxe.Constraints.IMap<String, T> {\n  public function new(): Void;\n  public function set(key: String, value: T): Void;\n  public function get(key: String): Null<T>;\n  public function exists(key: String): Bool;\n  public function remove(key: String): Bool;\n  public function keys(): Iterator<String>;\n  public function iterator(): Iterator<T>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): StringMap<T>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass StringMap<T> extends genes.util.EsMap<String, T> implements haxe.Constraints.IMap<String, T> {\n  public inline function copy(): StringMap<T> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","package haxe.ds;\n\n#if !js\nextern class ObjectMap<K:{}, V> implements haxe.Constraints.IMap<K, V> {\n  public function new(): Void;\n  public function set(key: K, value: V): Void;\n  public function get(key: K): Null<V>;\n  public function exists(key: K): Bool;\n  public function remove(key: K): Bool;\n  public function keys(): Iterator<K>;\n  public function iterator(): Iterator<V>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<K, V>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): ObjectMap<K, V>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass ObjectMap<K:{},\n  V> extends genes.util.EsMap<K, V> implements haxe.Constraints.IMap<K, V> {\n  public inline function copy(): ObjectMap<K, V> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<K, V>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n/**\n\tA linked-list of elements. The list is composed of element container objects\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole list content every time.\n\n\t@see https://haxe.org/manual/std-List.html\n**/\nclass List<T> {\n\tprivate var h:ListNode<T>;\n\tprivate var q:ListNode<T>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default, null):Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add(item:T) {\n\t\tvar x = ListNode.create(item, null);\n\t\tif (h == null)\n\t\t\th = x;\n\t\telse\n\t\t\tq.next = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push(item:T) {\n\t\tvar x = ListNode.create(item, h);\n\t\th = x;\n\t\tif (q == null)\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first():Null<T> {\n\t\treturn if (h == null) null else h.item;\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last():Null<T> {\n\t\treturn if (q == null) null else q.item;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop():Null<T> {\n\t\tif (h == null)\n\t\t\treturn null;\n\t\tvar x = h.item;\n\t\th = h.next;\n\t\tif (h == null)\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty():Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear():Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurrence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove(v:T):Bool {\n\t\tvar prev:ListNode<T> = null;\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tif (l.item == v) {\n\t\t\t\tif (prev == null)\n\t\t\t\t\th = l.next;\n\t\t\t\telse\n\t\t\t\t\tprev.next = l.next;\n\t\t\t\tif (q == l)\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l.next;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator():ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns an iterator of the List indices and values.\n\t**/\n\t@:pure @:runtime public inline function keyValueIterator():ListKeyValueIterator<T> {\n\t\treturn new ListKeyValueIterator(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile (l != null) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l.item));\n\t\t\tl = l.next;\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep:String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l.item);\n\t\t\tl = l.next;\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter(f:T->Bool) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tvar v = l.item;\n\t\t\tl = l.next;\n\t\t\tif (f(v))\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f:T->X):List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tvar v = l.item;\n\t\t\tl = l.next;\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n}\n\n#if neko\nprivate extern class ListNode<T> extends neko.NativeArray<Dynamic> {\n\tvar item(get, set):T;\n\tvar next(get, set):ListNode<T>;\n\tprivate inline function get_item():T\n\t\treturn this[0];\n\tprivate inline function set_item(v:T):T\n\t\treturn this[0] = v;\n\tprivate inline function get_next():ListNode<T>\n\t\treturn this[1];\n\tprivate inline function set_next(v:ListNode<T>):ListNode<T>\n\t\treturn this[1] = v;\n\tinline static function create<T>(item:T, next:ListNode<T>):ListNode<T> {\n\t\treturn untyped __dollar__array(item, next);\n\t}\n}\n#else\nprivate class ListNode<T> {\n\tpublic var item:T;\n\tpublic var next:ListNode<T>;\n\n\tpublic function new(item:T, next:ListNode<T>) {\n\t\tthis.item = item;\n\t\tthis.next = next;\n\t}\n\n\textern public inline static function create<T>(item:T, next:ListNode<T>):ListNode<T> {\n\t\treturn new ListNode(item, next);\n\t}\n}\n#end\n\nprivate class ListIterator<T> {\n\tvar head:ListNode<T>;\n\n\tpublic inline function new(head:ListNode<T>) {\n\t\tthis.head = head;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tvar val = head.item;\n\t\thead = head.next;\n\t\treturn val;\n\t}\n}\n\nprivate class ListKeyValueIterator<T> {\n\tvar idx:Int;\n\tvar head:ListNode<T>;\n\n\tpublic inline function new(head:ListNode<T>) {\n\t\tthis.head = head;\n\t\tthis.idx = 0;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():{key:Int, value:T} {\n\t\tvar val = head.item;\n\t\thead = head.next;\n\t\treturn {value: val, key: idx++};\n\t}\n}\n","package haxe.ds;\n\n#if !js\nextern class IntMap<T> implements haxe.Constraints.IMap<Int, T> {\n  public function new(): Void;\n  public function set(key: Int, value: T): Void;\n  public function get(key: Int): Null<T>;\n  public function exists(key: Int): Bool;\n  public function remove(key: Int): Bool;\n  public function keys(): Iterator<Int>;\n  public function iterator(): Iterator<T>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<Int, T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): IntMap<T>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass IntMap<T> extends genes.util.EsMap<Int, T> implements haxe.Constraints.IMap<Int, T> {\n  public inline function copy(): IntMap<T> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<Int, T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass(c:Class<Dynamic>);\n\tTEnum(e:Enum<Dynamic>);\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\tpublic static inline function getClass<T>(o:T):Class<T> {\n\t\treturn @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum(o:EnumValue):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn null;\n\t\t\t#if js_enums_as_arrays\n\t\t\treturn o.__enum__;\n\t\t\t#else\n\t\t\treturn $hxEnums[o.__enum__];\n\t\t\t#end\n\t\t}\n\n\tpublic static inline function getSuperClass(c:Class<Dynamic>):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.getSuperClass\", c.__super__);\n\t}\n\n\tpublic static inline function getClassName(c:Class<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getClassName\", c.__name__);\n\t}\n\n\tpublic static inline function getEnumName(e:Enum<Dynamic>):String {\n\t\treturn untyped __define_feature__(\"Type.getEnumName\", e.__ename__);\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic static function resolveClass(name:String):Class<Dynamic>\n\t\tuntyped {\n\t\t\tvar cl:Class<Dynamic> = $hxClasses[name];\n\t\t\t// ensure that this is a class\n\t\t\tif (cl == null || !js.Boot.isClass(cl))\n\t\t\t\treturn null;\n\t\t\treturn cl;\n\t\t}\n\n\tpublic static function resolveEnum(name:String):Enum<Dynamic>\n\t\tuntyped {\n\t\t\tvar e:Dynamic = $hxClasses[name];\n\t\t\t// ensure that this is an enum\n\t\t\tif (e == null || !js.Boot.isEnum(e))\n\t\t\t\treturn null;\n\t\t\treturn e;\n\t\t}\n\t#else\n\tpublic static inline function resolveClass(name:String):Class<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveClass\", $hxClasses[name]);\n\t}\n\n\tpublic static inline function resolveEnum(name:String):Enum<Dynamic> {\n\t\treturn untyped __define_feature__(\"Type.resolveEnum\", $hxEnums[name]);\n\t}\n\t#end\n\n\t#if (js_es < 5)\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T {\n\t\tswitch (args.length) {\n\t\t\tcase 0:\n\t\t\t\treturn js.Syntax.construct(cl);\n\t\t\tcase 1:\n\t\t\t\treturn js.Syntax.construct(cl, args[0]);\n\t\t\tcase 2:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1]);\n\t\t\tcase 3:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2]);\n\t\t\tcase 4:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3]);\n\t\t\tcase 5:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4]);\n\t\t\tcase 6:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5]);\n\t\t\tcase 7:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t\t\tcase 8:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n\t\t\tcase 9:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n\t\t\tcase 10:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n\t\t\tcase 11:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10]);\n\t\t\tcase 12:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11]);\n\t\t\tcase 13:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12]);\n\t\t\tcase 14:\n\t\t\t\treturn js.Syntax.construct(cl, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11],\n\t\t\t\t\targs[12], args[13]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t}\n\n\tpublic static function createEmptyInstance<T>(cl:Class<T>):T\n\t\tuntyped {\n\t\t\tjs.Syntax.code(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\t\treturn js.Syntax.code(\"new empty()\");\n\t\t}\n\t#else\n\tpublic static function createInstance<T>(cl:Class<T>, args:Array<Dynamic>):T {\n\t\tvar ctor = ((cast js.lib.Function).prototype.bind : js.lib.Function).apply(cl, [null].concat(args));\n\t\treturn js.Syntax.code(\"new ({0})\", ctor); // cannot use `js.Syntax.construct` because we need parens if `ctor` is fused in\n\t}\n\n\tpublic static inline function createEmptyInstance<T>(cl:Class<T>):T {\n\t\treturn js.lib.Object.create((cast cl).prototype);\n\t}\n\t#end\n\n\tpublic static function createEnum<T>(e:Enum<T>, constr:String, ?params:Array<Dynamic>):T {\n\t\tvar f:Dynamic = Reflect.field(e, constr);\n\t\tif (f == null)\n\t\t\tthrow \"No such constructor \" + constr;\n\t\tif (Reflect.isFunction(f)) {\n\t\t\tif (params == null)\n\t\t\t\tthrow \"Constructor \" + constr + \" need parameters\";\n\t\t\treturn Reflect.callMethod(e, f, params);\n\t\t}\n\t\tif (params != null && params.length != 0)\n\t\t\tthrow \"Constructor \" + constr + \" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>(e:Enum<T>, index:Int, ?params:Array<Dynamic>):T {\n\t\tvar c:String = (untyped e.__constructs__)[index];\n\t\tif (c == null)\n\t\t\tthrow index + \" is not a valid enum constructor index\";\n\t\treturn createEnum(e, c, params);\n\t}\n\n\t#if (js_es >= 6)\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar result = [];\n\t\twhile (c != null) {\n\t\t\tfor (name in js.lib.Object.getOwnPropertyNames((cast c).prototype)) {\n\t\t\t\tswitch name {\n\t\t\t\t\tcase \"constructor\" | \"__class__\" | \"__properties__\":\n\t\t\t\t\t// skip special names\n\t\t\t\t\tcase _:\n\t\t\t\t\t\tif (result.indexOf(name) == -1)\n\t\t\t\t\t\t\tresult.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = getSuperClass(c);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = js.lib.Object.getOwnPropertyNames(cast c);\n\t\ta.remove(\"__id__\");\n\t\ta.remove(\"hx__closures__\");\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__isInterface__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__instanceFields__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\ta.remove(\"name\");\n\t\ta.remove(\"length\");\n\t\treturn a;\n\t}\n\t#else\n\tpublic static function getInstanceFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = [];\n\t\tjs.Syntax.code(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields(c:Class<Dynamic>):Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\t#end\n\n\tpublic static inline function getEnumConstructs(e:Enum<Dynamic>):Array<String> {\n\t\treturn ((cast e).__constructs__ : Array<String>).copy();\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function typeof(v:Dynamic):ValueType {\n\t\tswitch (js.Syntax.typeof(v)) {\n\t\t\tcase \"boolean\":\n\t\t\t\treturn TBool;\n\t\t\tcase \"string\":\n\t\t\t\treturn TClass(String);\n\t\t\tcase \"number\":\n\t\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\t\tif (Math.ceil(v) == v % 2147483648.0)\n\t\t\t\t\treturn TInt;\n\t\t\t\treturn TFloat;\n\t\t\tcase \"object\":\n\t\t\t\tif (v == null)\n\t\t\t\t\treturn TNull;\n\t\t\t\tvar e = v.__enum__;\n\t\t\t\tif (e != null) {\n\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\treturn TEnum(e);\n\t\t\t\t\t#else\n\t\t\t\t\treturn TEnum(untyped $hxEnums[e]);\n\t\t\t\t\t#end\n\t\t\t\t}\n\t\t\t\tvar c = js.Boot.getClass(v);\n\t\t\t\tif (c != null)\n\t\t\t\t\treturn TClass(c);\n\t\t\t\treturn TObject;\n\t\t\tcase \"function\":\n\t\t\t\tif (js.Boot.isClass(v) || js.Boot.isEnum(v))\n\t\t\t\t\treturn TObject;\n\t\t\t\treturn TFunction;\n\t\t\tcase \"undefined\":\n\t\t\t\treturn TNull;\n\t\t\tdefault:\n\t\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T:EnumValue>(a:T, b:T):Bool\n\t\tuntyped {\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\ttry {\n\t\t\t\tvar e = a.__enum__;\n\t\t\t\tif (e == null || e != b.__enum__)\n\t\t\t\t\treturn false;\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\tif (a[0] != b[0])\n\t\t\t\t\treturn false;\n\t\t\t\tfor (i in 2...a.length)\n\t\t\t\t\tif (!enumEq(a[i], b[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t#else\n\t\t\t\tif (a._hx_index != b._hx_index)\n\t\t\t\t\treturn false;\n\t\t\t\tvar enm = $hxEnums[e];\n\t\t\t\tvar ctorName = enm.__constructs__[a._hx_index];\n\t\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\t\tfor (f in params) {\n\t\t\t\t\tif (!enumEq(a[f], b[f])) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t} catch (e:Dynamic) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\tpublic inline static function enumConstructor(e:EnumValue):String {\n\t\t#if js_enums_as_arrays\n\t\treturn untyped e[0];\n\t\t#else\n\t\treturn untyped $hxEnums[e.__enum__].__constructs__[e._hx_index];\n\t\t#end\n\t}\n\n\t#if js_enums_as_arrays\n\tpublic inline static function enumParameters(e:EnumValue):Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\t#else\n\tpublic static function enumParameters(e:EnumValue):Array<Dynamic>\n\t\tuntyped {\n\t\t\tvar enm:Enum<Dynamic> = $hxEnums[e.__enum__];\n\t\t\tvar ctorName:String = enm.__constructs__[e._hx_index];\n\t\t\tvar params:Array<String> = enm[ctorName].__params__;\n\t\t\treturn params != null ? [for (p in params) e[p]] : [];\n\t\t}\n\t#end\n\n\tpublic inline static function enumIndex(e:EnumValue):Int {\n\t\t#if !js_enums_as_arrays\n\t\treturn untyped e._hx_index;\n\t\t#else\n\t\treturn untyped e[1];\n\t\t#end\n\t}\n\n\tpublic inline static function allEnums<T>(e:Enum<T>):Array<T> {\n\t\treturn untyped __define_feature__(\"Type.allEnums\", e.__empty_constructs__.slice());\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\tstatic function dateStr(date:Date):String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear() + \"-\" + (if (m < 10) \"0\" + m else \"\" + m) + \"-\" + (if (d < 10) \"0\" + d else \"\" + d) + \" \"\n\t\t\t+ (if (h < 10) \"0\" + h else \"\" + h) + \":\" + (if (mi < 10) \"0\" + mi else \"\" + mi) + \":\" + (if (s < 10) \"0\" + s else \"\" + s);\n\t}\n\n\tstatic function strDate(s:String):Date {\n\t\tswitch (s.length) {\n\t\t\tcase 8: // hh:mm:ss\n\t\t\t\tvar k = s.split(\":\");\n\t\t\t\tvar d = js.Syntax.construct(Date);\n\t\t\t\t(cast d)[cast \"setTime\"](0);\n\t\t\t\t(cast d)[cast \"setUTCHours\"](k[0]);\n\t\t\t\t(cast d)[cast \"setUTCMinutes\"](k[1]);\n\t\t\t\t(cast d)[cast \"setUTCSeconds\"](k[2]);\n\t\t\t\treturn d;\n\t\t\tcase 10: // YYYY-MM-DD\n\t\t\t\tvar k = s.split(\"-\");\n\t\t\t\treturn new Date(cast k[0], (cast k[1]) - 1, cast k[2], 0, 0, 0);\n\t\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\t\tvar k = s.split(\" \");\n\t\t\t\tvar y = k[0].split(\"-\");\n\t\t\t\tvar t = k[1].split(\":\");\n\t\t\t\treturn new Date(cast y[0], (cast y[1]) - 1, cast y[2], cast t[0], cast t[1], cast t[2]);\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\t@:pure\n\tstatic function cca(s:String, index:Int):Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif (x != x) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\t@:pure\n\tstatic function substr(s:String, pos:Int, ?len:Int):String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (cast s).substr(pos, len);\n\t}\n\n\t@:pure\n\tstatic function indexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0)\n\t\t\t\ti = 0;\n\t\t}\n\t\twhile (i < len) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@:pure\n\tstatic function lastIndexOf<T>(a:Array<T>, obj:T, i:Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0) {\n\t\t\tif (js.Syntax.strictEq(a[i], obj))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>(a:Array<T>, obj:T) {\n\t\tvar i = a.indexOf(obj);\n\t\tif (i == -1)\n\t\t\treturn false;\n\t\ta.splice(i, 1);\n\t\treturn true;\n\t}\n\n\t@:pure\n\tstatic function iter<T>(a:Array<T>):Iterator<T>\n\t\tuntyped {\n\t\t\treturn {\n\t\t\t\tcur: 0,\n\t\t\t\tarr: a,\n\t\t\t\thasNext: function() {\n\t\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t\t},\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t@:ifFeature(\"anon_read.keyValueIterator\", \"dynamic_read.keyValueIterator\", \"closure_read.keyValueIterator\")\n\tstatic function keyValueIter<T>( a : Array<T> ) {\n\t\treturn new haxe.iterators.ArrayKeyValueIterator(a);\n\t}\n\n\t@:pure\n\tstatic function now(): Float return js.lib.Date.now();\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__('HxOverrides.indexOf',\n\t\t\t\tif (Array.prototype.indexOf) js.Syntax.code(\"HxOverrides\").indexOf = function(a, o, i) return Array.prototype.indexOf.call(a, o, i));\n\t\t\t__feature__('HxOverrides.lastIndexOf',\n\t\t\t\tif (Array.prototype.lastIndexOf) js.Syntax.code(\"HxOverrides\").lastIndexOf = function(a, o, i) return Array.prototype.lastIndexOf.call(a, o, i));\n\t\t\t#end\n\n\t\t\t__feature__('HxOverrides.now',\n\t\t\t\tif (js.Syntax.typeof(performance) != 'undefined' && js.Syntax.typeof(performance.now) == 'function') {\n\t\t\t\t\tHxOverrides.now = performance.now.bind(performance);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe;\n\nimport haxe.ds.List;\n\n@:noDoc\ntypedef TypeResolver = {\n\tfunction resolveClass(name:String):Class<Dynamic>;\n\tfunction resolveEnum(name:String):Enum<Dynamic>;\n}\n\n/**\n\tThe `Unserializer` class is the complement to the `Serializer` class. It parses\n\ta serialization `String` and creates objects from the contained data.\n\n\tThis class can be used in two ways:\n\n\t- create a `new Unserializer()` instance with a given serialization\n\t\tString, then call its `unserialize()` method until all values are\n\t\textracted\n\t- call `Unserializer.run()`  to unserialize a single value from a given\n\t\tString\n\n\tThe specification of the serialization format can be found here:\n\t<https://haxe.org/manual/serialization/format>\n**/\nclass Unserializer {\n\t/**\n\t\tThis value can be set to use custom type resolvers.\n\n\t\tA type resolver finds a `Class` or `Enum` instance from a given `String`.\n\t\tBy default, the Haxe `Type` Api is used.\n\n\t\tA type resolver must provide two methods:\n\n\t\t1. `resolveClass(name:String):Class<Dynamic>` is called to determine a\n\t\t\t\t`Class` from a class name\n\t\t2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an\n\t\t\t\t`Enum` from an enum name\n\n\t\tThis value is applied when a new `Unserializer` instance is created.\n\t\tChanging it afterwards has no effect on previously created instances.\n\t**/\n\tpublic static var DEFAULT_RESOLVER:TypeResolver = new DefaultResolver();\n\n\tstatic var BASE64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:\";\n\n\t#if !neko\n\tstatic var CODES = null;\n\n\tstatic function initCodes() {\n\t\tvar codes = #if flash new flash.utils.ByteArray(); #else new Array(); #end\n\t\tfor (i in 0...BASE64.length)\n\t\t\tcodes[StringTools.fastCodeAt(BASE64, i)] = i;\n\t\treturn codes;\n\t}\n\t#end\n\n\tvar buf:String;\n\tvar pos:Int;\n\tvar length:Int;\n\tvar cache:Array<Dynamic>;\n\tvar scache:Array<String>;\n\tvar resolver:TypeResolver;\n\t#if neko\n\tvar upos:Int;\n\t#end\n\n\t/**\n\t\tCreates a new Unserializer instance, with its internal buffer\n\t\tinitialized to `buf`.\n\n\t\tThis does not parse `buf` immediately. It is parsed only when calls to\n\t\t`this.unserialize` are made.\n\n\t\tEach Unserializer instance maintains its own cache.\n\t**/\n\tpublic function new(buf:String) {\n\t\tthis.buf = buf;\n\t\tlength = buf.length;\n\t\tpos = 0;\n\t\t#if neko\n\t\tupos = 0;\n\t\t#end\n\t\tscache = new Array();\n\t\tcache = new Array();\n\t\tvar r = DEFAULT_RESOLVER;\n\t\tif (r == null) {\n\t\t\tr = new DefaultResolver();\n\t\t\tDEFAULT_RESOLVER = r;\n\t\t}\n\t\tresolver = r;\n\t}\n\n\t/**\n\t\tSets the type resolver of `this` Unserializer instance to `r`.\n\n\t\tIf `r` is `null`, a special resolver is used which returns `null` for all\n\t\tinput values.\n\n\t\tSee `DEFAULT_RESOLVER` for more information on type resolvers.\n\t**/\n\tpublic function setResolver(r) {\n\t\tif (r == null)\n\t\t\tresolver = NullResolver.instance;\n\t\telse\n\t\t\tresolver = r;\n\t}\n\n\t/**\n\t\tGets the type resolver of `this` Unserializer instance.\n\n\t\tSee `DEFAULT_RESOLVER` for more information on type resolvers.\n\t**/\n\tpublic function getResolver() {\n\t\treturn resolver;\n\t}\n\n\tinline function get(p):Int {\n\t\treturn StringTools.fastCodeAt(buf, p);\n\t}\n\n\tfunction readDigits() {\n\t\tvar k = 0;\n\t\tvar s = false;\n\t\tvar fpos = pos;\n\t\twhile (true) {\n\t\t\tvar c = get(pos);\n\t\t\tif (StringTools.isEof(c))\n\t\t\t\tbreak;\n\t\t\tif (c == \"-\".code) {\n\t\t\t\tif (pos != fpos)\n\t\t\t\t\tbreak;\n\t\t\t\ts = true;\n\t\t\t\tpos++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (c < \"0\".code || c > \"9\".code)\n\t\t\t\tbreak;\n\t\t\tk = k * 10 + (c - \"0\".code);\n\t\t\tpos++;\n\t\t}\n\t\tif (s)\n\t\t\tk *= -1;\n\t\treturn k;\n\t}\n\n\tfunction readFloat() {\n\t\tvar p1 = pos;\n\t\twhile (true) {\n\t\t\tvar c = get(pos);\n\t\t\tif (StringTools.isEof(c))\n\t\t\t\tbreak;\n\t\t\t// + - . , 0-9\n\t\t\tif ((c >= 43 && c < 58) || c == \"e\".code || c == \"E\".code)\n\t\t\t\tpos++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn Std.parseFloat(buf.substr(p1, pos - p1));\n\t}\n\n\tfunction unserializeObject(o:{}) {\n\t\twhile (true) {\n\t\t\tif (pos >= length)\n\t\t\t\tthrow \"Invalid object\";\n\t\t\tif (get(pos) == \"g\".code)\n\t\t\t\tbreak;\n\t\t\tvar k:Dynamic = unserialize();\n\t\t\tif (!Std.isOfType(k, String))\n\t\t\t\tthrow \"Invalid object key\";\n\t\t\tvar v = unserialize();\n\t\t\tReflect.setField(o, k, v);\n\t\t}\n\t\tpos++;\n\t}\n\n\tfunction unserializeEnum<T>(edecl:Enum<T>, tag:String) {\n\t\tif (get(pos++) != \":\".code)\n\t\t\tthrow \"Invalid enum format\";\n\t\tvar nargs = readDigits();\n\t\tif (nargs == 0)\n\t\t\treturn Type.createEnum(edecl, tag);\n\t\tvar args = new Array();\n\t\twhile (nargs-- > 0)\n\t\t\targs.push(unserialize());\n\t\treturn Type.createEnum(edecl, tag, args);\n\t}\n\n\t/**\n\t\tUnserializes the next part of `this` Unserializer instance and returns\n\t\tthe according value.\n\n\t\tThis function may call `this.resolver.resolveClass` to determine a\n\t\tClass from a String, and `this.resolver.resolveEnum` to determine an\n\t\tEnum from a String.\n\n\t\tIf `this` Unserializer instance contains no more or invalid data, an\n\t\texception is thrown.\n\n\t\tThis operation may fail on structurally valid data if a type cannot be\n\t\tresolved or if a field cannot be set. This can happen when unserializing\n\t\tStrings that were serialized on a different Haxe target, in which the\n\t\tserialization side has to make sure not to include platform-specific\n\t\tdata.\n\n\t\tClasses are created from `Type.createEmptyInstance`, which means their\n\t\tconstructors are not called.\n\t**/\n\tpublic function unserialize():Dynamic {\n\t\tswitch (get(pos++)) {\n\t\t\tcase \"n\".code:\n\t\t\t\treturn null;\n\t\t\tcase \"t\".code:\n\t\t\t\treturn true;\n\t\t\tcase \"f\".code:\n\t\t\t\treturn false;\n\t\t\tcase \"z\".code:\n\t\t\t\treturn 0;\n\t\t\tcase \"i\".code:\n\t\t\t\treturn readDigits();\n\t\t\tcase \"d\".code:\n\t\t\t\treturn readFloat();\n\t\t\tcase \"y\".code:\n\t\t\t\tvar len = readDigits();\n\t\t\t\tif (get(pos++) != \":\".code || length - pos < len)\n\t\t\t\t\tthrow \"Invalid string length\";\n\t\t\t\tvar s = buf.substr(pos, len);\n\t\t\t\tpos += len;\n\t\t\t\ts = StringTools.urlDecode(s);\n\t\t\t\tscache.push(s);\n\t\t\t\treturn s;\n\t\t\tcase \"k\".code:\n\t\t\t\treturn Math.NaN;\n\t\t\tcase \"m\".code:\n\t\t\t\treturn Math.NEGATIVE_INFINITY;\n\t\t\tcase \"p\".code:\n\t\t\t\treturn Math.POSITIVE_INFINITY;\n\t\t\tcase \"a\".code:\n\t\t\t\tvar buf = buf;\n\t\t\t\tvar a = new Array<Dynamic>();\n\t\t\t\t#if cpp\n\t\t\t\tvar cachePos = cache.length;\n\t\t\t\t#end\n\t\t\t\tcache.push(a);\n\t\t\t\twhile (true) {\n\t\t\t\t\tvar c = get(pos);\n\t\t\t\t\tif (c == \"h\".code) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (c == \"u\".code) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tvar n = readDigits();\n\t\t\t\t\t\ta[a.length + n - 1] = null;\n\t\t\t\t\t} else\n\t\t\t\t\t\ta.push(unserialize());\n\t\t\t\t}\n\t\t\t\t#if cpp\n\t\t\t\treturn cache[cachePos] = cpp.NativeArray.resolveVirtualArray(a);\n\t\t\t\t#else\n\t\t\t\treturn a;\n\t\t\t\t#end\n\t\t\tcase \"o\".code:\n\t\t\t\tvar o = {};\n\t\t\t\tcache.push(o);\n\t\t\t\tunserializeObject(o);\n\t\t\t\treturn o;\n\t\t\tcase \"r\".code:\n\t\t\t\tvar n = readDigits();\n\t\t\t\tif (n < 0 || n >= cache.length)\n\t\t\t\t\tthrow \"Invalid reference\";\n\t\t\t\treturn cache[n];\n\t\t\tcase \"R\".code:\n\t\t\t\tvar n = readDigits();\n\t\t\t\tif (n < 0 || n >= scache.length)\n\t\t\t\t\tthrow \"Invalid string reference\";\n\t\t\t\treturn scache[n];\n\t\t\tcase \"x\".code:\n\t\t\t\tthrow unserialize();\n\t\t\tcase \"c\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar cl = resolver.resolveClass(name);\n\t\t\t\tif (cl == null)\n\t\t\t\t\tthrow \"Class not found \" + name;\n\t\t\t\tvar o = Type.createEmptyInstance(cl);\n\t\t\t\tcache.push(o);\n\t\t\t\tunserializeObject(o);\n\t\t\t\treturn o;\n\t\t\tcase \"w\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar edecl = resolver.resolveEnum(name);\n\t\t\t\tif (edecl == null)\n\t\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\t\tvar e = unserializeEnum(edecl, unserialize());\n\t\t\t\tcache.push(e);\n\t\t\t\treturn e;\n\t\t\tcase \"j\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar edecl = resolver.resolveEnum(name);\n\t\t\t\tif (edecl == null)\n\t\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\t\tpos++; /* skip ':' */\n\t\t\t\tvar index = readDigits();\n\t\t\t\tvar tag = Type.getEnumConstructs(edecl)[index];\n\t\t\t\tif (tag == null)\n\t\t\t\t\tthrow \"Unknown enum index \" + name + \"@\" + index;\n\t\t\t\tvar e = unserializeEnum(edecl, tag);\n\t\t\t\tcache.push(e);\n\t\t\t\treturn e;\n\t\t\tcase \"l\".code:\n\t\t\t\tvar l = new List();\n\t\t\t\tcache.push(l);\n\t\t\t\tvar buf = buf;\n\t\t\t\twhile (get(pos) != \"h\".code)\n\t\t\t\t\tl.add(unserialize());\n\t\t\t\tpos++;\n\t\t\t\treturn l;\n\t\t\tcase \"b\".code:\n\t\t\t\tvar h = new haxe.ds.StringMap();\n\t\t\t\tcache.push(h);\n\t\t\t\tvar buf = buf;\n\t\t\t\twhile (get(pos) != \"h\".code) {\n\t\t\t\t\tvar s = unserialize();\n\t\t\t\t\th.set(s, unserialize());\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t\treturn h;\n\t\t\tcase \"q\".code:\n\t\t\t\tvar h = new haxe.ds.IntMap();\n\t\t\t\tcache.push(h);\n\t\t\t\tvar buf = buf;\n\t\t\t\tvar c = get(pos++);\n\t\t\t\twhile (c == \":\".code) {\n\t\t\t\t\tvar i = readDigits();\n\t\t\t\t\th.set(i, unserialize());\n\t\t\t\t\tc = get(pos++);\n\t\t\t\t}\n\t\t\t\tif (c != \"h\".code)\n\t\t\t\t\tthrow \"Invalid IntMap format\";\n\t\t\t\treturn h;\n\t\t\tcase \"M\".code:\n\t\t\t\tvar h = new haxe.ds.ObjectMap();\n\t\t\t\tcache.push(h);\n\t\t\t\tvar buf = buf;\n\t\t\t\twhile (get(pos) != \"h\".code) {\n\t\t\t\t\tvar s = unserialize();\n\t\t\t\t\th.set(s, unserialize());\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t\treturn h;\n\t\t\tcase \"v\".code:\n\t\t\t\tvar d;\n\t\t\t\tif (get(pos) >= '0'.code && get(pos) <= '9'.code && get(pos + 1) >= '0'.code && get(pos + 1) <= '9'.code && get(pos + 2) >= '0'.code\n\t\t\t\t\t&& get(pos + 2) <= '9'.code && get(pos + 3) >= '0'.code && get(pos + 3) <= '9'.code && get(pos + 4) == '-'.code) {\n\t\t\t\t\t// Included for backwards compatibility\n\t\t\t\t\td = Date.fromString(buf.substr(pos, 19));\n\t\t\t\t\tpos += 19;\n\t\t\t\t} else\n\t\t\t\t\td = Date.fromTime(readFloat());\n\t\t\t\tcache.push(d);\n\t\t\t\treturn d;\n\t\t\tcase \"s\".code:\n\t\t\t\tvar len = readDigits();\n\t\t\t\tvar buf = buf;\n\t\t\t\tif (get(pos++) != \":\".code || length - pos < len)\n\t\t\t\t\tthrow \"Invalid bytes length\";\n\t\t\t\t#if neko\n\t\t\t\tvar bytes = haxe.io.Bytes.ofData(base_decode(untyped buf.substr(pos, len).__s, untyped BASE64.__s));\n\t\t\t\t#elseif php\n\t\t\t\tvar phpEncoded = php.Global.strtr(buf.substr(pos, len), '%:', '+/');\n\t\t\t\tvar bytes = haxe.io.Bytes.ofData(php.Global.base64_decode(phpEncoded));\n\t\t\t\t#else\n\t\t\t\tvar codes = CODES;\n\t\t\t\tif (codes == null) {\n\t\t\t\t\tcodes = initCodes();\n\t\t\t\t\tCODES = codes;\n\t\t\t\t}\n\t\t\t\tvar i = pos;\n\t\t\t\tvar rest = len & 3;\n\t\t\t\tvar size = (len >> 2) * 3 + ((rest >= 2) ? rest - 1 : 0);\n\t\t\t\tvar max = i + (len - rest);\n\t\t\t\tvar bytes = haxe.io.Bytes.alloc(size);\n\t\t\t\tvar bpos = 0;\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c1 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\tvar c2 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\tbytes.set(bpos++, (c1 << 2) | (c2 >> 4));\n\t\t\t\t\tvar c3 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\tbytes.set(bpos++, (c2 << 4) | (c3 >> 2));\n\t\t\t\t\tvar c4 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\tbytes.set(bpos++, (c3 << 6) | c4);\n\t\t\t\t}\n\t\t\t\tif (rest >= 2) {\n\t\t\t\t\tvar c1 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\tvar c2 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\tbytes.set(bpos++, (c1 << 2) | (c2 >> 4));\n\t\t\t\t\tif (rest == 3) {\n\t\t\t\t\t\tvar c3 = codes[StringTools.fastCodeAt(buf, i++)];\n\t\t\t\t\t\tbytes.set(bpos++, (c2 << 4) | (c3 >> 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t\tpos += len;\n\t\t\t\tcache.push(bytes);\n\t\t\t\treturn bytes;\n\t\t\tcase \"C\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar cl = resolver.resolveClass(name);\n\t\t\t\tif (cl == null)\n\t\t\t\t\tthrow \"Class not found \" + name;\n\t\t\t\tvar o:Dynamic = Type.createEmptyInstance(cl);\n\t\t\t\tcache.push(o);\n\t\t\t\to.hxUnserialize(this);\n\t\t\t\tif (get(pos++) != \"g\".code)\n\t\t\t\t\tthrow \"Invalid custom data\";\n\t\t\t\treturn o;\n\t\t\tcase \"A\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar cl = resolver.resolveClass(name);\n\t\t\t\tif (cl == null)\n\t\t\t\t\tthrow \"Class not found \" + name;\n\t\t\t\treturn cl;\n\t\t\tcase \"B\".code:\n\t\t\t\tvar name = unserialize();\n\t\t\t\tvar e = resolver.resolveEnum(name);\n\t\t\t\tif (e == null)\n\t\t\t\t\tthrow \"Enum not found \" + name;\n\t\t\t\treturn e;\n\t\t\tdefault:\n\t\t}\n\t\tpos--;\n\t\tthrow(\"Invalid char \" + buf.charAt(pos) + \" at position \" + pos);\n\t}\n\n\t/**\n\t\tUnserializes `v` and returns the according value.\n\n\t\tThis is a convenience function for creating a new instance of\n\t\tUnserializer with `v` as buffer and calling its `unserialize()` method\n\t\tonce.\n\t**/\n\tpublic static function run(v:String):Dynamic {\n\t\treturn new Unserializer(v).unserialize();\n\t}\n\n\t#if neko\n\tstatic var base_decode = neko.Lib.load(\"std\", \"base_decode\", 2);\n\t#end\n}\n\nprivate class DefaultResolver {\n\tpublic function new() {}\n\n\tpublic inline function resolveClass(name:String):Class<Dynamic>\n\t\treturn Type.resolveClass(name);\n\n\tpublic inline function resolveEnum(name:String):Enum<Dynamic>\n\t\treturn Type.resolveEnum(name);\n}\n\nprivate class NullResolver {\n\tfunction new() {}\n\n\tpublic inline function resolveClass(name:String):Class<Dynamic>\n\t\treturn null;\n\n\tpublic inline function resolveEnum(name:String):Enum<Dynamic>\n\t\treturn null;\n\n\tpublic static var instance(get, null):NullResolver;\n\n\tinline static function get_instance():NullResolver {\n\t\tif (instance == null)\n\t\t\tinstance = new NullResolver();\n\t\treturn instance;\n\t}\n}\n"]}