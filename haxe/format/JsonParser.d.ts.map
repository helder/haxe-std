{"sourceRoot":"","names":[],"mappings":";;;;;;;;;AAgCA;;;;;;;;;;;;QAWC,WCtBgB","version":3,"file":"JsonParser.d.ts.map","sources":["../../../../../../../haxe/versions/4.0.1/std/haxe/format/JsonParser.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/String.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.format;\n\n/**\n\tAn implementation of JSON parser in Haxe.\n\n\tThis class is used by `haxe.Json` when native JSON implementation\n\tis not available.\n\n\t@see https://haxe.org/manual/std-Json-parsing.html\n**/\nclass JsonParser {\n\t/**\n\t\tParses given JSON-encoded `str` and returns the resulting object.\n\n\t\tJSON objects are parsed into anonymous structures and JSON arrays\n\t\tare parsed into `Array<Dynamic>`.\n\n\t\tIf given `str` is not valid JSON, an exception will be thrown.\n\n\t\tIf `str` is null, the result is unspecified.\n\t**/\n\tstatic public inline function parse(str:String):Dynamic {\n\t\treturn new JsonParser(str).doParse();\n\t}\n\n\tvar str:String;\n\tvar pos:Int;\n\n\tfunction new(str:String) {\n\t\tthis.str = str;\n\t\tthis.pos = 0;\n\t}\n\n\tfunction doParse():Dynamic {\n\t\tvar result = parseRec();\n\t\tvar c;\n\t\twhile (!StringTools.isEof(c = nextChar())) {\n\t\t\tswitch (c) {\n\t\t\t\tcase ' '.code, '\\r'.code, '\\n'.code, '\\t'.code:\n\t\t\t\t// allow trailing whitespace\n\t\t\t\tdefault:\n\t\t\t\t\tinvalidChar();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction parseRec():Dynamic {\n\t\twhile (true) {\n\t\t\tvar c = nextChar();\n\t\t\tswitch (c) {\n\t\t\t\tcase ' '.code, '\\r'.code, '\\n'.code, '\\t'.code:\n\t\t\t\t// loop\n\t\t\t\tcase '{'.code:\n\t\t\t\t\tvar obj = {}, field = null, comma:Null<Bool> = null;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tvar c = nextChar();\n\t\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\t\tcase ' '.code, '\\r'.code, '\\n'.code, '\\t'.code:\n\t\t\t\t\t\t\t// loop\n\t\t\t\t\t\t\tcase '}'.code:\n\t\t\t\t\t\t\t\tif (field != null || comma == false)\n\t\t\t\t\t\t\t\t\tinvalidChar();\n\t\t\t\t\t\t\t\treturn obj;\n\t\t\t\t\t\t\tcase ':'.code:\n\t\t\t\t\t\t\t\tif (field == null)\n\t\t\t\t\t\t\t\t\tinvalidChar();\n\t\t\t\t\t\t\t\tReflect.setField(obj, field, parseRec());\n\t\t\t\t\t\t\t\tfield = null;\n\t\t\t\t\t\t\t\tcomma = true;\n\t\t\t\t\t\t\tcase ','.code:\n\t\t\t\t\t\t\t\tif (comma) comma = false else invalidChar();\n\t\t\t\t\t\t\tcase '\"'.code:\n\t\t\t\t\t\t\t\tif (field != null || comma) invalidChar();\n\t\t\t\t\t\t\t\tfield = parseString();\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tinvalidChar();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase '['.code:\n\t\t\t\t\tvar arr = [], comma:Null<Bool> = null;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tvar c = nextChar();\n\t\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\t\tcase ' '.code, '\\r'.code, '\\n'.code, '\\t'.code:\n\t\t\t\t\t\t\t// loop\n\t\t\t\t\t\t\tcase ']'.code:\n\t\t\t\t\t\t\t\tif (comma == false) invalidChar();\n\t\t\t\t\t\t\t\treturn arr;\n\t\t\t\t\t\t\tcase ','.code:\n\t\t\t\t\t\t\t\tif (comma) comma = false else invalidChar();\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (comma) invalidChar();\n\t\t\t\t\t\t\t\tpos--;\n\t\t\t\t\t\t\t\tarr.push(parseRec());\n\t\t\t\t\t\t\t\tcomma = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase 't'.code:\n\t\t\t\t\tvar save = pos;\n\t\t\t\t\tif (nextChar() != 'r'.code || nextChar() != 'u'.code || nextChar() != 'e'.code) {\n\t\t\t\t\t\tpos = save;\n\t\t\t\t\t\tinvalidChar();\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\tcase 'f'.code:\n\t\t\t\t\tvar save = pos;\n\t\t\t\t\tif (nextChar() != 'a'.code || nextChar() != 'l'.code || nextChar() != 's'.code || nextChar() != 'e'.code) {\n\t\t\t\t\t\tpos = save;\n\t\t\t\t\t\tinvalidChar();\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\tcase 'n'.code:\n\t\t\t\t\tvar save = pos;\n\t\t\t\t\tif (nextChar() != 'u'.code || nextChar() != 'l'.code || nextChar() != 'l'.code) {\n\t\t\t\t\t\tpos = save;\n\t\t\t\t\t\tinvalidChar();\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\tcase '\"'.code:\n\t\t\t\t\treturn parseString();\n\t\t\t\tcase '0'.code, '1'.code, '2'.code, '3'.code, '4'.code, '5'.code, '6'.code, '7'.code, '8'.code, '9'.code, '-'.code:\n\t\t\t\t\treturn parseNumber(c);\n\t\t\t\tdefault:\n\t\t\t\t\tinvalidChar();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString() {\n\t\tvar start = pos;\n\t\tvar buf:StringBuf = null;\n\t\t#if target.unicode\n\t\tvar prev = -1;\n\t\tinline function cancelSurrogate() {\n\t\t\t// invalid high surrogate (not followed by low surrogate)\n\t\t\tbuf.addChar(0xFFFD);\n\t\t\tprev = -1;\n\t\t}\n\t\t#end\n\t\twhile (true) {\n\t\t\tvar c = nextChar();\n\t\t\tif (c == '\"'.code)\n\t\t\t\tbreak;\n\t\t\tif (c == '\\\\'.code) {\n\t\t\t\tif (buf == null) {\n\t\t\t\t\tbuf = new StringBuf();\n\t\t\t\t}\n\t\t\t\tbuf.addSub(str, start, pos - start - 1);\n\t\t\t\tc = nextChar();\n\t\t\t\t#if target.unicode\n\t\t\t\tif (c != \"u\".code && prev != -1)\n\t\t\t\t\tcancelSurrogate();\n\t\t\t\t#end\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase \"r\".code:\n\t\t\t\t\t\tbuf.addChar(\"\\r\".code);\n\t\t\t\t\tcase \"n\".code:\n\t\t\t\t\t\tbuf.addChar(\"\\n\".code);\n\t\t\t\t\tcase \"t\".code:\n\t\t\t\t\t\tbuf.addChar(\"\\t\".code);\n\t\t\t\t\tcase \"b\".code:\n\t\t\t\t\t\tbuf.addChar(8);\n\t\t\t\t\tcase \"f\".code:\n\t\t\t\t\t\tbuf.addChar(12);\n\t\t\t\t\tcase \"/\".code, '\\\\'.code, '\"'.code:\n\t\t\t\t\t\tbuf.addChar(c);\n\t\t\t\t\tcase 'u'.code:\n\t\t\t\t\t\tvar uc:Int = Std.parseInt(\"0x\" + str.substr(pos, 4));\n\t\t\t\t\t\tpos += 4;\n\t\t\t\t\t\t#if !target.unicode\n\t\t\t\t\t\tif (uc <= 0x7F)\n\t\t\t\t\t\t\tbuf.addChar(uc);\n\t\t\t\t\t\telse if (uc <= 0x7FF) {\n\t\t\t\t\t\t\tbuf.addChar(0xC0 | (uc >> 6));\n\t\t\t\t\t\t\tbuf.addChar(0x80 | (uc & 63));\n\t\t\t\t\t\t} else if (uc <= 0xFFFF) {\n\t\t\t\t\t\t\tbuf.addChar(0xE0 | (uc >> 12));\n\t\t\t\t\t\t\tbuf.addChar(0x80 | ((uc >> 6) & 63));\n\t\t\t\t\t\t\tbuf.addChar(0x80 | (uc & 63));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbuf.addChar(0xF0 | (uc >> 18));\n\t\t\t\t\t\t\tbuf.addChar(0x80 | ((uc >> 12) & 63));\n\t\t\t\t\t\t\tbuf.addChar(0x80 | ((uc >> 6) & 63));\n\t\t\t\t\t\t\tbuf.addChar(0x80 | (uc & 63));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#else\n\t\t\t\t\t\tif (prev != -1) {\n\t\t\t\t\t\t\tif (uc < 0xDC00 || uc > 0xDFFF)\n\t\t\t\t\t\t\t\tcancelSurrogate();\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbuf.addChar(((prev - 0xD800) << 10) + (uc - 0xDC00) + 0x10000);\n\t\t\t\t\t\t\t\tprev = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (uc >= 0xD800 && uc <= 0xDBFF)\n\t\t\t\t\t\t\tprev = uc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbuf.addChar(uc);\n\t\t\t\t\t\t#end\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Invalid escape sequence \\\\\" + String.fromCharCode(c) + \" at position \" + (pos - 1);\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t}\n\t\t\t#if !(target.unicode)\n\t\t\t// ensure utf8 chars are not cut\n\t\t\telse if (c >= 0x80) {\n\t\t\t\tpos++;\n\t\t\t\tif (c >= 0xFC)\n\t\t\t\t\tpos += 4;\n\t\t\t\telse if (c >= 0xF8)\n\t\t\t\t\tpos += 3;\n\t\t\t\telse if (c >= 0xF0)\n\t\t\t\t\tpos += 2;\n\t\t\t\telse if (c >= 0xE0)\n\t\t\t\t\tpos++;\n\t\t\t}\n\t\t\t#end\n\t\telse if (StringTools.isEof(c))\n\t\t\tthrow \"Unclosed string\";\n\t\t}\n\t\t#if target.unicode\n\t\tif (prev != -1)\n\t\t\tcancelSurrogate();\n\t\t#end\n\t\tif (buf == null) {\n\t\t\treturn str.substr(start, pos - start - 1);\n\t\t} else {\n\t\t\tbuf.addSub(str, start, pos - start - 1);\n\t\t\treturn buf.toString();\n\t\t}\n\t}\n\n\tinline function parseNumber(c:Int):Dynamic {\n\t\tvar start = pos - 1;\n\t\tvar minus = c == '-'.code, digit = !minus, zero = c == '0'.code;\n\t\tvar point = false, e = false, pm = false, end = false;\n\t\twhile (true) {\n\t\t\tc = nextChar();\n\t\t\tswitch (c) {\n\t\t\t\tcase '0'.code:\n\t\t\t\t\tif (zero && !point)\n\t\t\t\t\t\tinvalidNumber(start);\n\t\t\t\t\tif (minus) {\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\t\tzero = true;\n\t\t\t\t\t}\n\t\t\t\t\tdigit = true;\n\t\t\t\tcase '1'.code, '2'.code, '3'.code, '4'.code, '5'.code, '6'.code, '7'.code, '8'.code, '9'.code:\n\t\t\t\t\tif (zero && !point)\n\t\t\t\t\t\tinvalidNumber(start);\n\t\t\t\t\tif (minus)\n\t\t\t\t\t\tminus = false;\n\t\t\t\t\tdigit = true;\n\t\t\t\t\tzero = false;\n\t\t\t\tcase '.'.code:\n\t\t\t\t\tif (minus || point || e)\n\t\t\t\t\t\tinvalidNumber(start);\n\t\t\t\t\tdigit = false;\n\t\t\t\t\tpoint = true;\n\t\t\t\tcase 'e'.code, 'E'.code:\n\t\t\t\t\tif (minus || zero || e)\n\t\t\t\t\t\tinvalidNumber(start);\n\t\t\t\t\tdigit = false;\n\t\t\t\t\te = true;\n\t\t\t\tcase '+'.code, '-'.code:\n\t\t\t\t\tif (!e || pm)\n\t\t\t\t\t\tinvalidNumber(start);\n\t\t\t\t\tdigit = false;\n\t\t\t\t\tpm = true;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!digit)\n\t\t\t\t\t\tinvalidNumber(start);\n\t\t\t\t\tpos--;\n\t\t\t\t\tend = true;\n\t\t\t}\n\t\t\tif (end)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar f = Std.parseFloat(str.substr(start, pos - start));\n\t\tvar i = Std.int(f);\n\t\treturn if (i == f) i else f;\n\t}\n\n\tinline function nextChar() {\n\t\treturn StringTools.fastCodeAt(str, pos++);\n\t}\n\n\tfunction invalidChar() {\n\t\tpos--; // rewind\n\t\tthrow \"Invalid char \" + StringTools.fastCodeAt(str, pos) + \" at position \" + pos;\n\t}\n\n\tfunction invalidNumber(start:Int) {\n\t\tthrow \"Invalid number at position \" + start + \": \" + str.substr(start, pos - start);\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi extern class String {\n\tvar length(default, null):Int;\n\n\t@:pure function new(string:String):Void;\n\t@:pure function toUpperCase():String;\n\t@:pure function toLowerCase():String;\n\t@:pure function charAt(index:Int):String;\n\t@:pure function indexOf(str:String, ?startIndex:Int):Int;\n\t@:pure function lastIndexOf(str:String, ?startIndex:Int):Int;\n\t@:pure function split(delimiter:String):Array<String>;\n\t@:pure function toString():String;\n\t@:pure function substring(startIndex:Int, ?endIndex:Int):String;\n\n\t@:pure inline function charCodeAt(index:Int):Null<Int> {\n\t\treturn @:privateAccess HxOverrides.cca(this, index);\n\t}\n\n\t@:pure inline function substr(pos:Int, ?len:Int):String {\n\t\treturn @:privateAccess HxOverrides.substr(this, pos, len);\n\t}\n\n\t@:pure static inline function fromCharCode(code:Int):String {\n\t\treturn untyped __define_feature__('String.fromCharCode', js.Syntax.code(\"String.fromCodePoint({0})\", code));\n\t}\n\n\tstatic function __init__():Void {\n\t\tuntyped __feature__('String.fromCharCode',\n\t\t\tjs.Syntax.code(\"if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }\"));\n\t}\n}\n"]}