{"sourceRoot":"","names":[],"mappings":"QA0BQ;QCrBR;QC0FA;QCrEA;QCDA;;QCMA;QC1BA;ACuBA;;;CAGC,OACC;WAAS;;CAGV,cAAuB,CACtB;UAAQ,oBACR;aAAW,AAAC,KAAK,KAAM,GACvB;YAAU,AAAC,KAAK,IAAK,GACrB;YAAU,IAAI,GACd;UAAQ,oBACR;aAAW,KAAK,EAChB;cAAY,AAAC,KAAK,IAAK,GACvB;YAAU,IAAI,GACd;EAAO,gBAAS,OAAO,MAAM,QAAQ,GAAG,KAAK,MAAM,KAAK,OAAO;;CAGhE,wBAAiC,CAChC;eAAa,WACb;QAAO,UAAS,GAAhB,CACC;MAAI,UAAS,GACZ;UAAM;KACP;aAAU,oBACV;aAAU,oBACV;MAAI,UAAS,KACZ;UAAM;KACP;MAAQ,QACF,OAAL,CACC;kBAAc,kBACd;OAAI,YAAW,GAAG,CACjB;gBAAW,kBACX;kBAAa,SACb;cAAS,YAAO,MAAM,IACtB;gBAAW,oBAAS,KAAK;KACnB,OACN;eAAU,mBACV;gBAAW,YAAO,MAAM,cACxB;gBAAW,+BAAoB,MAAM;;IAGtC;eAAW,oBAAS,KAAK,YAAO;KAElC;aAAU,IAAI;IAEf;EAAO;;CAGR,kBAAwC,CACvC;UAAQ,OACR;UAAQ,cACR;KAAI,MAAK,YAAc,KAAK,WAC3B;GAAO;IACR;KAAI,MAAK,UACR;SAAM;IACP;gBAAc,eACd;cAAY,eACZ;aAAW,SAAQ,SAAS,EAC5B;KAAI,EAAC,QAAQ,UAAW,GACvB;SAAM,qCAAuB;IAC9B;oBAAkB,eAClB;mBAAiB,AAAC,eAAe,EACjC;KAAI,eAAc,eAAe,GAChC;SAAM,2CAA6B;IACpC;cAAY,mBACZ;cAAsB,cACtB;cAAY,cACZ;cAAY,cACZ;iBAAe,cACf;aAAW,cACX;cAAY,aAAa,UACzB;eAAa,qBAAgB,MAC7B;KAAI,OACH;eAAY;IACb;aAAW,KAGX;KAAI,EAAC,QAAQ,MAAM,GAClB;WAAQ;IACT;EAAO,QACI,mBACA,mBACA,mBACE,0BACF,mBACJ,cACC,gBACM;;CAIf,OAAmC,CAClC;UAAQ,WACR;YAAU,KACV;YAAU,KACV;QAAO,OAAM,CACZ;WAAQ,uBACR;MAAI,MAAK,MACR;;KAED;MAAI,YAAW,MAAM,CACpB;OAAI,eAAc,CAiCjB;mBAAc,MACd;QAAI,QAAO,MACV;YAAM,0BAAoB;OAC3B;eAAU,kBACV;aAAQ,gBAAgB,QAAG,OAAO,OAClC;WAAO,OAAM,CACZ;cAAQ,YAAY,KAAK,GAAG,SAC5B;mBAAa,KAAK,GAAG,GACrB;SAAI,KAAI,SACP;;;OAEF;cAAS;KAGT;cAAS,YAAO;MACjB;cAAU,mBACV;OAAI,YAAW,WACd;eAAU;MACX;iBAAa,mBACb;iBAAa,mBAEb;iBAAa,WACb;mBAAe;IAEf;aAAS,YAAO;KACjB;SAAM;IAEP;EAAO;;CAGR,kBAAgD,CAC/C;UAAQ,WAAW,GACnB;EAAO;;CAGR,gBAAsC,CACrC;KAAI,EAAC,cACJ;GAAO;IACR;UAAQ,eAAwB,KAChC;UAAQ,0BAAoB,aAC5B;UAAQ,UAAU,QAAQ,GAAG,GAAG,GAChC;YACA;KAAI,EAAC,UAAU,UAAU,iBAAiB,WAAW,YACpD;SAAM,+CAAiC;IACxC;iBAAe,MACf;eAAa,WACb;WAAS,EACT;EAAO","version":3,"file":"Reader.js.map","sources":["../../../../../../../haxe/versions/4.0.1/std/js/Boot.hx","../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/haxe/zip/Uncompress.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/zip/InflateImpl.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/zip/Entry.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/ds/List.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/zip/Reader.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","package haxe.zip;\r\n\r\nimport js.node.Buffer;\r\nimport js.node.Zlib;\r\n\r\nclass Uncompress {\r\n\tvar windowBits:Null<Int>;\r\n\r\n\tpublic function new(?windowBits:Int) {\r\n\t\tthis.windowBits = windowBits;\r\n\t}\r\n\r\n\tpublic function execute(src:haxe.io.Bytes, srcPos:Int, dst:haxe.io.Bytes, dstPos:Int):{done:Bool, read:Int, write:Int} {\r\n\t\tvar src = js.node.Buffer.hxFromBytes(src).slice(srcPos);\r\n\t\tvar dst = js.node.Buffer.hxFromBytes(dst);\r\n\t\tvar res = cast Zlib.inflateRawSync(src, cast {info: true, /* windowBits: windowBits */});\r\n\t\tvar engine = res.engine;\r\n\t\tvar res:Buffer = res.buffer;\r\n\t\tdst.set(res, dstPos);\r\n\t\treturn {done: true, read: engine.bytesRead, write: res.byteLength};\r\n\t}\r\n\r\n\tpublic function setFlushMode(f:FlushMode) {}\r\n\r\n\tpublic function close() {}\r\n\r\n\tpublic static function run(src:haxe.io.Bytes, ?bufsize:Int):haxe.io.Bytes {\r\n\t\tvar buffer = js.node.Zlib.inflateSync(js.node.Buffer.hxFromBytes(src), bufsize == null ? {} : {chunkSize: bufsize});\r\n\t\treturn buffer.hxToBytes();\r\n\t}\r\n}\r\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nimport haxe.zip.Huffman;\nimport haxe.crypto.Adler32;\n\nprivate class Window {\n\tpublic static inline var SIZE = 1 << 15;\n\tpublic static inline var BUFSIZE = 1 << 16;\n\n\tpublic var buffer:haxe.io.Bytes;\n\tpublic var pos:Int;\n\n\tvar crc:Adler32;\n\n\tpublic function new(hasCrc) {\n\t\tbuffer = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos = 0;\n\t\tif (hasCrc)\n\t\t\tcrc = new Adler32();\n\t}\n\n\tpublic function slide() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, SIZE);\n\t\tvar b = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos -= SIZE;\n\t\tb.blit(0, buffer, SIZE, pos);\n\t\tbuffer = b;\n\t}\n\n\tpublic function addBytes(b, p, len) {\n\t\tif (pos + len > BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.blit(pos, b, p, len);\n\t\tpos += len;\n\t}\n\n\tpublic function addByte(c) {\n\t\tif (pos == BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.set(pos, c);\n\t\tpos++;\n\t}\n\n\tpublic function getLastChar() {\n\t\treturn buffer.get(pos - 1);\n\t}\n\n\tpublic function available() {\n\t\treturn pos;\n\t}\n\n\tpublic function checksum() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, pos);\n\t\treturn crc;\n\t}\n}\n\nprivate enum State {\n\tHead;\n\tBlock;\n\tCData;\n\tFlat;\n\tCrc;\n\tDist;\n\tDistOne;\n\tDone;\n}\n\n/**\n\tA pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.\n**/\nclass InflateImpl {\n\tstatic var LEN_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1\n\t];\n\tstatic var LEN_BASE_VAL_TBL = [\n\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n\t];\n\tstatic var DIST_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1\n\t];\n\tstatic var DIST_BASE_VAL_TBL = [\n\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577\n\t];\n\tstatic var CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\tvar nbits:Int;\n\tvar bits:Int;\n\tvar state:State;\n\tvar isFinal:Bool;\n\tvar huffman:Huffman;\n\tvar huffdist:Null<Huffman>;\n\tvar htools:HuffTools;\n\tvar len:Int;\n\tvar dist:Int;\n\tvar needed:Int;\n\tvar output:haxe.io.Bytes;\n\tvar outpos:Int;\n\tvar input:haxe.io.Input;\n\tvar lengths:Array<Int>;\n\tvar window:Window;\n\n\tstatic var FIXED_HUFFMAN = null;\n\n\tpublic function new(i, ?header = true, ?crc = true) {\n\t\tisFinal = false;\n\t\thtools = new HuffTools();\n\t\thuffman = buildFixedHuffman();\n\t\thuffdist = null;\n\t\tlen = 0;\n\t\tdist = 0;\n\t\tstate = header ? Head : Block;\n\t\tinput = i;\n\t\tbits = 0;\n\t\tnbits = 0;\n\t\tneeded = 0;\n\t\toutput = null;\n\t\toutpos = 0;\n\t\tlengths = new Array();\n\t\tfor (i in 0...19)\n\t\t\tlengths.push(-1);\n\t\twindow = new Window(crc);\n\t}\n\n\tfunction buildFixedHuffman() {\n\t\tif (FIXED_HUFFMAN != null)\n\t\t\treturn FIXED_HUFFMAN;\n\t\tvar a = new Array();\n\t\tfor (n in 0...288)\n\t\t\ta.push(if (n <= 143) 8 else if (n <= 255) 9 else if (n <= 279) 7 else 8);\n\t\tFIXED_HUFFMAN = htools.make(a, 0, 288, 10);\n\t\treturn FIXED_HUFFMAN;\n\t}\n\n\tpublic function readBytes(b, pos, len) {\n\t\tneeded = len;\n\t\toutpos = pos;\n\t\toutput = b;\n\t\tif (len > 0)\n\t\t\twhile (inflateLoop()) {}\n\t\treturn len - needed;\n\t}\n\n\tfunction getBits(n) {\n\t\twhile (nbits < n) {\n\t\t\tbits |= input.readByte() << nbits;\n\t\t\tnbits += 8;\n\t\t}\n\t\tvar b = bits & ((1 << n) - 1);\n\t\tnbits -= n;\n\t\tbits >>= n;\n\t\treturn b;\n\t}\n\n\tfunction getBit() {\n\t\tif (nbits == 0) {\n\t\t\tnbits = 8;\n\t\t\tbits = input.readByte();\n\t\t}\n\t\tvar b = bits & 1 == 1;\n\t\tnbits--;\n\t\tbits >>= 1;\n\t\treturn b;\n\t}\n\n\tfunction getRevBits(n) {\n\t\treturn if (n == 0)\n\t\t\t0\n\t\telse if (getBit())\n\t\t\t(1 << (n - 1)) | getRevBits(n - 1)\n\t\telse\n\t\t\tgetRevBits(n - 1);\n\t}\n\n\tfunction resetBits() {\n\t\tbits = 0;\n\t\tnbits = 0;\n\t}\n\n\tfunction addBytes(b, p, len) {\n\t\twindow.addBytes(b, p, len);\n\t\toutput.blit(outpos, b, p, len);\n\t\tneeded -= len;\n\t\toutpos += len;\n\t}\n\n\tfunction addByte(b) {\n\t\twindow.addByte(b);\n\t\toutput.set(outpos, b);\n\t\tneeded--;\n\t\toutpos++;\n\t}\n\n\tfunction addDistOne(n) {\n\t\tvar c = window.getLastChar();\n\t\tfor (i in 0...n)\n\t\t\taddByte(c);\n\t}\n\n\tfunction addDist(d, len) {\n\t\taddBytes(window.buffer, window.pos - d, len);\n\t}\n\n\tfunction applyHuffman(h) {\n\t\treturn switch (h) {\n\t\t\tcase Found(n): n;\n\t\t\tcase NeedBit(a, b): applyHuffman(getBit() ? b : a);\n\t\t\tcase NeedBits(n, tbl): applyHuffman(tbl[getBits(n)]);\n\t\t}\n\t}\n\n\tfunction inflateLengths(a, max) {\n\t\tvar i = 0;\n\t\tvar prev = 0;\n\t\twhile (i < max) {\n\t\t\tvar n = applyHuffman(huffman);\n\t\t\tswitch (n) {\n\t\t\t\tcase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15:\n\t\t\t\t\tprev = n;\n\t\t\t\t\ta[i] = n;\n\t\t\t\t\ti++;\n\t\t\t\tcase 16:\n\t\t\t\t\tvar end = i + 3 + getBits(2);\n\t\t\t\t\tif (end > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\twhile (i < end) {\n\t\t\t\t\t\ta[i] = prev;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\tcase 17:\n\t\t\t\t\ti += 3 + getBits(3);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tcase 18:\n\t\t\t\t\ti += 11 + getBits(7);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction inflateLoop() {\n\t\tswitch (state) {\n\t\t\tcase Head:\n\t\t\t\tvar cmf = input.readByte();\n\t\t\t\tvar cm = cmf & 15;\n\t\t\t\tvar cinfo = cmf >> 4;\n\t\t\t\tif (cm != 8)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tvar flg = input.readByte();\n\t\t\t\t// var fcheck = flg & 31;\n\t\t\t\tvar fdict = flg & 32 != 0;\n\t\t\t\t// var flevel = flg >> 6;\n\t\t\t\tif (((cmf << 8) + flg) % 31 != 0)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tif (fdict)\n\t\t\t\t\tthrow \"Unsupported dictionary\";\n\t\t\t\tstate = Block;\n\t\t\t\treturn true;\n\t\t\tcase Crc:\n\t\t\t\tvar calc = window.checksum();\n\t\t\t\tif (calc == null) {\n\t\t\t\t\tstate = Done;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar crc = Adler32.read(input);\n\t\t\t\tif (!calc.equals(crc))\n\t\t\t\t\tthrow \"Invalid CRC\";\n\t\t\t\tstate = Done;\n\t\t\t\treturn true;\n\t\t\tcase Done:\n\t\t\t\t// nothing\n\t\t\t\treturn false;\n\t\t\tcase Block:\n\t\t\t\tisFinal = getBit();\n\t\t\t\tswitch (getBits(2)) {\n\t\t\t\t\tcase 0: // no compression\n\t\t\t\t\t\tlen = input.readUInt16();\n\t\t\t\t\t\tvar nlen = input.readUInt16();\n\t\t\t\t\t\tif (nlen != 0xFFFF - len) throw \"Invalid data\";\n\t\t\t\t\t\tstate = Flat;\n\t\t\t\t\t\tvar r = inflateLoop();\n\t\t\t\t\t\tresetBits();\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tcase 1: // fixed Huffman\n\t\t\t\t\t\thuffman = buildFixedHuffman();\n\t\t\t\t\t\thuffdist = null;\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 2: // dynamic Huffman\n\t\t\t\t\t\tvar hlit = getBits(5) + 257;\n\t\t\t\t\t\tvar hdist = getBits(5) + 1;\n\t\t\t\t\t\tvar hclen = getBits(4) + 4;\n\t\t\t\t\t\tfor (i in 0...hclen)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = getBits(3);\n\t\t\t\t\t\tfor (i in hclen...19)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = 0;\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, 19, 8);\n\t\t\t\t\t\tvar lengths = new Array();\n\t\t\t\t\t\tfor (i in 0...hlit + hdist)\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\tinflateLengths(lengths, hlit + hdist);\n\t\t\t\t\t\thuffdist = htools.make(lengths, hlit, hdist, 16);\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, hlit, 16);\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t}\n\t\t\tcase Flat:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\tvar bytes = input.read(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\taddBytes(bytes, 0, rlen);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\treturn needed > 0;\n\t\t\tcase DistOne:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\taddDistOne(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase Dist:\n\t\t\t\twhile (len > 0 && needed > 0) {\n\t\t\t\t\tvar rdist = (len < dist) ? len : dist;\n\t\t\t\t\tvar rlen = (needed < rdist) ? needed : rdist;\n\t\t\t\t\taddDist(dist, rlen);\n\t\t\t\t\tlen -= rlen;\n\t\t\t\t}\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase CData:\n\t\t\t\tvar n = applyHuffman(huffman);\n\t\t\t\tif (n < 256) {\n\t\t\t\t\taddByte(n);\n\t\t\t\t\treturn needed > 0;\n\t\t\t\t} else if (n == 256) {\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tn -= 257;\n\t\t\t\t\tvar extra_bits = LEN_EXTRA_BITS_TBL[n];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tlen = LEN_BASE_VAL_TBL[n] + getBits(extra_bits);\n\t\t\t\t\tvar dist_code = if (huffdist == null) getRevBits(5) else applyHuffman(huffdist);\n\t\t\t\t\textra_bits = DIST_EXTRA_BITS_TBL[dist_code];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tdist = DIST_BASE_VAL_TBL[dist_code] + getBits(extra_bits);\n\t\t\t\t\tif (dist > window.available())\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tstate = (dist == 1) ? DistOne : Dist;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function run(i:haxe.io.Input, ?bufsize = 65536) {\n\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\n\t\tvar output = new haxe.io.BytesBuffer();\n\t\tvar inflate = new InflateImpl(i);\n\t\twhile (true) {\n\t\t\tvar len = inflate.readBytes(buf, 0, bufsize);\n\t\t\toutput.addBytes(buf, 0, len);\n\t\t\tif (len < bufsize)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn output.getBytes();\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nimport haxe.ds.List;\n\nenum ExtraField {\n\tFUnknown(tag:Int, bytes:haxe.io.Bytes);\n\tFInfoZipUnicodePath(name:String, crc:Int);\n\tFUtf8;\n}\n\ntypedef Entry = {\n\tvar fileName:String;\n\tvar fileSize:Int;\n\tvar fileTime:Date;\n\tvar compressed:Bool;\n\tvar dataSize:Int;\n\tvar data:Null<haxe.io.Bytes>;\n\tvar crc32:Null<Int>;\n\tvar ?extraFields:Null<List<ExtraField>>;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n/**\n\tA linked-list of elements. The list is composed of element container objects\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole list content every time.\n\n\t@see https://haxe.org/manual/std-List.html\n**/\nclass List<T> {\n\tprivate var h:ListNode<T>;\n\tprivate var q:ListNode<T>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default, null):Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add(item:T) {\n\t\tvar x = ListNode.create(item, null);\n\t\tif (h == null)\n\t\t\th = x;\n\t\telse\n\t\t\tq.next = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push(item:T) {\n\t\tvar x = ListNode.create(item, h);\n\t\th = x;\n\t\tif (q == null)\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first():Null<T> {\n\t\treturn if (h == null) null else h.item;\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last():Null<T> {\n\t\treturn if (q == null) null else q.item;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop():Null<T> {\n\t\tif (h == null)\n\t\t\treturn null;\n\t\tvar x = h.item;\n\t\th = h.next;\n\t\tif (h == null)\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty():Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear():Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurrence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove(v:T):Bool {\n\t\tvar prev:ListNode<T> = null;\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tif (l.item == v) {\n\t\t\t\tif (prev == null)\n\t\t\t\t\th = l.next;\n\t\t\t\telse\n\t\t\t\t\tprev.next = l.next;\n\t\t\t\tif (q == l)\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l.next;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator():ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns an iterator of the List indices and values.\n\t**/\n\t@:pure @:runtime public inline function keyValueIterator():ListKeyValueIterator<T> {\n\t\treturn new ListKeyValueIterator(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile (l != null) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l.item));\n\t\t\tl = l.next;\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep:String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l.item);\n\t\t\tl = l.next;\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter(f:T->Bool) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tvar v = l.item;\n\t\t\tl = l.next;\n\t\t\tif (f(v))\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f:T->X):List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile (l != null) {\n\t\t\tvar v = l.item;\n\t\t\tl = l.next;\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n}\n\n#if neko\nprivate extern class ListNode<T> extends neko.NativeArray<Dynamic> {\n\tvar item(get, set):T;\n\tvar next(get, set):ListNode<T>;\n\tprivate inline function get_item():T\n\t\treturn this[0];\n\tprivate inline function set_item(v:T):T\n\t\treturn this[0] = v;\n\tprivate inline function get_next():ListNode<T>\n\t\treturn this[1];\n\tprivate inline function set_next(v:ListNode<T>):ListNode<T>\n\t\treturn this[1] = v;\n\tinline static function create<T>(item:T, next:ListNode<T>):ListNode<T> {\n\t\treturn untyped __dollar__array(item, next);\n\t}\n}\n#else\nprivate class ListNode<T> {\n\tpublic var item:T;\n\tpublic var next:ListNode<T>;\n\n\tpublic function new(item:T, next:ListNode<T>) {\n\t\tthis.item = item;\n\t\tthis.next = next;\n\t}\n\n\textern public inline static function create<T>(item:T, next:ListNode<T>):ListNode<T> {\n\t\treturn new ListNode(item, next);\n\t}\n}\n#end\n\nprivate class ListIterator<T> {\n\tvar head:ListNode<T>;\n\n\tpublic inline function new(head:ListNode<T>) {\n\t\tthis.head = head;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tvar val = head.item;\n\t\thead = head.next;\n\t\treturn val;\n\t}\n}\n\nprivate class ListKeyValueIterator<T> {\n\tvar idx:Int;\n\tvar head:ListNode<T>;\n\n\tpublic inline function new(head:ListNode<T>) {\n\t\tthis.head = head;\n\t\tthis.idx = 0;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():{key:Int, value:T} {\n\t\tvar val = head.item;\n\t\thead = head.next;\n\t\treturn {value: val, key: idx++};\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nimport haxe.zip.Entry;\nimport haxe.ds.List;\n\n// see http://www.pkware.com/documents/casestudies/APPNOTE.TXT\nclass Reader {\n\tvar i:haxe.io.Input;\n\n\tpublic function new(i) {\n\t\tthis.i = i;\n\t}\n\n\tfunction readZipDate() {\n\t\tvar t = i.readUInt16();\n\t\tvar hour = (t >> 11) & 31;\n\t\tvar min = (t >> 5) & 63;\n\t\tvar sec = t & 31;\n\t\tvar d = i.readUInt16();\n\t\tvar year = d >> 9;\n\t\tvar month = (d >> 5) & 15;\n\t\tvar day = d & 31;\n\t\treturn new Date(year + 1980, month - 1, day, hour, min, sec << 1);\n\t}\n\n\tfunction readExtraFields(length) {\n\t\tvar fields = new List();\n\t\twhile (length > 0) {\n\t\t\tif (length < 4)\n\t\t\t\tthrow \"Invalid extra fields data\";\n\t\t\tvar tag = i.readUInt16();\n\t\t\tvar len = i.readUInt16();\n\t\t\tif (length < len)\n\t\t\t\tthrow \"Invalid extra fields data\";\n\t\t\tswitch (tag) {\n\t\t\t\tcase 0x7075:\n\t\t\t\t\tvar version = i.readByte();\n\t\t\t\t\tif (version != 1) {\n\t\t\t\t\t\tvar data = new haxe.io.BytesBuffer();\n\t\t\t\t\t\tdata.addByte(version);\n\t\t\t\t\t\tdata.add(i.read(len - 1));\n\t\t\t\t\t\tfields.add(FUnknown(tag, data.getBytes()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar crc = i.readInt32();\n\t\t\t\t\t\tvar name = i.read(len - 5).toString();\n\t\t\t\t\t\tfields.add(FInfoZipUnicodePath(name, crc));\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tfields.add(FUnknown(tag, i.read(len)));\n\t\t\t}\n\t\t\tlength -= 4 + len;\n\t\t}\n\t\treturn fields;\n\t}\n\n\tpublic function readEntryHeader():Entry {\n\t\tvar i = this.i;\n\t\tvar h = i.readInt32();\n\t\tif (h == 0x02014B50 || h == 0x06054B50)\n\t\t\treturn null;\n\t\tif (h != 0x04034B50)\n\t\t\tthrow \"Invalid Zip Data\";\n\t\tvar version = i.readUInt16();\n\t\tvar flags = i.readUInt16();\n\t\tvar utf8 = flags & 0x800 != 0;\n\t\tif ((flags & 0xF7F1) != 0)\n\t\t\tthrow \"Unsupported flags \" + flags;\n\t\tvar compression = i.readUInt16();\n\t\tvar compressed = (compression != 0);\n\t\tif (compressed && compression != 8)\n\t\t\tthrow \"Unsupported compression \" + compression;\n\t\tvar mtime = readZipDate();\n\t\tvar crc32:Null<Int> = i.readInt32();\n\t\tvar csize = i.readInt32();\n\t\tvar usize = i.readInt32();\n\t\tvar fnamelen = i.readInt16();\n\t\tvar elen = i.readInt16();\n\t\tvar fname = i.readString(fnamelen);\n\t\tvar fields = readExtraFields(elen);\n\t\tif (utf8)\n\t\t\tfields.push(FUtf8);\n\t\tvar data = null;\n\t\t// we have a data descriptor that store the real crc/sizes\n\t\t// after the compressed data, let's wait for it\n\t\tif ((flags & 8) != 0)\n\t\t\tcrc32 = null;\n\t\treturn {\n\t\t\tfileName: fname,\n\t\t\tfileSize: usize,\n\t\t\tfileTime: mtime,\n\t\t\tcompressed: compressed,\n\t\t\tdataSize: csize,\n\t\t\tdata: data,\n\t\t\tcrc32: crc32,\n\t\t\textraFields: fields,\n\t\t};\n\t}\n\n\tpublic function read():List<Entry> {\n\t\tvar l = new List();\n\t\tvar buf = null;\n\t\tvar tmp = null;\n\t\twhile (true) {\n\t\t\tvar e = readEntryHeader();\n\t\t\tif (e == null)\n\t\t\t\tbreak;\n\t\t\t// do we have a data descriptor? (see readEntryHeader)\n\t\t\tif (e.crc32 == null) {\n\t\t\t\tif (e.compressed) {\n\t\t\t\t\t#if neko\n\t\t\t\t\t// enter progressive mode : we use a different input which has\n\t\t\t\t\t// a temporary buffer, this is necessary since we have to uncompress\n\t\t\t\t\t// progressively, and after that we might have pending read data\n\t\t\t\t\t// that needs to be processed\n\t\t\t\t\tvar bufSize = 65536;\n\t\t\t\t\tif (buf == null) {\n\t\t\t\t\t\tbuf = new haxe.io.BufferInput(i, haxe.io.Bytes.alloc(bufSize));\n\t\t\t\t\t\ttmp = haxe.io.Bytes.alloc(bufSize);\n\t\t\t\t\t\ti = buf;\n\t\t\t\t\t}\n\t\t\t\t\tvar out = new haxe.io.BytesBuffer();\n\t\t\t\t\tvar z = new neko.zip.Uncompress(-15);\n\t\t\t\t\tz.setFlushMode(neko.zip.Flush.SYNC);\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (buf.available == 0)\n\t\t\t\t\t\t\tbuf.refill();\n\t\t\t\t\t\tvar p = bufSize - buf.available;\n\t\t\t\t\t\tif (p != buf.pos) {\n\t\t\t\t\t\t\t// because of lack of \"srcLen\" in zip api, we need to always be stuck to the buffer end\n\t\t\t\t\t\t\tbuf.buf.blit(p, buf.buf, buf.pos, buf.available);\n\t\t\t\t\t\t\tbuf.pos = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar r = z.execute(buf.buf, buf.pos, tmp, 0);\n\t\t\t\t\t\tout.addBytes(tmp, 0, r.write);\n\t\t\t\t\t\tbuf.pos += r.read;\n\t\t\t\t\t\tbuf.available -= r.read;\n\t\t\t\t\t\tif (r.done)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\te.data = out.getBytes();\n\t\t\t\t\t#else\n\t\t\t\t\tvar bufSize = 65536;\n\t\t\t\t\tif (tmp == null)\n\t\t\t\t\t\ttmp = haxe.io.Bytes.alloc(bufSize);\n\t\t\t\t\tvar out = new haxe.io.BytesBuffer();\n\t\t\t\t\tvar z = new InflateImpl(i, false, false);\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tvar n = z.readBytes(tmp, 0, bufSize);\n\t\t\t\t\t\tout.addBytes(tmp, 0, n);\n\t\t\t\t\t\tif (n < bufSize)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\te.data = out.getBytes();\n\t\t\t\t\t#end\n\t\t\t\t} else\n\t\t\t\t\te.data = i.read(e.dataSize);\n\t\t\t\te.crc32 = i.readInt32();\n\t\t\t\tif (e.crc32 == 0x08074b50)\n\t\t\t\t\te.crc32 = i.readInt32();\n\t\t\t\te.dataSize = i.readInt32();\n\t\t\t\te.fileSize = i.readInt32();\n\t\t\t\t// set data to uncompressed\n\t\t\t\te.dataSize = e.fileSize;\n\t\t\t\te.compressed = false;\n\t\t\t} else\n\t\t\t\te.data = i.read(e.dataSize);\n\t\t\tl.add(e);\n\t\t}\n\t\treturn l;\n\t}\n\n\tpublic static function readZip(i:haxe.io.Input) {\n\t\tvar r = new Reader(i);\n\t\treturn r.read();\n\t}\n\n\tpublic static function unzip(f:Entry) {\n\t\tif (!f.compressed)\n\t\t\treturn f.data;\n\t\tvar c = new haxe.zip.Uncompress(-15);\n\t\tvar s = haxe.io.Bytes.alloc(f.fileSize);\n\t\tvar r = c.execute(f.data, 0, s, 0);\n\t\tc.close();\n\t\tif (!r.done || r.read != f.data.length || r.write != f.fileSize)\n\t\t\tthrow \"Invalid compressed data for \" + f.fileName;\n\t\tf.compressed = false;\n\t\tf.dataSize = f.fileSize;\n\t\tf.data = s;\n\t\treturn f.data;\n\t}\n}\n"]}