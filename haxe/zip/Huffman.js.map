{"sourceRoot":"","names":[],"mappings":"QA0BQ;QCRR;QCbA;;ACmBA;;;;;CACC;CACA;CACA;;;;;AAGD;AAAA;CACC,MAAsB;;CAEtB,aACQ;EAAA,OAAQ;GACd,AAAK,OAAL,AAAW;IAAA,aAAI;IAAA;;GAEf,AAAK,OAAL,AAAgB;IAAA,gBAAH;IAAA,eACZ;IAAA,SAAS,eAAU,GACnB;IAAA,SAAS,eAAU,GACnB;IAAA,WAAI,CAAC,CAAC,KAAK,MAAM,KAAK;;GAJvB,AAAK,OAAL,AAAiB;IAAA,kBAAH;IAAA,cAAO;IAAA,MAAM;;;;;CAQ7B,gBAAyB,CACxB;EAAA,QAAQ,eAAU,GAClB;EAAA,GAAI,MAAK,GACR;GAAA,AAAO;IACR;EAAA,GAAI,MAAK,GACD;GAAA,GAAQ,gBACT,GAAL,CAAgB;IAAA,gBAAH;IAAA,eAAO;IAAA,uBAAQ,kBAAa,IAAI,kBAAa;IACjD;IAAA,MAAM;;IAEjB;EAAA,WAAW,KAAK,EAChB;EAAA,YAAY,YACZ;EAAA,SAAU,EAAV;EAAA,UAAc,KAAd;EAAA,YAAc,KAAd;GAAA,aACC;GAAA,WAAW,cAAM;IAClB;EAAA,cAAS,OAAO,GAAG,GAAG,GAAG,GACzB;EAAA,AAAO,wBAAS,GAAG;;CAGpB,6BACC;EAAA,GAAQ,gBACF,GAAL,CAAgB;GAAA,gBAAH;GAAA,eACZ;GAAA,GAAI,KAAI,GAAG,CACV;IAAA,cAAS,OAAO,GAAG,KAAK,GAAG,IAAI,GAAG,GAClC;IAAA,cAAS,OAAO,IAAI,AAAC,KAAK,IAAK,KAAK,GAAG,IAAI,GAAG;IAE9C;IAAA,MAAM,KAAK,kBAAa;;GAEzB;GAAA,MAAM,KAAK,kBAAa;;;CAI3B,gCAAyE,CACxE;EAAA,GAAI,OAAM,SACT;GAAA,MAAM;IACP;EAAA,UAAU,AAAC,KAAK,IAAK,IACrB;EAAA,GAAI,eAAY,MACf;GAAA,AAAO,qBAAM,cAAS;IACvB;EAAA,MAAM,EACN;EAAA,MACA;EAAA,AAAO,uBAAQ,cAAS,MAAM,SAAS,GAAG,MAAM,cAAS,MAAM,SAAS,IAAI,GAAG;;CAGhF,sCAAsD,CACrD;EAAA,aAAa,YACb;EAAA,UAAU,YACV;EAAA,GAAI,WAAU,IACb;GAAA,MAAM;IACP;EAAA,SAAU,EAAV;EAAA,UAAc,QAAd;EAAA,YAAc,KAAd;GAAA,aACC;GAAA,YAAY,GACZ;GAAA,SAAS;IAEV;EAAA,UAAU,EAAV;EAAA,UAAc,SAAd;EAAA,aAAc,KAAd;GAAA,eACC;GAAA,QAAQ,QAAQ,KAAI,KACpB;GAAA,GAAI,MAAK,SACR;IAAA,MAAM;KACP;GAAA,OAAO;IAER;EAAA,WAAW,EACX;EAAA,UAAU,EAAV;EAAA,UAAc,UAAU,EAAxB;EAAA,aAAc,KAAd;GAAA,eACC;GAAA,OAAO,AAAC,OAAO,OAAO,OAAO,EAC7B;GAAA,IAAI,MAAK;IAEV;EAAA,WAAW,aACX;EAAA,UAAU,EAAV;EAAA,UAAc,SAAd;EAAA,aAAc,KAAd;GAAA,eACC;GAAA,QAAQ,QAAQ,KAAI,KACpB;GAAA,GAAI,MAAK,GAAG,CACX;IAAA,QAAQ,IAAI,IAAI,GAChB;IAAA,IAAI,IAAI,KAAK,IAAI,EACjB;IAAA,cAAS,AAAC,KAAK,IAAK,GAAG;;IAGzB;EAAA,AAAO,yBAAa,gBAAQ,cAAS,MAAM,SAAS,GAAG,IAAI,cAAS,MAAM,SAAS,GAAG","version":3,"file":"Huffman.js.map","sources":["../../../../../../../haxe/versions/4.0.2/std/js/Boot.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/haxe/ds/IntMap.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.2/std/haxe/zip/Huffman.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","package haxe.ds;\n\n#if !js\nextern class IntMap<T> implements haxe.Constraints.IMap<Int, T> {\n  public function new(): Void;\n  public function set(key: Int, value: T): Void;\n  public function get(key: Int): Null<T>;\n  public function exists(key: Int): Bool;\n  public function remove(key: Int): Bool;\n  public function keys(): Iterator<Int>;\n  public function iterator(): Iterator<T>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<Int, T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): IntMap<T>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass IntMap<T> extends genes.util.EsMap<Int, T> implements haxe.Constraints.IMap<Int, T> {\n  public inline function copy(): IntMap<T> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<Int, T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nenum Huffman {\n\tFound(i:Int);\n\tNeedBit(left:Huffman, right:Huffman);\n\tNeedBits(n:Int, table:Array<Huffman>);\n}\n\nclass HuffTools {\n\tpublic function new() {}\n\n\tfunction treeDepth(t) {\n\t\treturn switch (t) {\n\t\t\tcase Found(_): 0;\n\t\t\tcase NeedBits(_, _): throw \"assert\";\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tvar da = treeDepth(a);\n\t\t\t\tvar db = treeDepth(b);\n\t\t\t\t1 + ((da < db) ? da : db);\n\t\t}\n\t}\n\n\tfunction treeCompress(t) {\n\t\tvar d = treeDepth(t);\n\t\tif (d == 0)\n\t\t\treturn t;\n\t\tif (d == 1)\n\t\t\treturn switch (t) {\n\t\t\t\tcase NeedBit(a, b): NeedBit(treeCompress(a), treeCompress(b));\n\t\t\t\tdefault: throw \"assert\";\n\t\t\t}\n\t\tvar size = 1 << d;\n\t\tvar table = new Array();\n\t\tfor (i in 0...size)\n\t\t\ttable.push(Found(-1));\n\t\ttreeWalk(table, 0, 0, d, t);\n\t\treturn NeedBits(d, table);\n\t}\n\n\tfunction treeWalk(table, p, cd, d, t) {\n\t\tswitch (t) {\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tif (d > 0) {\n\t\t\t\t\ttreeWalk(table, p, cd + 1, d - 1, a);\n\t\t\t\t\ttreeWalk(table, p | (1 << cd), cd + 1, d - 1, b);\n\t\t\t\t} else\n\t\t\t\t\ttable[p] = treeCompress(t);\n\t\t\tdefault:\n\t\t\t\ttable[p] = treeCompress(t);\n\t\t}\n\t}\n\n\tfunction treeMake(bits:haxe.ds.IntMap<Int>, maxbits:Int, v:Int, len:Int) {\n\t\tif (len > maxbits)\n\t\t\tthrow \"Invalid huffman\";\n\t\tvar idx = (v << 5) | len;\n\t\tif (bits.exists(idx))\n\t\t\treturn Found(bits.get(idx));\n\t\tv <<= 1;\n\t\tlen += 1;\n\t\treturn NeedBit(treeMake(bits, maxbits, v, len), treeMake(bits, maxbits, v | 1, len));\n\t}\n\n\tpublic function make(lengths, pos, nlengths, maxbits) {\n\t\tvar counts = new Array();\n\t\tvar tmp = new Array();\n\t\tif (maxbits > 32)\n\t\t\tthrow \"Invalid huffman\";\n\t\tfor (i in 0...maxbits) {\n\t\t\tcounts.push(0);\n\t\t\ttmp.push(0);\n\t\t}\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar p = lengths[i + pos];\n\t\t\tif (p >= maxbits)\n\t\t\t\tthrow \"Invalid huffman\";\n\t\t\tcounts[p]++;\n\t\t}\n\t\tvar code = 0;\n\t\tfor (i in 1...maxbits - 1) {\n\t\t\tcode = (code + counts[i]) << 1;\n\t\t\ttmp[i] = code;\n\t\t}\n\t\tvar bits = new haxe.ds.IntMap();\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar l = lengths[i + pos];\n\t\t\tif (l != 0) {\n\t\t\t\tvar n = tmp[l - 1];\n\t\t\t\ttmp[l - 1] = n + 1;\n\t\t\t\tbits.set((n << 5) | l, i);\n\t\t\t}\n\t\t}\n\t\treturn treeCompress(NeedBit(treeMake(bits, maxbits, 0, 1), treeMake(bits, maxbits, 1, 1)));\n\t}\n}\n"]}