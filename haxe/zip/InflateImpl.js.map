{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"InflateImpl.js.map","sources":["../../../../../../../haxe/versions/4.0.1/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/zip/Huffman.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.0.1/std/js/_std/haxe/io/Bytes.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/crypto/Adler32.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.1/std/haxe/zip/InflateImpl.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nenum Huffman {\n\tFound(i:Int);\n\tNeedBit(left:Huffman, right:Huffman);\n\tNeedBits(n:Int, table:Array<Huffman>);\n}\n\nclass HuffTools {\n\tpublic function new() {}\n\n\tfunction treeDepth(t) {\n\t\treturn switch (t) {\n\t\t\tcase Found(_): 0;\n\t\t\tcase NeedBits(_, _): throw \"assert\";\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tvar da = treeDepth(a);\n\t\t\t\tvar db = treeDepth(b);\n\t\t\t\t1 + ((da < db) ? da : db);\n\t\t}\n\t}\n\n\tfunction treeCompress(t) {\n\t\tvar d = treeDepth(t);\n\t\tif (d == 0)\n\t\t\treturn t;\n\t\tif (d == 1)\n\t\t\treturn switch (t) {\n\t\t\t\tcase NeedBit(a, b): NeedBit(treeCompress(a), treeCompress(b));\n\t\t\t\tdefault: throw \"assert\";\n\t\t\t}\n\t\tvar size = 1 << d;\n\t\tvar table = new Array();\n\t\tfor (i in 0...size)\n\t\t\ttable.push(Found(-1));\n\t\ttreeWalk(table, 0, 0, d, t);\n\t\treturn NeedBits(d, table);\n\t}\n\n\tfunction treeWalk(table, p, cd, d, t) {\n\t\tswitch (t) {\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tif (d > 0) {\n\t\t\t\t\ttreeWalk(table, p, cd + 1, d - 1, a);\n\t\t\t\t\ttreeWalk(table, p | (1 << cd), cd + 1, d - 1, b);\n\t\t\t\t} else\n\t\t\t\t\ttable[p] = treeCompress(t);\n\t\t\tdefault:\n\t\t\t\ttable[p] = treeCompress(t);\n\t\t}\n\t}\n\n\tfunction treeMake(bits:haxe.ds.IntMap<Int>, maxbits:Int, v:Int, len:Int) {\n\t\tif (len > maxbits)\n\t\t\tthrow \"Invalid huffman\";\n\t\tvar idx = (v << 5) | len;\n\t\tif (bits.exists(idx))\n\t\t\treturn Found(bits.get(idx));\n\t\tv <<= 1;\n\t\tlen += 1;\n\t\treturn NeedBit(treeMake(bits, maxbits, v, len), treeMake(bits, maxbits, v | 1, len));\n\t}\n\n\tpublic function make(lengths, pos, nlengths, maxbits) {\n\t\tvar counts = new Array();\n\t\tvar tmp = new Array();\n\t\tif (maxbits > 32)\n\t\t\tthrow \"Invalid huffman\";\n\t\tfor (i in 0...maxbits) {\n\t\t\tcounts.push(0);\n\t\t\ttmp.push(0);\n\t\t}\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar p = lengths[i + pos];\n\t\t\tif (p >= maxbits)\n\t\t\t\tthrow \"Invalid huffman\";\n\t\t\tcounts[p]++;\n\t\t}\n\t\tvar code = 0;\n\t\tfor (i in 1...maxbits - 1) {\n\t\t\tcode = (code + counts[i]) << 1;\n\t\t\ttmp[i] = code;\n\t\t}\n\t\tvar bits = new haxe.ds.IntMap();\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar l = lengths[i + pos];\n\t\t\tif (l != 0) {\n\t\t\t\tvar n = tmp[l - 1];\n\t\t\t\ttmp[l - 1] = n + 1;\n\t\t\t\tbits.set((n << 5) | l, i);\n\t\t\t}\n\t\t}\n\t\treturn treeCompress(NeedBit(treeMake(bits, maxbits, 0, 1), treeMake(bits, maxbits, 1, 1)));\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass Bytes {\n\tpublic var length(default, null):Int;\n\n\tvar b:js.lib.Uint8Array;\n\tvar data:js.lib.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.lib.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get(pos:Int):Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set(pos:Int, v:Int):Void {\n\t\tb[pos] = v;\n\t}\n\n\tpublic function blit(pos:Int, src:Bytes, srcpos:Int, len:Int):Void {\n\t\tif (pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (srcpos == 0 && len == src.b.byteLength)\n\t\t\tb.set(src.b, pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos, srcpos + len), pos);\n\t}\n\n\tpublic function fill(pos:Int, len:Int, value:Int):Void {\n\t\tfor (i in 0...len)\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub(pos:Int, len:Int):Bytes {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos + b.byteOffset, pos + b.byteOffset + len));\n\t}\n\n\tpublic function compare(other:Bytes):Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor (i in 0...len)\n\t\t\tif (b1[i] != b2[i])\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData():Void {\n\t\tif (data == null)\n\t\t\tdata = new js.lib.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat(pos:Int):Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat(pos:Int, v:Float):Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32(pos:Int):Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32(pos:Int, v:Int):Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64(pos:Int):haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4), getInt32(pos));\n\t}\n\n\tpublic function setInt64(pos:Int, v:haxe.Int64):Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString(pos:Int, len:Int, ?encoding:Encoding):String {\n\t\tif (pos < 0 || len < 0 || pos + len > length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (encoding == null)\n\t\t\tencoding = UTF8;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar i = pos;\n\t\tvar max = pos + len;\n\t\tswitch (encoding) {\n\t\t\tcase UTF8:\n\t\t\t\tvar debug = pos > 0;\n\t\t\t\t// utf8-decode and utf16-encode\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++];\n\t\t\t\t\tif (c < 0x80) {\n\t\t\t\t\t\tif (c == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t\t} else if (c < 0xE0)\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x3F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\telse if (c < 0xF0) {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\ts += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar c2 = b[i++];\n\t\t\t\t\t\tvar c3 = b[i++];\n\t\t\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t\t\ts += String.fromCharCode(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase RawNative:\n\t\t\t\twhile (i < max) {\n\t\t\t\t\tvar c = b[i++] | (b[i++] << 8);\n\t\t\t\t\ts += String.fromCharCode(c);\n\t\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString():String {\n\t\treturn getString(0, length);\n\t}\n\n\tpublic function toHex():String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor (i in 0...str.length)\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor (i in 0...length) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData():BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc(length:Int):Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString(s:String, ?encoding:Encoding):Bytes {\n\t\tif (encoding == RawNative) {\n\t\t\tvar buf = new js.lib.Uint8Array(s.length << 1);\n\t\t\tfor (i in 0...s.length) {\n\t\t\t\tvar c:Int = StringTools.fastCodeAt(s, i);\n\t\t\t\tbuf[i << 1] = c & 0xFF;\n\t\t\t\tbuf[(i << 1) | 1] = c >> 8;\n\t\t\t}\n\t\t\treturn new Bytes(buf.buffer);\n\t\t}\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile (i < s.length) {\n\t\t\tvar c:Int = StringTools.fastCodeAt(s, i++);\n\t\t\t// surrogate pair\n\t\t\tif (0xD800 <= c && c <= 0xDBFF)\n\t\t\t\tc = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s, i++) & 0x3FF);\n\t\t\tif (c <= 0x7F)\n\t\t\t\ta.push(c);\n\t\t\telse if (c <= 0x7FF) {\n\t\t\t\ta.push(0xC0 | (c >> 6));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else if (c <= 0xFFFF) {\n\t\t\t\ta.push(0xE0 | (c >> 12));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t} else {\n\t\t\t\ta.push(0xF0 | (c >> 18));\n\t\t\t\ta.push(0x80 | ((c >> 12) & 63));\n\t\t\t\ta.push(0x80 | ((c >> 6) & 63));\n\t\t\t\ta.push(0x80 | (c & 63));\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData(b:BytesData):Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif (hb != null)\n\t\t\treturn hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic static function ofHex(s:String):Bytes {\n\t\tif ((s.length & 1) != 0)\n\t\t\tthrow \"Not a hex string (odd number of digits)\";\n\t\tvar a = new Array();\n\t\tvar i = 0;\n\t\tvar len = s.length >> 1;\n\t\twhile (i < len) {\n\t\t\tvar high = StringTools.fastCodeAt(s, i * 2);\n\t\t\tvar low = StringTools.fastCodeAt(s, i * 2 + 1);\n\t\t\thigh = (high & 0xF) + ((high & 0x40) >> 6) * 9;\n\t\t\tlow = (low & 0xF) + ((low & 0x40) >> 6) * 9;\n\t\t\ta.push(((high << 4) | low) & 0xFF);\n\t\t\ti++;\n\t\t}\n\n\t\treturn new Bytes(new js.lib.Uint8Array(a).buffer);\n\t}\n\n\tpublic inline static function fastGet(b:BytesData, pos:Int):Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCalculates the Adler32 of the given Bytes.\n */\nclass Adler32 {\n\tvar a1:Int;\n\tvar a2:Int;\n\n\tpublic function new() {\n\t\ta1 = 1;\n\t\ta2 = 0;\n\t}\n\n\tpublic function get() {\n\t\treturn (a2 << 16) | a1;\n\t}\n\n\tpublic function update(b:haxe.io.Bytes, pos, len) {\n\t\tvar a1 = a1, a2 = a2;\n\t\tfor (p in pos...pos + len) {\n\t\t\tvar c = b.get(p);\n\t\t\ta1 = (a1 + c) % 65521;\n\t\t\ta2 = (a2 + a1) % 65521;\n\t\t}\n\t\tthis.a1 = a1;\n\t\tthis.a2 = a2;\n\t}\n\n\tpublic function equals(a:Adler32) {\n\t\treturn a.a1 == a1 && a.a2 == a2;\n\t}\n\n\tpublic function toString() {\n\t\treturn StringTools.hex(a2, 8) + StringTools.hex(a1, 8);\n\t}\n\n\tpublic static function read(i:haxe.io.Input) {\n\t\tvar a = new Adler32();\n\t\tvar a2a = i.readByte();\n\t\tvar a2b = i.readByte();\n\t\tvar a1a = i.readByte();\n\t\tvar a1b = i.readByte();\n\t\ta.a1 = (a1a << 8) | a1b;\n\t\ta.a2 = (a2a << 8) | a2b;\n\t\treturn a;\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes) {\n\t\tvar a = new Adler32();\n\t\ta.update(b, 0, b.length);\n\t\treturn a.get();\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nimport haxe.zip.Huffman;\nimport haxe.crypto.Adler32;\n\nprivate class Window {\n\tpublic static inline var SIZE = 1 << 15;\n\tpublic static inline var BUFSIZE = 1 << 16;\n\n\tpublic var buffer:haxe.io.Bytes;\n\tpublic var pos:Int;\n\n\tvar crc:Adler32;\n\n\tpublic function new(hasCrc) {\n\t\tbuffer = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos = 0;\n\t\tif (hasCrc)\n\t\t\tcrc = new Adler32();\n\t}\n\n\tpublic function slide() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, SIZE);\n\t\tvar b = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos -= SIZE;\n\t\tb.blit(0, buffer, SIZE, pos);\n\t\tbuffer = b;\n\t}\n\n\tpublic function addBytes(b, p, len) {\n\t\tif (pos + len > BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.blit(pos, b, p, len);\n\t\tpos += len;\n\t}\n\n\tpublic function addByte(c) {\n\t\tif (pos == BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.set(pos, c);\n\t\tpos++;\n\t}\n\n\tpublic function getLastChar() {\n\t\treturn buffer.get(pos - 1);\n\t}\n\n\tpublic function available() {\n\t\treturn pos;\n\t}\n\n\tpublic function checksum() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, pos);\n\t\treturn crc;\n\t}\n}\n\nprivate enum State {\n\tHead;\n\tBlock;\n\tCData;\n\tFlat;\n\tCrc;\n\tDist;\n\tDistOne;\n\tDone;\n}\n\n/**\n\tA pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.\n**/\nclass InflateImpl {\n\tstatic var LEN_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1\n\t];\n\tstatic var LEN_BASE_VAL_TBL = [\n\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n\t];\n\tstatic var DIST_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1\n\t];\n\tstatic var DIST_BASE_VAL_TBL = [\n\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577\n\t];\n\tstatic var CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\tvar nbits:Int;\n\tvar bits:Int;\n\tvar state:State;\n\tvar isFinal:Bool;\n\tvar huffman:Huffman;\n\tvar huffdist:Null<Huffman>;\n\tvar htools:HuffTools;\n\tvar len:Int;\n\tvar dist:Int;\n\tvar needed:Int;\n\tvar output:haxe.io.Bytes;\n\tvar outpos:Int;\n\tvar input:haxe.io.Input;\n\tvar lengths:Array<Int>;\n\tvar window:Window;\n\n\tstatic var FIXED_HUFFMAN = null;\n\n\tpublic function new(i, ?header = true, ?crc = true) {\n\t\tisFinal = false;\n\t\thtools = new HuffTools();\n\t\thuffman = buildFixedHuffman();\n\t\thuffdist = null;\n\t\tlen = 0;\n\t\tdist = 0;\n\t\tstate = header ? Head : Block;\n\t\tinput = i;\n\t\tbits = 0;\n\t\tnbits = 0;\n\t\tneeded = 0;\n\t\toutput = null;\n\t\toutpos = 0;\n\t\tlengths = new Array();\n\t\tfor (i in 0...19)\n\t\t\tlengths.push(-1);\n\t\twindow = new Window(crc);\n\t}\n\n\tfunction buildFixedHuffman() {\n\t\tif (FIXED_HUFFMAN != null)\n\t\t\treturn FIXED_HUFFMAN;\n\t\tvar a = new Array();\n\t\tfor (n in 0...288)\n\t\t\ta.push(if (n <= 143) 8 else if (n <= 255) 9 else if (n <= 279) 7 else 8);\n\t\tFIXED_HUFFMAN = htools.make(a, 0, 288, 10);\n\t\treturn FIXED_HUFFMAN;\n\t}\n\n\tpublic function readBytes(b, pos, len) {\n\t\tneeded = len;\n\t\toutpos = pos;\n\t\toutput = b;\n\t\tif (len > 0)\n\t\t\twhile (inflateLoop()) {}\n\t\treturn len - needed;\n\t}\n\n\tfunction getBits(n) {\n\t\twhile (nbits < n) {\n\t\t\tbits |= input.readByte() << nbits;\n\t\t\tnbits += 8;\n\t\t}\n\t\tvar b = bits & ((1 << n) - 1);\n\t\tnbits -= n;\n\t\tbits >>= n;\n\t\treturn b;\n\t}\n\n\tfunction getBit() {\n\t\tif (nbits == 0) {\n\t\t\tnbits = 8;\n\t\t\tbits = input.readByte();\n\t\t}\n\t\tvar b = bits & 1 == 1;\n\t\tnbits--;\n\t\tbits >>= 1;\n\t\treturn b;\n\t}\n\n\tfunction getRevBits(n) {\n\t\treturn if (n == 0)\n\t\t\t0\n\t\telse if (getBit())\n\t\t\t(1 << (n - 1)) | getRevBits(n - 1)\n\t\telse\n\t\t\tgetRevBits(n - 1);\n\t}\n\n\tfunction resetBits() {\n\t\tbits = 0;\n\t\tnbits = 0;\n\t}\n\n\tfunction addBytes(b, p, len) {\n\t\twindow.addBytes(b, p, len);\n\t\toutput.blit(outpos, b, p, len);\n\t\tneeded -= len;\n\t\toutpos += len;\n\t}\n\n\tfunction addByte(b) {\n\t\twindow.addByte(b);\n\t\toutput.set(outpos, b);\n\t\tneeded--;\n\t\toutpos++;\n\t}\n\n\tfunction addDistOne(n) {\n\t\tvar c = window.getLastChar();\n\t\tfor (i in 0...n)\n\t\t\taddByte(c);\n\t}\n\n\tfunction addDist(d, len) {\n\t\taddBytes(window.buffer, window.pos - d, len);\n\t}\n\n\tfunction applyHuffman(h) {\n\t\treturn switch (h) {\n\t\t\tcase Found(n): n;\n\t\t\tcase NeedBit(a, b): applyHuffman(getBit() ? b : a);\n\t\t\tcase NeedBits(n, tbl): applyHuffman(tbl[getBits(n)]);\n\t\t}\n\t}\n\n\tfunction inflateLengths(a, max) {\n\t\tvar i = 0;\n\t\tvar prev = 0;\n\t\twhile (i < max) {\n\t\t\tvar n = applyHuffman(huffman);\n\t\t\tswitch (n) {\n\t\t\t\tcase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15:\n\t\t\t\t\tprev = n;\n\t\t\t\t\ta[i] = n;\n\t\t\t\t\ti++;\n\t\t\t\tcase 16:\n\t\t\t\t\tvar end = i + 3 + getBits(2);\n\t\t\t\t\tif (end > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\twhile (i < end) {\n\t\t\t\t\t\ta[i] = prev;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\tcase 17:\n\t\t\t\t\ti += 3 + getBits(3);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tcase 18:\n\t\t\t\t\ti += 11 + getBits(7);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction inflateLoop() {\n\t\tswitch (state) {\n\t\t\tcase Head:\n\t\t\t\tvar cmf = input.readByte();\n\t\t\t\tvar cm = cmf & 15;\n\t\t\t\tvar cinfo = cmf >> 4;\n\t\t\t\tif (cm != 8)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tvar flg = input.readByte();\n\t\t\t\t// var fcheck = flg & 31;\n\t\t\t\tvar fdict = flg & 32 != 0;\n\t\t\t\t// var flevel = flg >> 6;\n\t\t\t\tif (((cmf << 8) + flg) % 31 != 0)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tif (fdict)\n\t\t\t\t\tthrow \"Unsupported dictionary\";\n\t\t\t\tstate = Block;\n\t\t\t\treturn true;\n\t\t\tcase Crc:\n\t\t\t\tvar calc = window.checksum();\n\t\t\t\tif (calc == null) {\n\t\t\t\t\tstate = Done;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar crc = Adler32.read(input);\n\t\t\t\tif (!calc.equals(crc))\n\t\t\t\t\tthrow \"Invalid CRC\";\n\t\t\t\tstate = Done;\n\t\t\t\treturn true;\n\t\t\tcase Done:\n\t\t\t\t// nothing\n\t\t\t\treturn false;\n\t\t\tcase Block:\n\t\t\t\tisFinal = getBit();\n\t\t\t\tswitch (getBits(2)) {\n\t\t\t\t\tcase 0: // no compression\n\t\t\t\t\t\tlen = input.readUInt16();\n\t\t\t\t\t\tvar nlen = input.readUInt16();\n\t\t\t\t\t\tif (nlen != 0xFFFF - len) throw \"Invalid data\";\n\t\t\t\t\t\tstate = Flat;\n\t\t\t\t\t\tvar r = inflateLoop();\n\t\t\t\t\t\tresetBits();\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tcase 1: // fixed Huffman\n\t\t\t\t\t\thuffman = buildFixedHuffman();\n\t\t\t\t\t\thuffdist = null;\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 2: // dynamic Huffman\n\t\t\t\t\t\tvar hlit = getBits(5) + 257;\n\t\t\t\t\t\tvar hdist = getBits(5) + 1;\n\t\t\t\t\t\tvar hclen = getBits(4) + 4;\n\t\t\t\t\t\tfor (i in 0...hclen)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = getBits(3);\n\t\t\t\t\t\tfor (i in hclen...19)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = 0;\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, 19, 8);\n\t\t\t\t\t\tvar lengths = new Array();\n\t\t\t\t\t\tfor (i in 0...hlit + hdist)\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\tinflateLengths(lengths, hlit + hdist);\n\t\t\t\t\t\thuffdist = htools.make(lengths, hlit, hdist, 16);\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, hlit, 16);\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t}\n\t\t\tcase Flat:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\tvar bytes = input.read(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\taddBytes(bytes, 0, rlen);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\treturn needed > 0;\n\t\t\tcase DistOne:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\taddDistOne(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase Dist:\n\t\t\t\twhile (len > 0 && needed > 0) {\n\t\t\t\t\tvar rdist = (len < dist) ? len : dist;\n\t\t\t\t\tvar rlen = (needed < rdist) ? needed : rdist;\n\t\t\t\t\taddDist(dist, rlen);\n\t\t\t\t\tlen -= rlen;\n\t\t\t\t}\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase CData:\n\t\t\t\tvar n = applyHuffman(huffman);\n\t\t\t\tif (n < 256) {\n\t\t\t\t\taddByte(n);\n\t\t\t\t\treturn needed > 0;\n\t\t\t\t} else if (n == 256) {\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tn -= 257;\n\t\t\t\t\tvar extra_bits = LEN_EXTRA_BITS_TBL[n];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tlen = LEN_BASE_VAL_TBL[n] + getBits(extra_bits);\n\t\t\t\t\tvar dist_code = if (huffdist == null) getRevBits(5) else applyHuffman(huffdist);\n\t\t\t\t\textra_bits = DIST_EXTRA_BITS_TBL[dist_code];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tdist = DIST_BASE_VAL_TBL[dist_code] + getBits(extra_bits);\n\t\t\t\t\tif (dist > window.available())\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tstate = (dist == 1) ? DistOne : Dist;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function run(i:haxe.io.Input, ?bufsize = 65536) {\n\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\n\t\tvar output = new haxe.io.BytesBuffer();\n\t\tvar inflate = new InflateImpl(i);\n\t\twhile (true) {\n\t\t\tvar len = inflate.readBytes(buf, 0, bufsize);\n\t\t\toutput.addBytes(buf, 0, len);\n\t\t\tif (len < bufsize)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn output.getBytes();\n\t}\n}\n"]}