{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"InflateImpl.js.map","sources":["../../../../../../../haxe/versions/4.1.3/std/haxe/zip/Huffman.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/crypto/Adler32.hx","../../../../../../../haxe/versions/4.1.3/std/js/_std/haxe/Exception.hx","../../../../../../../haxe/versions/4.1.3/std/haxe/zip/InflateImpl.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nenum Huffman {\n\tFound(i:Int);\n\tNeedBit(left:Huffman, right:Huffman);\n\tNeedBits(n:Int, table:Array<Huffman>);\n}\n\nclass HuffTools {\n\tpublic function new() {}\n\n\tfunction treeDepth(t) {\n\t\treturn switch (t) {\n\t\t\tcase Found(_): 0;\n\t\t\tcase NeedBits(_, _): throw \"assert\";\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tvar da = treeDepth(a);\n\t\t\t\tvar db = treeDepth(b);\n\t\t\t\t1 + ((da < db) ? da : db);\n\t\t}\n\t}\n\n\tfunction treeCompress(t) {\n\t\tvar d = treeDepth(t);\n\t\tif (d == 0)\n\t\t\treturn t;\n\t\tif (d == 1)\n\t\t\treturn switch (t) {\n\t\t\t\tcase NeedBit(a, b): NeedBit(treeCompress(a), treeCompress(b));\n\t\t\t\tdefault: throw \"assert\";\n\t\t\t}\n\t\tvar size = 1 << d;\n\t\tvar table = new Array();\n\t\tfor (i in 0...size)\n\t\t\ttable.push(Found(-1));\n\t\ttreeWalk(table, 0, 0, d, t);\n\t\treturn NeedBits(d, table);\n\t}\n\n\tfunction treeWalk(table, p, cd, d, t) {\n\t\tswitch (t) {\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tif (d > 0) {\n\t\t\t\t\ttreeWalk(table, p, cd + 1, d - 1, a);\n\t\t\t\t\ttreeWalk(table, p | (1 << cd), cd + 1, d - 1, b);\n\t\t\t\t} else\n\t\t\t\t\ttable[p] = treeCompress(t);\n\t\t\tdefault:\n\t\t\t\ttable[p] = treeCompress(t);\n\t\t}\n\t}\n\n\tfunction treeMake(bits:haxe.ds.IntMap<Int>, maxbits:Int, v:Int, len:Int) {\n\t\tif (len > maxbits)\n\t\t\tthrow \"Invalid huffman\";\n\t\tvar idx = (v << 5) | len;\n\t\tif (bits.exists(idx))\n\t\t\treturn Found(bits.get(idx));\n\t\tv <<= 1;\n\t\tlen += 1;\n\t\treturn NeedBit(treeMake(bits, maxbits, v, len), treeMake(bits, maxbits, v | 1, len));\n\t}\n\n\tpublic function make(lengths, pos, nlengths, maxbits) {\n\t\tif (nlengths == 1) {\n\t\t\treturn NeedBit(Found(0), Found(0));\n\t\t}\n\t\tvar counts = new Array();\n\t\tvar tmp = new Array();\n\t\tif (maxbits > 32)\n\t\t\tthrow \"Invalid huffman\";\n\t\tfor (i in 0...maxbits) {\n\t\t\tcounts.push(0);\n\t\t\ttmp.push(0);\n\t\t}\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar p = lengths[i + pos];\n\t\t\tif (p >= maxbits)\n\t\t\t\tthrow \"Invalid huffman\";\n\t\t\tcounts[p]++;\n\t\t}\n\t\tvar code = 0;\n\t\tfor (i in 1...maxbits - 1) {\n\t\t\tcode = (code + counts[i]) << 1;\n\t\t\ttmp[i] = code;\n\t\t}\n\t\tvar bits = new haxe.ds.IntMap();\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar l = lengths[i + pos];\n\t\t\tif (l != 0) {\n\t\t\t\tvar n = tmp[l - 1];\n\t\t\t\ttmp[l - 1] = n + 1;\n\t\t\t\tbits.set((n << 5) | l, i);\n\t\t\t}\n\t\t}\n\t\treturn treeCompress(NeedBit(treeMake(bits, maxbits, 0, 1), treeMake(bits, maxbits, 1, 1)));\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCalculates the Adler32 of the given Bytes.\n */\nclass Adler32 {\n\tvar a1:Int;\n\tvar a2:Int;\n\n\tpublic function new() {\n\t\ta1 = 1;\n\t\ta2 = 0;\n\t}\n\n\tpublic function get() {\n\t\treturn (a2 << 16) | a1;\n\t}\n\n\tpublic function update(b:haxe.io.Bytes, pos, len) {\n\t\tvar a1 = a1, a2 = a2;\n\t\tfor (p in pos...pos + len) {\n\t\t\tvar c = b.get(p);\n\t\t\ta1 = (a1 + c) % 65521;\n\t\t\ta2 = (a2 + a1) % 65521;\n\t\t}\n\t\tthis.a1 = a1;\n\t\tthis.a2 = a2;\n\t}\n\n\tpublic function equals(a:Adler32) {\n\t\treturn a.a1 == a1 && a.a2 == a2;\n\t}\n\n\tpublic function toString() {\n\t\treturn StringTools.hex(a2, 8) + StringTools.hex(a1, 8);\n\t}\n\n\tpublic static function read(i:haxe.io.Input) {\n\t\tvar a = new Adler32();\n\t\tvar a2a = i.readByte();\n\t\tvar a2b = i.readByte();\n\t\tvar a1a = i.readByte();\n\t\tvar a1b = i.readByte();\n\t\ta.a1 = (a1a << 8) | a1b;\n\t\ta.a2 = (a2a << 8) | a2b;\n\t\treturn a;\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes) {\n\t\tvar a = new Adler32();\n\t\ta.update(b, 0, b.length);\n\t\treturn a.get();\n\t}\n}\n","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nimport haxe.zip.Huffman;\nimport haxe.crypto.Adler32;\n\nprivate class Window {\n\tpublic static inline var SIZE = 1 << 15;\n\tpublic static inline var BUFSIZE = 1 << 16;\n\n\tpublic var buffer:haxe.io.Bytes;\n\tpublic var pos:Int;\n\n\tvar crc:Adler32;\n\n\tpublic function new(hasCrc) {\n\t\tbuffer = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos = 0;\n\t\tif (hasCrc)\n\t\t\tcrc = new Adler32();\n\t}\n\n\tpublic function slide() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, SIZE);\n\t\tvar b = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos -= SIZE;\n\t\tb.blit(0, buffer, SIZE, pos);\n\t\tbuffer = b;\n\t}\n\n\tpublic function addBytes(b, p, len) {\n\t\tif (pos + len > BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.blit(pos, b, p, len);\n\t\tpos += len;\n\t}\n\n\tpublic function addByte(c) {\n\t\tif (pos == BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.set(pos, c);\n\t\tpos++;\n\t}\n\n\tpublic function getLastChar() {\n\t\treturn buffer.get(pos - 1);\n\t}\n\n\tpublic function available() {\n\t\treturn pos;\n\t}\n\n\tpublic function checksum() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, pos);\n\t\treturn crc;\n\t}\n}\n\nprivate enum State {\n\tHead;\n\tBlock;\n\tCData;\n\tFlat;\n\tCrc;\n\tDist;\n\tDistOne;\n\tDone;\n}\n\n/**\n\tA pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.\n**/\nclass InflateImpl {\n\tstatic var LEN_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1\n\t];\n\tstatic var LEN_BASE_VAL_TBL = [\n\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n\t];\n\tstatic var DIST_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1\n\t];\n\tstatic var DIST_BASE_VAL_TBL = [\n\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577\n\t];\n\tstatic var CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\tvar nbits:Int;\n\tvar bits:Int;\n\tvar state:State;\n\tvar isFinal:Bool;\n\tvar huffman:Huffman;\n\tvar huffdist:Null<Huffman>;\n\tvar htools:HuffTools;\n\tvar len:Int;\n\tvar dist:Int;\n\tvar needed:Int;\n\tvar output:haxe.io.Bytes;\n\tvar outpos:Int;\n\tvar input:haxe.io.Input;\n\tvar lengths:Array<Int>;\n\tvar window:Window;\n\n\tstatic var FIXED_HUFFMAN = null;\n\n\tpublic function new(i, ?header = true, ?crc = true) {\n\t\tisFinal = false;\n\t\thtools = new HuffTools();\n\t\thuffman = buildFixedHuffman();\n\t\thuffdist = null;\n\t\tlen = 0;\n\t\tdist = 0;\n\t\tstate = header ? Head : Block;\n\t\tinput = i;\n\t\tbits = 0;\n\t\tnbits = 0;\n\t\tneeded = 0;\n\t\toutput = null;\n\t\toutpos = 0;\n\t\tlengths = new Array();\n\t\tfor (i in 0...19)\n\t\t\tlengths.push(-1);\n\t\twindow = new Window(crc);\n\t}\n\n\tfunction buildFixedHuffman() {\n\t\tif (FIXED_HUFFMAN != null)\n\t\t\treturn FIXED_HUFFMAN;\n\t\tvar a = new Array();\n\t\tfor (n in 0...288)\n\t\t\ta.push(if (n <= 143) 8 else if (n <= 255) 9 else if (n <= 279) 7 else 8);\n\t\tFIXED_HUFFMAN = htools.make(a, 0, 288, 10);\n\t\treturn FIXED_HUFFMAN;\n\t}\n\n\tpublic function readBytes(b, pos, len) {\n\t\tneeded = len;\n\t\toutpos = pos;\n\t\toutput = b;\n\t\tif (len > 0)\n\t\t\twhile (inflateLoop()) {}\n\t\treturn len - needed;\n\t}\n\n\tfunction getBits(n) {\n\t\twhile (nbits < n) {\n\t\t\tbits |= input.readByte() << nbits;\n\t\t\tnbits += 8;\n\t\t}\n\t\tvar b = bits & ((1 << n) - 1);\n\t\tnbits -= n;\n\t\tbits >>= n;\n\t\treturn b;\n\t}\n\n\tfunction getBit() {\n\t\tif (nbits == 0) {\n\t\t\tnbits = 8;\n\t\t\tbits = input.readByte();\n\t\t}\n\t\tvar b = bits & 1 == 1;\n\t\tnbits--;\n\t\tbits >>= 1;\n\t\treturn b;\n\t}\n\n\tfunction getRevBits(n) {\n\t\treturn if (n == 0)\n\t\t\t0\n\t\telse if (getBit())\n\t\t\t(1 << (n - 1)) | getRevBits(n - 1)\n\t\telse\n\t\t\tgetRevBits(n - 1);\n\t}\n\n\tfunction resetBits() {\n\t\tbits = 0;\n\t\tnbits = 0;\n\t}\n\n\tfunction addBytes(b, p, len) {\n\t\twindow.addBytes(b, p, len);\n\t\toutput.blit(outpos, b, p, len);\n\t\tneeded -= len;\n\t\toutpos += len;\n\t}\n\n\tfunction addByte(b) {\n\t\twindow.addByte(b);\n\t\toutput.set(outpos, b);\n\t\tneeded--;\n\t\toutpos++;\n\t}\n\n\tfunction addDistOne(n) {\n\t\tvar c = window.getLastChar();\n\t\tfor (i in 0...n)\n\t\t\taddByte(c);\n\t}\n\n\tfunction addDist(d, len) {\n\t\taddBytes(window.buffer, window.pos - d, len);\n\t}\n\n\tfunction applyHuffman(h) {\n\t\treturn switch (h) {\n\t\t\tcase Found(n): n;\n\t\t\tcase NeedBit(a, b): applyHuffman(getBit() ? b : a);\n\t\t\tcase NeedBits(n, tbl): applyHuffman(tbl[getBits(n)]);\n\t\t}\n\t}\n\n\tfunction inflateLengths(a, max) {\n\t\tvar i = 0;\n\t\tvar prev = 0;\n\t\twhile (i < max) {\n\t\t\tvar n = applyHuffman(huffman);\n\t\t\tswitch (n) {\n\t\t\t\tcase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15:\n\t\t\t\t\tprev = n;\n\t\t\t\t\ta[i] = n;\n\t\t\t\t\ti++;\n\t\t\t\tcase 16:\n\t\t\t\t\tvar end = i + 3 + getBits(2);\n\t\t\t\t\tif (end > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\twhile (i < end) {\n\t\t\t\t\t\ta[i] = prev;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\tcase 17:\n\t\t\t\t\ti += 3 + getBits(3);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tcase 18:\n\t\t\t\t\ti += 11 + getBits(7);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction inflateLoop() {\n\t\tswitch (state) {\n\t\t\tcase Head:\n\t\t\t\tvar cmf = input.readByte();\n\t\t\t\tvar cm = cmf & 15;\n\t\t\t\tvar cinfo = cmf >> 4;\n\t\t\t\tif (cm != 8)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tvar flg = input.readByte();\n\t\t\t\t// var fcheck = flg & 31;\n\t\t\t\tvar fdict = flg & 32 != 0;\n\t\t\t\t// var flevel = flg >> 6;\n\t\t\t\tif (((cmf << 8) + flg) % 31 != 0)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tif (fdict)\n\t\t\t\t\tthrow \"Unsupported dictionary\";\n\t\t\t\tstate = Block;\n\t\t\t\treturn true;\n\t\t\tcase Crc:\n\t\t\t\tvar calc = window.checksum();\n\t\t\t\tif (calc == null) {\n\t\t\t\t\tstate = Done;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar crc = Adler32.read(input);\n\t\t\t\tif (!calc.equals(crc))\n\t\t\t\t\tthrow \"Invalid CRC\";\n\t\t\t\tstate = Done;\n\t\t\t\treturn true;\n\t\t\tcase Done:\n\t\t\t\t// nothing\n\t\t\t\treturn false;\n\t\t\tcase Block:\n\t\t\t\tisFinal = getBit();\n\t\t\t\tswitch (getBits(2)) {\n\t\t\t\t\tcase 0: // no compression\n\t\t\t\t\t\tlen = input.readUInt16();\n\t\t\t\t\t\tvar nlen = input.readUInt16();\n\t\t\t\t\t\tif (nlen != 0xFFFF - len) throw \"Invalid data\";\n\t\t\t\t\t\tstate = Flat;\n\t\t\t\t\t\tvar r = inflateLoop();\n\t\t\t\t\t\tresetBits();\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tcase 1: // fixed Huffman\n\t\t\t\t\t\thuffman = buildFixedHuffman();\n\t\t\t\t\t\thuffdist = null;\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 2: // dynamic Huffman\n\t\t\t\t\t\tvar hlit = getBits(5) + 257;\n\t\t\t\t\t\tvar hdist = getBits(5) + 1;\n\t\t\t\t\t\tvar hclen = getBits(4) + 4;\n\t\t\t\t\t\tfor (i in 0...hclen)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = getBits(3);\n\t\t\t\t\t\tfor (i in hclen...19)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = 0;\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, 19, 8);\n\t\t\t\t\t\tvar lengths = new Array();\n\t\t\t\t\t\tfor (i in 0...hlit + hdist)\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\tinflateLengths(lengths, hlit + hdist);\n\t\t\t\t\t\thuffdist = htools.make(lengths, hlit, hdist, 16);\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, hlit, 16);\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t}\n\t\t\tcase Flat:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\tvar bytes = input.read(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\taddBytes(bytes, 0, rlen);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\treturn needed > 0;\n\t\t\tcase DistOne:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\taddDistOne(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase Dist:\n\t\t\t\twhile (len > 0 && needed > 0) {\n\t\t\t\t\tvar rdist = (len < dist) ? len : dist;\n\t\t\t\t\tvar rlen = (needed < rdist) ? needed : rdist;\n\t\t\t\t\taddDist(dist, rlen);\n\t\t\t\t\tlen -= rlen;\n\t\t\t\t}\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase CData:\n\t\t\t\tvar n = applyHuffman(huffman);\n\t\t\t\tif (n < 256) {\n\t\t\t\t\taddByte(n);\n\t\t\t\t\treturn needed > 0;\n\t\t\t\t} else if (n == 256) {\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tn -= 257;\n\t\t\t\t\tvar extra_bits = LEN_EXTRA_BITS_TBL[n];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tlen = LEN_BASE_VAL_TBL[n] + getBits(extra_bits);\n\t\t\t\t\tvar dist_code = if (huffdist == null) getRevBits(5) else applyHuffman(huffdist);\n\t\t\t\t\textra_bits = DIST_EXTRA_BITS_TBL[dist_code];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tdist = DIST_BASE_VAL_TBL[dist_code] + getBits(extra_bits);\n\t\t\t\t\tif (dist > window.available())\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tstate = (dist == 1) ? DistOne : Dist;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function run(i:haxe.io.Input, ?bufsize = 65536) {\n\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\n\t\tvar output = new haxe.io.BytesBuffer();\n\t\tvar inflate = new InflateImpl(i);\n\t\twhile (true) {\n\t\t\tvar len = inflate.readBytes(buf, 0, bufsize);\n\t\t\toutput.addBytes(buf, 0, len);\n\t\t\tif (len < bufsize)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn output.getBytes();\n\t}\n}\n"]}