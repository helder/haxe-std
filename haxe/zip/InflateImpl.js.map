{"sourceRoot":"","names":[],"mappings":"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","version":3,"file":"InflateImpl.js.map","sources":["../../../../../../../haxe/versions/4.0.5/std/js/Boot.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/zip/Huffman.hx","../../../../../../../haxe/versions/4.0.5/std/js/_std/haxe/io/BytesBuffer.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/crypto/Adler32.hx","../../../../../../../haxe/haxe_libraries/genes/0.3.0/github/2408778ccba83def22930ef9595d1639043c1dc2/src/genes/Register.hx","../../../../../../../haxe/versions/4.0.5/std/haxe/zip/InflateImpl.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.lib.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.lib.Error).captureStackTrace)\n\t\t\t(cast js.lib.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.lib.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.lib.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.lib.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\tstatic inline function isClass(o:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isInterface(o:Class<Dynamic>):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isInterface\", o.__isInterface__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic):Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\t@:pure static function getClass(o:Null<Dynamic>):Null<Dynamic> {\n\t\tif (o == null) {\n\t\t\treturn null;\n\t\t} else if (Std.is(o, Array)) {\n\t\t\treturn Array;\n\t\t} else {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o, s:String) {\n\t\tuntyped {\n\t\t\tif (o == null)\n\t\t\t\treturn \"null\";\n\t\t\tif (s.length >= 5)\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif (t == \"function\" && (isClass(o) || isEnum(o)))\n\t\t\t\tt = \"object\";\n\t\t\tswitch (t) {\n\t\t\t\tcase \"object\":\n\t\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\t\tvar con = e[n];\n\t\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\treturn n + \"(\" + [for (p in (con.__params__ : Array<String>)) __string_rec(o[p], s)].join(\",\") + \")\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t#end\n\t\t\t\t\tif (js.Syntax.instanceof(o, Array)) {\n\t\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\t\t__feature__(\"has_enum\", if (o.__enum__) {\n\t\t\t\t\t\t\tif (o.length == 2)\n\t\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\t\tvar str = o[0] + \"(\";\n\t\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\t\tfor (i in 2...o.length) {\n\t\t\t\t\t\t\t\tif (i != 2)\n\t\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i], s);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tstr += __string_rec(o[i], s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t\t});\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor (i in 0...o.length)\n\t\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\") + __string_rec(o[i], s);\n\t\t\t\t\t\tstr += \"]\";\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}\n\t\t\t\t\tvar tostr;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t\t} catch (e:Dynamic) {\n\t\t\t\t\t\t// strange error on IE\n\t\t\t\t\t\treturn \"???\";\n\t\t\t\t\t}\n\t\t\t\t\tif (tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\") {\n\t\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\t\tif (s2 != \"[object Object]\")\n\t\t\t\t\t\t\treturn s2;\n\t\t\t\t\t}\n\t\t\t\t\tvar str = \"{\\n\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t\tvar k:String = null;\n\t\t\t\t\t__js__(\"for( {0} in {1} ) {\", k, o);\n\t\t\t\t\tif (hasp && !o.hasOwnProperty(k))\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\")\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif (str.length != 2)\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \" + __string_rec(o[k], s);\n\t\t\t\t\t__js__(\"}\");\n\t\t\t\t\ts = s.substring(1);\n\t\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\t\treturn str;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn \"<function>\";\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn o;\n\t\t\t\tdefault:\n\t\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\t@:pure private static function __interfLoop(cc:Dynamic, cl:Dynamic) {\n\t\tif (cc == null)\n\t\t\treturn false;\n\t\tif (cc == cl)\n\t\t\treturn true;\n\t\tif (js.lib.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\")) {\n\t\t\tvar intf:Dynamic = cc.__interfaces__;\n\t\t\tfor (i in 0...intf.length) {\n\t\t\t\tvar i:Dynamic = intf[i];\n\t\t\t\tif (i == cl || __interfLoop(i, cl))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__, cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o:Dynamic, cl:Dynamic) {\n\t\tif (cl == null)\n\t\t\treturn false;\n\t\tswitch (cl) {\n\t\t\tcase Int:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\t\tcase Float:\n\t\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\t\tcase Bool:\n\t\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\t\tcase String:\n\t\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\t\tcase Array:\n\t\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\t\tcase Dynamic:\n\t\t\t\treturn o != null;\n\t\t\tdefault:\n\t\t\t\tif (o != null) {\n\t\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\t\tif (js.Syntax.typeof(cl) == \"function\") {\n\t\t\t\t\t\tif (__downcastCheck(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl)) {\n\t\t\t\t\t\tif (js.Syntax.instanceof(o, cl))\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// do not use isClass/isEnum here\n\t\t\t\tuntyped __feature__(\"Class.*\", if (cl == Class && o.__name__ != null) return true);\n\t\t\t\tuntyped __feature__(\"Enum.*\", if (cl == Enum && o.__ename__ != null) return true);\n\t\t\t\t#if js_enums_as_arrays\n\t\t\t\treturn o.__enum__ == cl;\n\t\t\t\t#else\n\t\t\t\treturn untyped __feature__(\n\t\t\t\t\t\"has_enum\",\n\t\t\t\t\tif (o.__enum__ != null) ($hxEnums[o.__enum__]) == cl else false,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t\t#end\n\t\t}\n\t}\n\n\tstatic function __downcastCheck(o:Dynamic, cl:Class<Dynamic>):Bool {\n\t\treturn js.Syntax.instanceof(o, cl) || (isInterface(cl) && inline __implements(o, cl));\n\t}\n\n\tstatic function __implements(o:Dynamic, iface:Class<Dynamic>):Bool {\n\t\treturn __interfLoop(getClass(o), iface);\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o:Dynamic, t:Dynamic) {\n\t\tif (o == null || __instanceof(o, t))\n\t\t\treturn o;\n\t\telse\n\t\t\tthrow \"Cannot cast \" + Std.string(o) + \" to \" + Std.string(t);\n\t}\n\n\tstatic var __toStr:js.lib.Function;\n\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nenum Huffman {\n\tFound(i:Int);\n\tNeedBit(left:Huffman, right:Huffman);\n\tNeedBits(n:Int, table:Array<Huffman>);\n}\n\nclass HuffTools {\n\tpublic function new() {}\n\n\tfunction treeDepth(t) {\n\t\treturn switch (t) {\n\t\t\tcase Found(_): 0;\n\t\t\tcase NeedBits(_, _): throw \"assert\";\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tvar da = treeDepth(a);\n\t\t\t\tvar db = treeDepth(b);\n\t\t\t\t1 + ((da < db) ? da : db);\n\t\t}\n\t}\n\n\tfunction treeCompress(t) {\n\t\tvar d = treeDepth(t);\n\t\tif (d == 0)\n\t\t\treturn t;\n\t\tif (d == 1)\n\t\t\treturn switch (t) {\n\t\t\t\tcase NeedBit(a, b): NeedBit(treeCompress(a), treeCompress(b));\n\t\t\t\tdefault: throw \"assert\";\n\t\t\t}\n\t\tvar size = 1 << d;\n\t\tvar table = new Array();\n\t\tfor (i in 0...size)\n\t\t\ttable.push(Found(-1));\n\t\ttreeWalk(table, 0, 0, d, t);\n\t\treturn NeedBits(d, table);\n\t}\n\n\tfunction treeWalk(table, p, cd, d, t) {\n\t\tswitch (t) {\n\t\t\tcase NeedBit(a, b):\n\t\t\t\tif (d > 0) {\n\t\t\t\t\ttreeWalk(table, p, cd + 1, d - 1, a);\n\t\t\t\t\ttreeWalk(table, p | (1 << cd), cd + 1, d - 1, b);\n\t\t\t\t} else\n\t\t\t\t\ttable[p] = treeCompress(t);\n\t\t\tdefault:\n\t\t\t\ttable[p] = treeCompress(t);\n\t\t}\n\t}\n\n\tfunction treeMake(bits:haxe.ds.IntMap<Int>, maxbits:Int, v:Int, len:Int) {\n\t\tif (len > maxbits)\n\t\t\tthrow \"Invalid huffman\";\n\t\tvar idx = (v << 5) | len;\n\t\tif (bits.exists(idx))\n\t\t\treturn Found(bits.get(idx));\n\t\tv <<= 1;\n\t\tlen += 1;\n\t\treturn NeedBit(treeMake(bits, maxbits, v, len), treeMake(bits, maxbits, v | 1, len));\n\t}\n\n\tpublic function make(lengths, pos, nlengths, maxbits) {\n\t\tif (nlengths == 1) {\n\t\t\treturn NeedBit(Found(0), Found(0));\n\t\t}\n\t\tvar counts = new Array();\n\t\tvar tmp = new Array();\n\t\tif (maxbits > 32)\n\t\t\tthrow \"Invalid huffman\";\n\t\tfor (i in 0...maxbits) {\n\t\t\tcounts.push(0);\n\t\t\ttmp.push(0);\n\t\t}\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar p = lengths[i + pos];\n\t\t\tif (p >= maxbits)\n\t\t\t\tthrow \"Invalid huffman\";\n\t\t\tcounts[p]++;\n\t\t}\n\t\tvar code = 0;\n\t\tfor (i in 1...maxbits - 1) {\n\t\t\tcode = (code + counts[i]) << 1;\n\t\t\ttmp[i] = code;\n\t\t}\n\t\tvar bits = new haxe.ds.IntMap();\n\t\tfor (i in 0...nlengths) {\n\t\t\tvar l = lengths[i + pos];\n\t\t\tif (l != 0) {\n\t\t\t\tvar n = tmp[l - 1];\n\t\t\t\ttmp[l - 1] = n + 1;\n\t\t\t\tbits.set((n << 5) | l, i);\n\t\t\t}\n\t\t}\n\t\treturn treeCompress(NeedBit(treeMake(bits, maxbits, 0, 1), treeMake(bits, maxbits, 1, 1)));\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n@:coreApi\nclass BytesBuffer {\n\tvar buffer:js.lib.ArrayBuffer;\n\tvar view:js.lib.DataView;\n\tvar u8:js.lib.Uint8Array;\n\tvar pos:Int;\n\tvar size:Int;\n\n\tpublic var length(get, never):Int;\n\n\tpublic function new() {\n\t\tpos = 0;\n\t\tsize = 0;\n\t}\n\n\tinline function get_length():Int {\n\t\treturn pos;\n\t}\n\n\tpublic function addByte(byte:Int):Void {\n\t\tif (pos == size)\n\t\t\tgrow(1);\n\t\tview.setUint8(pos++, byte);\n\t}\n\n\tpublic function add(src:Bytes):Void {\n\t\tif (pos + src.length > size)\n\t\t\tgrow(src.length);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset, src.length);\n\t\tu8.set(sub, pos);\n\t\tpos += src.length;\n\t}\n\n\tpublic function addString(v:String, ?encoding:Encoding):Void {\n\t\tadd(Bytes.ofString(v, encoding));\n\t}\n\n\tpublic function addInt32(v:Int):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setInt32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addInt64(v:haxe.Int64):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setInt32(pos, v.low, true);\n\t\tview.setInt32(pos + 4, v.high, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addFloat(v:Float):Void {\n\t\tif (pos + 4 > size)\n\t\t\tgrow(4);\n\t\tview.setFloat32(pos, v, true);\n\t\tpos += 4;\n\t}\n\n\tpublic function addDouble(v:Float):Void {\n\t\tif (pos + 8 > size)\n\t\t\tgrow(8);\n\t\tview.setFloat64(pos, v, true);\n\t\tpos += 8;\n\t}\n\n\tpublic function addBytes(src:Bytes, pos:Int, len:Int):Void {\n\t\tif (pos < 0 || len < 0 || pos + len > src.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\tif (this.pos + len > size)\n\t\t\tgrow(len);\n\t\tif (size == 0)\n\t\t\treturn;\n\t\tvar sub = new js.lib.Uint8Array(@:privateAccess src.b.buffer, @:privateAccess src.b.byteOffset + pos, len);\n\t\tu8.set(sub, this.pos);\n\t\tthis.pos += len;\n\t}\n\n\tfunction grow(delta:Int):Void {\n\t\tvar req = pos + delta;\n\t\tvar nsize = size == 0 ? 16 : size;\n\t\twhile (nsize < req)\n\t\t\tnsize = (nsize * 3) >> 1;\n\t\tvar nbuf = new js.lib.ArrayBuffer(nsize);\n\t\tvar nu8 = new js.lib.Uint8Array(nbuf);\n\t\tif (size > 0)\n\t\t\tnu8.set(u8);\n\t\tsize = nsize;\n\t\tbuffer = nbuf;\n\t\tu8 = nu8;\n\t\tview = new js.lib.DataView(buffer);\n\t}\n\n\tpublic function getBytes():Bytes@:privateAccess {\n\t\tif (size == 0)\n\t\t\treturn haxe.io.Bytes.alloc(0);\n\t\tvar b = new Bytes(buffer);\n\t\tb.length = pos;\n\t\treturn b;\n\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.crypto;\n\n/**\n\tCalculates the Adler32 of the given Bytes.\n */\nclass Adler32 {\n\tvar a1:Int;\n\tvar a2:Int;\n\n\tpublic function new() {\n\t\ta1 = 1;\n\t\ta2 = 0;\n\t}\n\n\tpublic function get() {\n\t\treturn (a2 << 16) | a1;\n\t}\n\n\tpublic function update(b:haxe.io.Bytes, pos, len) {\n\t\tvar a1 = a1, a2 = a2;\n\t\tfor (p in pos...pos + len) {\n\t\t\tvar c = b.get(p);\n\t\t\ta1 = (a1 + c) % 65521;\n\t\t\ta2 = (a2 + a1) % 65521;\n\t\t}\n\t\tthis.a1 = a1;\n\t\tthis.a2 = a2;\n\t}\n\n\tpublic function equals(a:Adler32) {\n\t\treturn a.a1 == a1 && a.a2 == a2;\n\t}\n\n\tpublic function toString() {\n\t\treturn StringTools.hex(a2, 8) + StringTools.hex(a1, 8);\n\t}\n\n\tpublic static function read(i:haxe.io.Input) {\n\t\tvar a = new Adler32();\n\t\tvar a2a = i.readByte();\n\t\tvar a2b = i.readByte();\n\t\tvar a1a = i.readByte();\n\t\tvar a1b = i.readByte();\n\t\ta.a1 = (a1a << 8) | a1b;\n\t\ta.a2 = (a2a << 8) | a2b;\n\t\treturn a;\n\t}\n\n\tpublic static function make(b:haxe.io.Bytes) {\n\t\tvar a = new Adler32();\n\t\ta.update(b, 0, b.length);\n\t\treturn a.get();\n\t}\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.zip;\n\nimport haxe.zip.Huffman;\nimport haxe.crypto.Adler32;\n\nprivate class Window {\n\tpublic static inline var SIZE = 1 << 15;\n\tpublic static inline var BUFSIZE = 1 << 16;\n\n\tpublic var buffer:haxe.io.Bytes;\n\tpublic var pos:Int;\n\n\tvar crc:Adler32;\n\n\tpublic function new(hasCrc) {\n\t\tbuffer = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos = 0;\n\t\tif (hasCrc)\n\t\t\tcrc = new Adler32();\n\t}\n\n\tpublic function slide() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, SIZE);\n\t\tvar b = haxe.io.Bytes.alloc(BUFSIZE);\n\t\tpos -= SIZE;\n\t\tb.blit(0, buffer, SIZE, pos);\n\t\tbuffer = b;\n\t}\n\n\tpublic function addBytes(b, p, len) {\n\t\tif (pos + len > BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.blit(pos, b, p, len);\n\t\tpos += len;\n\t}\n\n\tpublic function addByte(c) {\n\t\tif (pos == BUFSIZE)\n\t\t\tslide();\n\t\tbuffer.set(pos, c);\n\t\tpos++;\n\t}\n\n\tpublic function getLastChar() {\n\t\treturn buffer.get(pos - 1);\n\t}\n\n\tpublic function available() {\n\t\treturn pos;\n\t}\n\n\tpublic function checksum() {\n\t\tif (crc != null)\n\t\t\tcrc.update(buffer, 0, pos);\n\t\treturn crc;\n\t}\n}\n\nprivate enum State {\n\tHead;\n\tBlock;\n\tCData;\n\tFlat;\n\tCrc;\n\tDist;\n\tDistOne;\n\tDone;\n}\n\n/**\n\tA pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.\n**/\nclass InflateImpl {\n\tstatic var LEN_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1\n\t];\n\tstatic var LEN_BASE_VAL_TBL = [\n\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258\n\t];\n\tstatic var DIST_EXTRA_BITS_TBL = [\n\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1\n\t];\n\tstatic var DIST_BASE_VAL_TBL = [\n\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577\n\t];\n\tstatic var CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\tvar nbits:Int;\n\tvar bits:Int;\n\tvar state:State;\n\tvar isFinal:Bool;\n\tvar huffman:Huffman;\n\tvar huffdist:Null<Huffman>;\n\tvar htools:HuffTools;\n\tvar len:Int;\n\tvar dist:Int;\n\tvar needed:Int;\n\tvar output:haxe.io.Bytes;\n\tvar outpos:Int;\n\tvar input:haxe.io.Input;\n\tvar lengths:Array<Int>;\n\tvar window:Window;\n\n\tstatic var FIXED_HUFFMAN = null;\n\n\tpublic function new(i, ?header = true, ?crc = true) {\n\t\tisFinal = false;\n\t\thtools = new HuffTools();\n\t\thuffman = buildFixedHuffman();\n\t\thuffdist = null;\n\t\tlen = 0;\n\t\tdist = 0;\n\t\tstate = header ? Head : Block;\n\t\tinput = i;\n\t\tbits = 0;\n\t\tnbits = 0;\n\t\tneeded = 0;\n\t\toutput = null;\n\t\toutpos = 0;\n\t\tlengths = new Array();\n\t\tfor (i in 0...19)\n\t\t\tlengths.push(-1);\n\t\twindow = new Window(crc);\n\t}\n\n\tfunction buildFixedHuffman() {\n\t\tif (FIXED_HUFFMAN != null)\n\t\t\treturn FIXED_HUFFMAN;\n\t\tvar a = new Array();\n\t\tfor (n in 0...288)\n\t\t\ta.push(if (n <= 143) 8 else if (n <= 255) 9 else if (n <= 279) 7 else 8);\n\t\tFIXED_HUFFMAN = htools.make(a, 0, 288, 10);\n\t\treturn FIXED_HUFFMAN;\n\t}\n\n\tpublic function readBytes(b, pos, len) {\n\t\tneeded = len;\n\t\toutpos = pos;\n\t\toutput = b;\n\t\tif (len > 0)\n\t\t\twhile (inflateLoop()) {}\n\t\treturn len - needed;\n\t}\n\n\tfunction getBits(n) {\n\t\twhile (nbits < n) {\n\t\t\tbits |= input.readByte() << nbits;\n\t\t\tnbits += 8;\n\t\t}\n\t\tvar b = bits & ((1 << n) - 1);\n\t\tnbits -= n;\n\t\tbits >>= n;\n\t\treturn b;\n\t}\n\n\tfunction getBit() {\n\t\tif (nbits == 0) {\n\t\t\tnbits = 8;\n\t\t\tbits = input.readByte();\n\t\t}\n\t\tvar b = bits & 1 == 1;\n\t\tnbits--;\n\t\tbits >>= 1;\n\t\treturn b;\n\t}\n\n\tfunction getRevBits(n) {\n\t\treturn if (n == 0)\n\t\t\t0\n\t\telse if (getBit())\n\t\t\t(1 << (n - 1)) | getRevBits(n - 1)\n\t\telse\n\t\t\tgetRevBits(n - 1);\n\t}\n\n\tfunction resetBits() {\n\t\tbits = 0;\n\t\tnbits = 0;\n\t}\n\n\tfunction addBytes(b, p, len) {\n\t\twindow.addBytes(b, p, len);\n\t\toutput.blit(outpos, b, p, len);\n\t\tneeded -= len;\n\t\toutpos += len;\n\t}\n\n\tfunction addByte(b) {\n\t\twindow.addByte(b);\n\t\toutput.set(outpos, b);\n\t\tneeded--;\n\t\toutpos++;\n\t}\n\n\tfunction addDistOne(n) {\n\t\tvar c = window.getLastChar();\n\t\tfor (i in 0...n)\n\t\t\taddByte(c);\n\t}\n\n\tfunction addDist(d, len) {\n\t\taddBytes(window.buffer, window.pos - d, len);\n\t}\n\n\tfunction applyHuffman(h) {\n\t\treturn switch (h) {\n\t\t\tcase Found(n): n;\n\t\t\tcase NeedBit(a, b): applyHuffman(getBit() ? b : a);\n\t\t\tcase NeedBits(n, tbl): applyHuffman(tbl[getBits(n)]);\n\t\t}\n\t}\n\n\tfunction inflateLengths(a, max) {\n\t\tvar i = 0;\n\t\tvar prev = 0;\n\t\twhile (i < max) {\n\t\t\tvar n = applyHuffman(huffman);\n\t\t\tswitch (n) {\n\t\t\t\tcase 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15:\n\t\t\t\t\tprev = n;\n\t\t\t\t\ta[i] = n;\n\t\t\t\t\ti++;\n\t\t\t\tcase 16:\n\t\t\t\t\tvar end = i + 3 + getBits(2);\n\t\t\t\t\tif (end > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\twhile (i < end) {\n\t\t\t\t\t\ta[i] = prev;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\tcase 17:\n\t\t\t\t\ti += 3 + getBits(3);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tcase 18:\n\t\t\t\t\ti += 11 + getBits(7);\n\t\t\t\t\tif (i > max)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction inflateLoop() {\n\t\tswitch (state) {\n\t\t\tcase Head:\n\t\t\t\tvar cmf = input.readByte();\n\t\t\t\tvar cm = cmf & 15;\n\t\t\t\tvar cinfo = cmf >> 4;\n\t\t\t\tif (cm != 8)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tvar flg = input.readByte();\n\t\t\t\t// var fcheck = flg & 31;\n\t\t\t\tvar fdict = flg & 32 != 0;\n\t\t\t\t// var flevel = flg >> 6;\n\t\t\t\tif (((cmf << 8) + flg) % 31 != 0)\n\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\tif (fdict)\n\t\t\t\t\tthrow \"Unsupported dictionary\";\n\t\t\t\tstate = Block;\n\t\t\t\treturn true;\n\t\t\tcase Crc:\n\t\t\t\tvar calc = window.checksum();\n\t\t\t\tif (calc == null) {\n\t\t\t\t\tstate = Done;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar crc = Adler32.read(input);\n\t\t\t\tif (!calc.equals(crc))\n\t\t\t\t\tthrow \"Invalid CRC\";\n\t\t\t\tstate = Done;\n\t\t\t\treturn true;\n\t\t\tcase Done:\n\t\t\t\t// nothing\n\t\t\t\treturn false;\n\t\t\tcase Block:\n\t\t\t\tisFinal = getBit();\n\t\t\t\tswitch (getBits(2)) {\n\t\t\t\t\tcase 0: // no compression\n\t\t\t\t\t\tlen = input.readUInt16();\n\t\t\t\t\t\tvar nlen = input.readUInt16();\n\t\t\t\t\t\tif (nlen != 0xFFFF - len) throw \"Invalid data\";\n\t\t\t\t\t\tstate = Flat;\n\t\t\t\t\t\tvar r = inflateLoop();\n\t\t\t\t\t\tresetBits();\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tcase 1: // fixed Huffman\n\t\t\t\t\t\thuffman = buildFixedHuffman();\n\t\t\t\t\t\thuffdist = null;\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 2: // dynamic Huffman\n\t\t\t\t\t\tvar hlit = getBits(5) + 257;\n\t\t\t\t\t\tvar hdist = getBits(5) + 1;\n\t\t\t\t\t\tvar hclen = getBits(4) + 4;\n\t\t\t\t\t\tfor (i in 0...hclen)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = getBits(3);\n\t\t\t\t\t\tfor (i in hclen...19)\n\t\t\t\t\t\t\tlengths[CODE_LENGTHS_POS[i]] = 0;\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, 19, 8);\n\t\t\t\t\t\tvar lengths = new Array();\n\t\t\t\t\t\tfor (i in 0...hlit + hdist)\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\tinflateLengths(lengths, hlit + hdist);\n\t\t\t\t\t\thuffdist = htools.make(lengths, hlit, hdist, 16);\n\t\t\t\t\t\thuffman = htools.make(lengths, 0, hlit, 16);\n\t\t\t\t\t\tstate = CData;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t}\n\t\t\tcase Flat:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\tvar bytes = input.read(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\taddBytes(bytes, 0, rlen);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\treturn needed > 0;\n\t\t\tcase DistOne:\n\t\t\t\tvar rlen = (len < needed) ? len : needed;\n\t\t\t\taddDistOne(rlen);\n\t\t\t\tlen -= rlen;\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase Dist:\n\t\t\t\twhile (len > 0 && needed > 0) {\n\t\t\t\t\tvar rdist = (len < dist) ? len : dist;\n\t\t\t\t\tvar rlen = (needed < rdist) ? needed : rdist;\n\t\t\t\t\taddDist(dist, rlen);\n\t\t\t\t\tlen -= rlen;\n\t\t\t\t}\n\t\t\t\tif (len == 0)\n\t\t\t\t\tstate = CData;\n\t\t\t\treturn needed > 0;\n\t\t\tcase CData:\n\t\t\t\tvar n = applyHuffman(huffman);\n\t\t\t\tif (n < 256) {\n\t\t\t\t\taddByte(n);\n\t\t\t\t\treturn needed > 0;\n\t\t\t\t} else if (n == 256) {\n\t\t\t\t\tstate = isFinal ? Crc : Block;\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tn -= 257;\n\t\t\t\t\tvar extra_bits = LEN_EXTRA_BITS_TBL[n];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tlen = LEN_BASE_VAL_TBL[n] + getBits(extra_bits);\n\t\t\t\t\tvar dist_code = if (huffdist == null) getRevBits(5) else applyHuffman(huffdist);\n\t\t\t\t\textra_bits = DIST_EXTRA_BITS_TBL[dist_code];\n\t\t\t\t\tif (extra_bits == -1)\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tdist = DIST_BASE_VAL_TBL[dist_code] + getBits(extra_bits);\n\t\t\t\t\tif (dist > window.available())\n\t\t\t\t\t\tthrow \"Invalid data\";\n\t\t\t\t\tstate = (dist == 1) ? DistOne : Dist;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function run(i:haxe.io.Input, ?bufsize = 65536) {\n\t\tvar buf = haxe.io.Bytes.alloc(bufsize);\n\t\tvar output = new haxe.io.BytesBuffer();\n\t\tvar inflate = new InflateImpl(i);\n\t\twhile (true) {\n\t\t\tvar len = inflate.readBytes(buf, 0, bufsize);\n\t\t\toutput.addBytes(buf, 0, len);\n\t\t\tif (len < bufsize)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn output.getBytes();\n\t}\n}\n"]}