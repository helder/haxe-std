{"sourceRoot":"","names":[],"mappings":";AAiCA,iBAAa,KCRN,ACpBoB","version":3,"file":"Rest.d.ts.map","sources":["../../../../../../../haxe/versions/4.2.0/std/haxe/extern/Rest.hx","../../../../../../../haxe/versions/4.2.0/std/js/_std/Array.hx","../../../../../../../haxe/versions/4.2.0/std/haxe/Rest.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.extern;\n\n/**\n\tDEPRECATED: use haxe.Rest instead.\n\t\n\tA special type that represents \"rest\" function argument.\n\tShould be used as a type for the last argument of an extern method,\n\trepresenting that arbitrary number of arguments of given type can be\n\tpassed to that method.\n\t@see <https://haxe.org/manual/lf-externs.html>\n**/\ntypedef Rest<T> = haxe.Rest<T>\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.ArrayKeyValueIterator;\n\n@:coreApi\nextern class Array<T> {\n\tvar length(default, null):Int;\n\n\tfunction new():Void;\n\tfunction concat(a:Array<T>):Array<T>;\n\tfunction join(sep:String):String;\n\tfunction pop():Null<T>;\n\tfunction push(x:T):Int;\n\tfunction reverse():Void;\n\tfunction shift():Null<T>;\n\tfunction slice(pos:Int, ?end:Int):Array<T>;\n\tfunction sort(f:T->T->Int):Void;\n\tfunction splice(pos:Int, len:Int):Array<T>;\n\tfunction toString():String;\n\tfunction unshift(x:T):Void;\n\n\tinline function insert(pos:Int, x:T):Void {\n\t\t(cast this).splice(pos, 0, x);\n\t}\n\n\tinline function remove(x:T):Bool {\n\t\treturn @:privateAccess HxOverrides.remove(this, x);\n\t}\n\n\tinline function contains(x:T):Bool {\n\t\t#if (js_es >= 6)\n\t\treturn (cast this).includes(x);\n\t\t#else\n\t\treturn this.indexOf(x) != -1;\n\t\t#end\n\t}\n\n\t#if (js_es >= 5)\n\t@:pure function indexOf(x:T, ?fromIndex:Int):Int;\n\t@:pure function lastIndexOf(x:T, ?fromIndex:Int):Int;\n\t#else\n\tinline function indexOf(x:T, ?fromIndex:Int):Int {\n\t\treturn @:privateAccess HxOverrides.indexOf(this, x, (fromIndex != null) ? fromIndex : 0);\n\t}\n\n\tinline function lastIndexOf(x:T, ?fromIndex:Int):Int {\n\t\treturn @:privateAccess HxOverrides.lastIndexOf(this, x, (fromIndex != null) ? fromIndex : length - 1);\n\t}\n\t#end\n\n\t@:pure\n\tinline function copy():Array<T> {\n\t\treturn (cast this).slice();\n\t}\n\n\t@:runtime inline function map<S>(f:T->S):Array<S> {\n\t\tvar result:Array<S> = js.Syntax.construct(Array, length);\n\t\tfor(i in 0...length) {\n\t\t\tresult[i] = f(this[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@:runtime inline function filter(f:T->Bool):Array<T> {\n\t\treturn [for (v in this) if (f(v)) v];\n\t}\n\n\t@:runtime inline function iterator():haxe.iterators.ArrayIterator<T> {\n\t\treturn new haxe.iterators.ArrayIterator(this);\n\t}\n\n\t@:runtime inline function keyValueIterator():ArrayKeyValueIterator<T> {\n\t\treturn new ArrayKeyValueIterator(this);\n\t}\n\n\tinline function resize(len:Int):Void {\n\t\tthis.length = len;\n\t}\n}\n","package haxe;\n\nimport haxe.iterators.RestIterator;\nimport haxe.iterators.RestKeyValueIterator;\n\nprivate typedef NativeRest<T> = Array<T>;\n\n/**\n\tA special type that represents a \"rest\" function argument.\n\t\n\tThe special `...` syntax can be used for convenience and improved readability:\n\n\t```haxe\n\tfunction f(...rest:Int) {\n\t\t$type(rest); // haxe.Rest<Int>\n\t}\n\n\tf(1, 2, 3);\n\n\tfinal array = [1, 2, 3];\n\tf(...array);\n\t```\n\n\tShould be used as a type for the last argument of a method, indicating that\n\tan arbitrary number of arguments of the given type can be passed to that method.\n\n\tAllows to use array access by index to get values of rest arguments.\n\tIf the index exceeds the amount of rest arguments passed, the result is unspecified.\n**/\n@:coreApi\nabstract Rest<T>(NativeRest<T>) {\n\t/** Amount of arguments passed as rest arguments */\n\tpublic var length(get,never):Int;\n\tinline function get_length():Int\n\t\treturn this.length;\n\n\t/**\n\t\tCreate rest arguments using contents of `array`.\n\n\t\tWARNING:\n\t\tDepending on a target platform modifying `array` after using this method\n\t\tmay affect the created `Rest` instance.\n\t\tUse `Rest.of(array.copy())` to avoid that.\n\t**/\n\t@:from static public inline function of<T>(array:Array<T>):Rest<T>\n\t\treturn new Rest(array);\n\n\tinline function new(array:Array<T>):Void\n\t\tthis = array;\n\n\t@:arrayAccess inline function get(index:Int):T\n\t\treturn this[index];\n\n\t/**\n\t\tCreates an array containing all the values of rest arguments.\n\t**/\n\t@:to public #if !cppia inline #end function toArray():Array<T>\n\t\treturn this.copy();\n\n\tpublic inline function iterator():RestIterator<T>\n\t\treturn new RestIterator<T>(this);\n\n\tpublic inline function keyValueIterator():RestKeyValueIterator<T>\n\t\treturn new RestKeyValueIterator<T>(this);\n\n\t/**\n\t\tCreate a new rest arguments collection by appending `item` to this one.\n\t**/\n\tpublic function append(item:T):Rest<T> {\n\t\tvar result = this.copy();\n\t\tresult.push(item);\n\t\treturn new Rest(result);\n\t}\n\n\t/**\n\t\tCreate a new rest arguments collection by prepending this one with `item`.\n\t**/\n\tpublic function prepend(item:T):Rest<T> {\n\t\tvar result = this.copy();\n\t\tresult.unshift(item);\n\t\treturn new Rest(result);\n\t}\n\n\tpublic inline function toString():String {\n\t\t#if (flash || js)\n\t\t\treturn '[${this.toString()}]';\n\t\t#else\n\t\t\treturn this.toString();\n\t\t#end\n\t}\n}"]}