{"sourceRoot":"","names":[],"mappings":";AAkLa,4BC3EN;;AD4EM,6BC5EN;;AD6EM,8BCxGN","version":3,"file":"Node.d.ts.map","sources":["../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/Node.hx","../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/Timers.hx"],"sourcesContent":["/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js;\r\n\r\nimport haxe.Constraints.Function;\r\nimport haxe.extern.Rest;\r\nimport js.node.Module;\r\nimport js.node.Process;\r\nimport js.node.Timers.Immediate;\r\nimport js.node.Timers.Timeout;\r\nimport js.node.console.Console;\r\n#if haxe4\r\nimport js.Syntax.code;\r\n#end\r\n\r\n/**\r\n\tNode.js globals\r\n**/\r\n@:native(\"global\")\r\nextern class Node {\r\n\t/**\r\n\t\tThis variable may appear to be global but is not. See [__dirname](https://nodejs.org/api/modules.html#modules_dirname).\r\n\t**/\r\n\tstatic var __dirname(get, never):String;\r\n\r\n\tprivate static inline function get___dirname():String {\r\n\t\t#if haxe4\r\n\t\treturn code(\"__dirname\");\r\n\t\t#else\r\n\t\treturn untyped __js__(\"__dirname\");\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tThis variable may appear to be global but is not. See [__filename](https://nodejs.org/api/modules.html#modules_filename).\r\n\t**/\r\n\tstatic var __filename(get, never):String;\r\n\r\n\tprivate static inline function get___filename():String {\r\n\t\t#if haxe4\r\n\t\treturn code(\"__filename\");\r\n\t\t#else\r\n\t\treturn untyped __js__(\"__filename\");\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\t`clearImmediate` is described in the [timers](https://nodejs.org/api/timers.html) section.\r\n\t**/\r\n\tstatic function clearImmediate(immediate:Immediate):Void;\r\n\r\n\t/**\r\n\t\t`clearInterval` is described in the [timers](https://nodejs.org/api/timers.html) section.\r\n\t**/\r\n\tstatic function clearInterval(timeout:Timeout):Void;\r\n\r\n\t/**\r\n\t\t`clearTimeout` is described in the [timers](https://nodejs.org/api/timers.html) section.\r\n\t**/\r\n\tstatic function clearTimeout(timeout:Timeout):Void;\r\n\r\n\t/**\r\n\t\tUsed to print to stdout and stderr. See the [console](https://nodejs.org/api/console.html) section.\r\n\t**/\r\n\tstatic var console(get, never):Console;\r\n\r\n\tprivate static inline function get_console():Console {\r\n\t\t#if haxe4\r\n\t\treturn code(\"console\");\r\n\t\t#else\r\n\t\treturn untyped __js__(\"console\");\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tThis variable may appear to be global but is not. See [exports](https://nodejs.org/api/modules.html#modules_exports).\r\n\t**/\r\n\tstatic var exports(get, never):Dynamic<Dynamic>;\r\n\r\n\tprivate static inline function get_exports():Dynamic<Dynamic> {\r\n\t\t#if haxe4\r\n\t\treturn code(\"exports\");\r\n\t\t#else\r\n\t\treturn untyped __js__(\"exports\");\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tIn browsers, the top-level scope is the global scope.\r\n\t\tThis means that within the browser `var something` will define a new global variable.\r\n\t\tIn Node.js this is different. The top-level scope is not the global scope; `var something` inside a Node.js module\r\n\t\twill be local to that module.\r\n\t**/\r\n\tstatic inline var global:Dynamic<Dynamic> = cast Node;\r\n\r\n\t/**\r\n\t\tThis variable may appear to be global but is not. See [module](https://nodejs.org/api/modules.html#modules_module).\r\n\t**/\r\n\tstatic var module(get, never):Module;\r\n\r\n\tprivate static inline function get_module():Module {\r\n\t\t#if haxe4\r\n\t\treturn code(\"module\");\r\n\t\t#else\r\n\t\treturn untyped __js__(\"module\");\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tThe process object. See the [process object](https://nodejs.org/api/process.html#process_process) section.\r\n\t**/\r\n\tstatic var process(get, never):Process;\r\n\r\n\tprivate static inline function get_process():Process {\r\n\t\t#if haxe4\r\n\t\treturn code(\"process\");\r\n\t\t#else\r\n\t\treturn untyped __js__(\"process\");\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\tThe `queueMicrotask()` method queues a microtask to invoke `callback`.\r\n\t\tIf `callback` throws an exception, the [process object](https://nodejs.org/api/process.html#process_process) 'uncaughtException' event will be emitted.\r\n\r\n\t\tThe microtask queue is managed by V8 and may be used in a similar manner to the `Process.nextTick()` queue,\r\n\t\twhich is managed by Node.js.\r\n\t\tThe `Process.nextTick()` queue is always processed before the microtask queue within each turn of the Node.js event loop.\r\n\t**/\r\n\tstatic function queueMicrotask(callback:Void->Void):Void;\r\n\r\n\t/**\r\n\t\tThis variable may appear to be global but is not. See [require()](https://nodejs.org/api/modules.html#modules_require_id).\r\n\t**/\r\n\tstatic inline function require(module:String):Dynamic {\r\n\t\t#if haxe4\r\n\t\treturn code(\"require({0})\", module);\r\n\t\t#else\r\n\t\treturn untyped __js__(\"require({0})\", module);\r\n\t\t#end\r\n\t}\r\n\r\n\t/**\r\n\t\t`setImmediate` is described in the [timers](https://nodejs.org/api/timers.html) section.\r\n\t**/\r\n\tstatic function setImmediate(callback:Function, args:Rest<Dynamic>):Immediate;\r\n\r\n\t/**\r\n\t\t`setInterval` is described in the [timers](https://nodejs.org/api/timers.html) section.\r\n\t**/\r\n\tstatic function setInterval(callback:Function, delay:Int, args:Rest<Dynamic>):Timeout;\r\n\r\n\t/**\r\n\t\t`setTimeout` is described in the [timers](https://nodejs.org/api/timers.html) section.\r\n\t**/\r\n\tstatic function setTimeout(callback:Function, delay:Int, args:Rest<Dynamic>):Timeout;\r\n}\r\n\r\n@:deprecated typedef TimeoutObject = js.node.Timers.Timeout;\r\n@:deprecated typedef IntervalObject = js.node.Timers.Timeout;\r\n@:deprecated typedef ImmediateObject = js.node.Timers.Immediate;\r\n","package js.node;\r\n\r\nimport haxe.Constraints.Function;\r\nimport haxe.extern.Rest;\r\n\r\n/**\r\n\tThe `timer` module exposes a global API for scheduling functions to be called at some future period of time.\r\n\tBecause the timer functions are globals, there is no need to call `require('timers')` to use the API.\r\n\r\n\tThe timer functions within Node.js implement a similar API as the timers API provided by Web Browsers\r\n\tbut use a different internal implementation that is built around the Node.js Event Loop.\r\n**/\r\n@:jsRequire(\"timers\")\r\nextern class Timers {\r\n\t/**\r\n\t\tSchedules the \"immediate\" execution of the callback after I/O events' callbacks.\r\n\r\n\t\tWhen multiple calls to `setImmediate()` are made, the `callback` functions are queued for execution\r\n\t\tin the order in which they are created. The entire callback queue is processed every event loop iteration.\r\n\t\tIf an immediate timer is queued from inside an executing callback, that timer will not be triggered until\r\n\t\tthe next event loop iteration.\r\n\r\n\t\tIf `callback` is not a function, a `TypeError` will be thrown.\r\n\r\n\t\tThis method has a custom variant for promises that is available using `util.promisify()`.\r\n\t**/\r\n\tstatic function setImmediate(callback:Function, args:Rest<Dynamic>):Immediate;\r\n\r\n\t/**\r\n\t\tSchedules repeated execution of `callback` every `delay` milliseconds.\r\n\r\n\t\tWhen delay is larger than `2147483647` or less than `1`, the `delay` will be set to `1`.\r\n\t\tNon-integer delays are truncated to an integer.\r\n\r\n\t\tIf `callback` is not a function, a `TypeError` will be thrown.\r\n\r\n\t\tThis method has a custom variant for promises that is available using `util.promisify()`.\r\n\t**/\r\n\tstatic function setInterval(callback:Function, delay:Int, args:Rest<Dynamic>):Timeout;\r\n\r\n\t/**\r\n\t\tSchedules execution of a one-time `callback` after `delay` milliseconds.\r\n\r\n\t\tThe `callback` will likely not be invoked in precisely `delay` milliseconds.\r\n\t\tNode.js makes no guarantees about the exact timing of when callbacks will fire, nor of their ordering.\r\n\t\tThe callback will be called as close as possible to the time specified.\r\n\r\n\t\tWhen delay is larger than `2147483647` or less than `1`, the delay will be set to `1`.\r\n\t\tNon-integer delays are truncated to an integer.\r\n\r\n\t\tIf `callback` is not a function, a `TypeError` will be thrown.\r\n\r\n\t\tThis method has a custom variant for promises that is available using `util.promisify()`.\r\n\t**/\r\n\tstatic function setTimeout(callback:Function, delay:Int, args:Rest<Dynamic>):Timeout;\r\n\r\n\t/**\r\n\t\tCancels an Immediate object created by `setImmediate()`.\r\n\t**/\r\n\tstatic function clearImmediate(immediate:Immediate):Void;\r\n\r\n\t/**\r\n\t\tCancels a Timeout object created by `setInterval()`.\r\n\t**/\r\n\tstatic function clearInterval(timeout:Timeout):Void;\r\n\r\n\t/**\r\n\t\tCancels a Timeout object created by `setTimeout()`.\r\n\t**/\r\n\tstatic function clearTimeout(timeout:Timeout):Void;\r\n}\r\n\r\n/**\r\n\tThis object is created internally and is returned from `setImmediate()`.\r\n\tIt can be passed to `clearImmediate()` in order to cancel the scheduled actions.\r\n**/\r\nextern class Immediate {\r\n\t/**\r\n\t\tIf true, the `Immediate` object will keep the Node.js event loop active.\r\n\t**/\r\n\tfunction hasRef():Bool;\r\n\r\n\t/**\r\n\t\tWhen called, requests that the Node.js event loop not exit so long as the `Immediate` is active.\r\n\t\tCalling `immediate.ref()` multiple times will have no effect.\r\n\r\n\t\tBy default, all `Immediate` objects are \"ref'ed\", making it normally unnecessary to call `immediate.ref()`\r\n\t\tunless `immediate.unref()` had been called previously.\r\n\t**/\r\n\tfunction ref():Immediate;\r\n\r\n\t/**\r\n\t\tWhen called, the active `Immediate` object will not require the Node.js event loop to remain active.\r\n\t\tIf there is no other activity keeping the event loop running, the process may exit before the `Immediate` object's\r\n\t\tcallback is invoked. Calling immediate.unref() multiple times will have no effect.\r\n\t**/\r\n\tfunction unref():Immediate;\r\n}\r\n\r\n/**\r\n\tThis object is created internally and is returned from `setTimeout()` and `setInterval()`.\r\n\tIt can be passed to either `clearTimeout()` or `clearInterval()` in order to cancel the scheduled actions.\r\n**/\r\nextern class Timeout {\r\n\t/**\r\n\t\tIf true, the `Timeout` object will keep the Node.js event loop active.\r\n\t**/\r\n\tfunction hasRef():Bool;\r\n\r\n\t/**\r\n\t\tWhen called, the active `Timeout` object will not require the Node.js event loop to remain active.\r\n\t\tIf there is no other activity keeping the event loop running, the process may exit before the `Timeout` object's\r\n\t\tcallback is invoked. Calling `timeout.unref()` multiple times will have no effect.\r\n\r\n\t\tCalling `timeout.unref()` creates an internal timer that will wake the Node.js event loop.\r\n\t\tCreating too many of these can adversely impact performance of the Node.js application.\r\n\t**/\r\n\tfunction ref():Timeout;\r\n\r\n\t/**\r\n\t\tSets the timer's start time to the current time, and reschedules the timer to call its callback at the previously\r\n\t\tspecified duration adjusted to the current time. This is useful for refreshing a timer without allocating\r\n\t\ta new JavaScript object.\r\n\r\n\t\tUsing this on a timer that has already called its callback will reactivate the timer.\r\n\t**/\r\n\tfunction refresh():Timeout;\r\n\r\n\t/**\r\n\t\tWhen called, the active `Timeout` object will not require the Node.js event loop to remain active.\r\n\t\tIf there is no other activity keeping the event loop running, the process may exit before the `Timeout` object's\r\n\t\tcallback is invoked. Calling `timeout.unref()` multiple times will have no effect.\r\n\r\n\t\tCalling `timeout.unref()` creates an internal timer that will wake the Node.js event loop.\r\n\t\tCreating too many of these can adversely impact performance of the Node.js application.\r\n\t**/\r\n\tfunction unref():Timeout;\r\n}\r\n"]}