{"sourceRoot":"","names":[],"mappings":"QAwYA;;YCxUA,uBC+PY,gBC7OZ,OAWoC,SCyPxB,cDpQZ,OAWoC,SHuLxB,gBGlMZ,OAWoC,SH6LxB,kBGxMZ,OE7DiB,QDwTL,UD3PZ,qBGzDO,yBHyDP,OGzDO,UHMI,iBC+RC,YD5OZ,OAWoC,SCoNxB,WD/NZ,OE7DiB,QLqTL,SGxPZ,uBGzDO,UHMI,OFgDC,QEGZ,sBGzDO,UHMI,OC4QC,gBDzNZ,OAtBoC,QC4PxB,aDtOZ,OAWoC,SCuOxB,ODlPZ,eAtBoC,WA7BzB,OD+SC,wBC5PZ,OAtBoC,QDwQxB,qBClPZ,OAWoC,SFtBxB,YEWZ,+BE7DiB,2BF6DjB,OGzDO,qBHMI,iBDoTC,wBCjQZ,OAtBoC,QD6QxB,qBCvPZ,OAWoC,SHgNxB,QG3NZ,+BE7DiB,0BF6DjB,OGzDO,UHMI,iBHuRC,SGpOZ,iBIzDO,AP+WP,2BGtTA,OGzDO,UHMI","version":3,"file":"Transform.d.ts.map","sources":["../../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/stream/Writable.hx","../../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/stream/Transform.hx","../../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/stream/Duplex.hx","../../../../../../../../haxe/versions/4.1.0/std/StdTypes.hx","../../../../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/stream/Readable.hx","../../../../../../../../haxe/versions/4.1.0/std/js/_std/String.hx","../../../../../../../../haxe/versions/4.1.0/std/js/lib/Error.hx","../../../../../../../../haxe/versions/4.1.0/std/js/_std/Array.hx"],"sourcesContent":["/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.stream;\r\n\r\nimport haxe.extern.EitherType;\r\nimport js.node.Stream;\r\nimport js.node.events.EventEmitter.Event;\r\nimport js.node.stream.Readable.IReadable;\r\n#if haxe4\r\nimport js.lib.Error;\r\nimport js.lib.Object;\r\nimport js.lib.Uint8Array;\r\n#else\r\nimport js.Error;\r\nimport js.html.Uint8Array;\r\n#end\r\n\r\n/**\r\n\tWritable streams are an abstraction for a destination to which data is written.\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_writable_streams\r\n**/\r\n@:enum abstract WritableEvent<T:haxe.Constraints.Function>(Event<T>) to Event<T> {\r\n\t/**\r\n\t\tThe `'close'` event is emitted when the stream and any of its underlying resources\r\n\t\t(a file descriptor, for example) have been closed.\r\n\t\tThe event indicates that no more events will be emitted, and no further computation will occur.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_close\r\n\t**/\r\n\tvar Close:WritableEvent<Void->Void> = \"close\";\r\n\r\n\t/**\r\n\t\tIf a call to stream.write(chunk) returns `false`, the `'drain'` event will be emitted\r\n\t\twhen it is appropriate to resume writing data to the stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_drain\r\n\t**/\r\n\tvar Drain:WritableEvent<Void->Void> = \"drain\";\r\n\r\n\t/**\r\n\t\tThe `'error'` event is emitted if an `error` occurred while writing or piping data.\r\n\t\tThe listener callback is passed a single Error argument when called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_error\r\n\t**/\r\n\tvar Error:WritableEvent<Error->Void> = \"error\";\r\n\r\n\t/**\r\n\t\tThe `'finish'` event is emitted after the stream.end() method has been called,\r\n\t\tand all data has been flushed to the underlying system.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_finish\r\n\t**/\r\n\tvar Finish:WritableEvent<Void->Void> = \"finish\";\r\n\r\n\t/**\r\n\t\tThe `'pipe'` event is emitted when the stream.pipe() method is called on a readable stream,\r\n\t\tadding this writable to its set of destinations.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_pipe\r\n\t**/\r\n\tvar Pipe:WritableEvent<IReadable->Void> = \"pipe\";\r\n\r\n\t/**\r\n\t\tThe `'unpipe'` event is emitted when the stream.unpipe() method is called on a Readable stream,\r\n\t\tremoving this Writable from its set of destinations.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_unpipe\r\n\t**/\r\n\tvar Unpipe:WritableEvent<IReadable->Void> = \"unpipe\";\r\n}\r\n\r\n/**\r\n\tThe Writable stream interface is an abstraction for a destination that you are writing data to.\r\n\r\n\tExamples of writable streams include:\r\n\r\n\t\t- http requests, on the client\r\n\t\t- http responses, on the server\r\n\t\t- fs write streams\r\n\t\t- zlib streams\r\n\t\t- crypto streams\r\n\t\t- tcp sockets\r\n\t\t- child process stdin\r\n\t\t- process.stdout, process.stderr\r\n**/\r\n@:jsRequire(\"stream\", \"Writable\")\r\nextern class Writable<TSelf:Writable<TSelf>> extends Stream<TSelf> implements IWritable {\r\n\t/**\r\n\t\tThe `writable.cork()` method forces all written data to be buffered in memory.\r\n\t\tThe buffered data will be flushed when either the `stream.uncork()` or `stream.end()` methods are called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_cork\r\n\t**/\r\n\tfunction cork():Void;\r\n\r\n\t/**\r\n\t\tDestroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event unless `emitClose` is set in `false`.\r\n\t\tAfter this call, the writable stream has ended and subsequent calls to `write()` or `end()` will result in an `ERR_STREAM_DESTROYED` error.\r\n\t\tThis is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\r\n\t\tUse `end()` instead of destroy if data should flush before close, or wait for the `'drain'` event before destroying the stream.\r\n\t\tImplementors should not override this method, but instead implement `writable._destroy()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroy_error\r\n\t**/\r\n\tfunction destroy(?error:Error):TSelf;\r\n\r\n\t/**\r\n\t\tIs `true` after `writable.destroy()` has been called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroyed\r\n\t**/\r\n\tvar destroyed(default, null):Bool;\r\n\r\n\t/**\r\n\t\tCalling the `writable.end()` method signals that no more data will be written to the Writable.\r\n\t\tThe optional `chunk` and `encoding` arguments allow one final additional chunk of data to be written immediately before closing the stream.\r\n\t\tIf provided, the optional `callback` function is attached as a listener for the 'finish' event.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback\r\n\t**/\r\n\t@:overload(function(?callback:EitherType<Void->Void, Null<Error>->Void>):Void {})\r\n\tfunction end(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Void;\r\n\r\n\t/**\r\n\t\tThe `writable.setDefaultEncoding()` method sets the default `encoding` for a Writable stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding\r\n\t**/\r\n\tfunction setDefaultEncoding(encoding:String):TSelf;\r\n\r\n\t/**\r\n\t\tThe `writable.uncork()` method flushes all data buffered since `stream.cork()` was called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_uncork\r\n\t**/\r\n\tfunction uncork():Void;\r\n\r\n\t/**\r\n\t\tIs `true` if it is safe to call `writable.write()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writable\r\n\t**/\r\n\tvar writable(default, null):Bool;\r\n\r\n\t/**\r\n\t\tIs `true` after `writable.end()` has been called. This property\r\n\t\tdoes not indicate whether the data has been flushed, for this use\r\n\t\t`writable.writableFinished` instead.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writableended\r\n\t**/\r\n\tvar writableEnded(default, null):Bool;\r\n\r\n\t/**\r\n\t\tIs set to `true` immediately before the 'finish' event is emitted.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablefinished\r\n\t**/\r\n\tvar writableFinished(default, null):Bool;\r\n\r\n\t/**\r\n\t\tReturn the value of `highWaterMark` passed when constructing this `Writable`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablehighwatermark\r\n\t**/\r\n\tvar writablehighWaterMark(default, null):Int;\r\n\r\n\t/**\r\n\t\tThis property contains the number of bytes (or objects) in the queue ready to be written.\r\n\t\tThe value provides introspection data regarding the status of the `highWaterMark`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablelength\r\n\t**/\r\n\tvar writableLength(default, null):Int;\r\n\r\n\t/**\r\n\t\tGetter for the property `objectMode` of a given `Writable` stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writableobjectmode\r\n\t**/\r\n\tvar writableObjectMode(default, null):Bool;\r\n\r\n\t/**\r\n\t\tThe `writable.write()` method writes some data to the stream, and calls the supplied `callback` once the data has been fully handled.\r\n\t\tIf an error occurs, the `callback` may or may not be called with the error as its first argument.\r\n\t\tTo reliably detect write errors, add a listener for the `'error'` event.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\r\n\t**/\r\n\tfunction write(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Bool;\r\n\r\n\t// --------- API for implementing a Writable Stream -----------------------\r\n\r\n\t/**\r\n\t\t@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options\r\n\t**/\r\n\tfunction new(?options:WritableNewOptionsAdapter);\r\n\r\n\t/**\r\n\t\tAll `Writable` stream implementations must provide a `writable._write()` method to send data to the underlying resource.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1\r\n\t**/\r\n\tprivate function _write(chunk:Dynamic, encoding:String, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThis function **MUST NOT** be called by application code directly.\r\n\t\tIt should be implemented by child classes, and called by the internal `Writable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writev_chunks_callback\r\n\t**/\r\n\tprivate function _writev(chunks:Array<Chunk>, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThe `_destroy()` method is called by `writable.destroy()`.\r\n\t\tIt can be overridden by child classes but it **must not** be called directly.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroy_err_callback\r\n\t**/\r\n\tprivate function _destroy(err:Null<Error>, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThe `_final()` method **must not** be called directly.\r\n\t\tt may be implemented by child classes, and if so, will be called by the internal `Writable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_final_callback\r\n\t**/\r\n\tprivate function _final(callback:Null<Error>->Void):Void;\r\n\r\n\t// --------- TTY module API  ----------------------------------------------\r\n\r\n\t/**\r\n\t\tTerminal write streams (i.e. process.stdout) have this property set to true.\r\n\t\tIt is false for any other write streams.\r\n\r\n\t\t@see https://nodejs.org/api/tty.html#tty_writestream_istty\r\n\t**/\r\n\tvar isTTY(default, null):Bool;\r\n}\r\n\r\n/**\r\n\t@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options\r\n**/\r\ntypedef WritableNewOptions = {\r\n\t/**\r\n\t\t`highWaterMark` <number> Buffer level when stream.write() starts returning `false`. Default: `16384` (16kb), or 16 for `objectMode` streams.\r\n\t**/\r\n\t@:optional var highWaterMark:Int;\r\n\r\n\t/**\r\n\t\t`decodeStrings` <boolean> Whether to encode `string`s passed to stream.write() to `Buffer`s (with the encoding specified in the stream.write() call) before passing them to stream._write().\r\n\t\tOther types of data are not converted (i.e. `Buffer`s are not decoded into `string`s). Setting to false will prevent strings from being converted.\r\n\t\tDefault: `true`.\r\n\t**/\r\n\t@:optional var decodeStrings:Bool;\r\n\r\n\t/**\r\n\t\t`defaultEncoding` <string> The default encoding that is used when no encoding is specified as an argument to stream.write().\r\n\t\tDefault: `'utf8'`.\r\n\t**/\r\n\t@:optional var defaultEncoding:String;\r\n\r\n\t/**\r\n\t\t`objectMode` <boolean> Whether or not the stream.write(anyObj) is a valid operation. When set,\r\n\t\tit becomes possible to write JavaScript values other than string, `Buffer` or `Uint8Array` if supported by the stream implementation.\r\n\t\tDefault: `false`.\r\n\t**/\r\n\t@:optional var objectMode:Bool;\r\n\r\n\t/**\r\n\t\t`emitClose` <boolean> Whether or not the stream should emit `'close'` after it has been destroyed.\r\n\t\tDefault: `true`.\r\n\t**/\r\n\t@:optional var emitClose:Bool;\r\n\r\n\t/**\r\n\t\t`write` <Function> Implementation for the stream._write() method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var write:(chunk:Dynamic, encoding:String, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var write:Dynamic->String->Null<Error>->Void->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`writev` <Function> Implementation for the stream._writev() method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var writev:(chunks:Array<Chunk>, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var writev:Array<Chunk>->(Null<Error>->Void)->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`destroy` <Function> Implementation for the stream._destroy() method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var destroy:(error:Null<Error>, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var destroy:Null<Error>->(Null<Error>->Void)->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`final` <Function> Implementation for the stream._final() method.\r\n\t**/\r\n\t// TODO @native in typedef cannot work now\r\n\t// @:native(\"final\")\r\n\t#if haxe4\r\n\t@:optional var final_:(error:Null<Error>) -> Void;\r\n\t#else\r\n\t@:optional var final_:Null<Error>->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\t`autoDestroy` <boolean> Whether this stream should automatically call .destroy() on itself after ending. Default: false.\r\n\t**/\r\n\t@:optional var autoDestroy:Bool;\r\n}\r\n\r\n@:forward\r\nabstract WritableNewOptionsAdapter(WritableNewOptions) {\r\n\t@:from\r\n\tpublic static function from(options:WritableNewOptions):WritableNewOptionsAdapter {\r\n\t\tif (!Reflect.hasField(options, \"final\")) {\r\n\t\t\t#if haxe4\r\n\t\t\tObject.defineProperty(options, \"final\", {get: function() return options.final_});\r\n\t\t\t#else\r\n\t\t\tuntyped __js__(\"Object.defineProperty({0}, {1}, {2})\", options, \"final\", {get: function() return options.final_});\r\n\t\t\t#end\r\n\t\t}\r\n\t\treturn cast options;\r\n\t}\r\n}\r\n\r\n/**\r\n\tWritable interface used for type parameter constraints.\r\n\tSee `Writable` for actual class documentation.\r\n**/\r\n@:remove\r\nextern interface IWritable extends IStream {\r\n\tfunction cork():Void;\r\n\r\n\tfunction destroy(?error:Error):IWritable;\r\n\r\n\tvar destroyed(default, null):Bool;\r\n\r\n\t@:overload(function(?callback:EitherType<Void->Void, Null<Error>->Void>):Void {})\r\n\tfunction end(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Void;\r\n\r\n\tfunction setDefaultEncoding(encoding:String):IWritable;\r\n\r\n\tfunction uncork():Void;\r\n\r\n\tvar writable(default, null):Bool;\r\n\r\n\tvar writableEnded(default, null):Bool;\r\n\r\n\tvar writableFinished(default, null):Bool;\r\n\r\n\tvar writablehighWaterMark(default, null):Int;\r\n\r\n\tvar writableLength(default, null):Int;\r\n\r\n\tvar writableObjectMode(default, null):Bool;\r\n\r\n\tfunction write(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Bool;\r\n\r\n\tvar isTTY(default, null):Bool;\r\n}\r\n\r\ntypedef Chunk = {\r\n\tvar chunk:Dynamic;\r\n\tvar encoding:String;\r\n}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.stream;\r\n\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n/**\r\n\tA `Transform` stream is a `Duplex` stream where the output is computed in some way from the input.\r\n\tExamples include `zlib` streams or `crypto` streams that compress, encrypt, or decrypt data.\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_implementing_a_transform_stream\r\n**/\r\n@:jsRequire(\"stream\", \"Transform\")\r\nextern class Transform<TSelf:Transform<TSelf>> extends Duplex<TSelf> implements ITransform {\r\n\tfunction new(?options:TransformNewOptions);\r\n\r\n\t/**\r\n\t\tThis function **MUST NOT** be called by application code directly.\r\n\t\tIt should be implemented by child classes, and called by the internal `Readable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_transform_flush_callback\r\n\t**/\r\n\tprivate function _flush(callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThis function **MUST NOT** be called by application code directly.\r\n\t\tIt should be implemented by child classes, and called by the internal `Readable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_transform_transform_chunk_encoding_callback\r\n\t**/\r\n\t#if haxe4\r\n\tprivate function _transform(chunk:Dynamic, encoding:String, callback:(error:Null<Error>, data:Dynamic) -> Void):Void;\r\n\t#else\r\n\tprivate function _transform(chunk:Dynamic, encoding:String, callback:Null<Error>->Dynamic->Void):Void;\r\n\t#end\r\n}\r\n\r\n/**\r\n\t@see https://nodejs.org/api/stream.html#stream_new_stream_transform_options\r\n**/\r\ntypedef TransformNewOptions = {\r\n\t> Duplex.DuplexNewOptions,\r\n\r\n\t/**\r\n\t\tImplementation for the `stream._transform()` method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var transform:(chunk:Dynamic, encoding:String, callback:(error:Null<Error>, data:Dynamic) -> Void) -> Void;\r\n\t#else\r\n\t@:optional var transform:Dynamic->String->(Null<Error>->Dynamic->Void)->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\tImplementation for the `stream._flush()` method.\r\n\t**/\r\n\t@:optional var flush:Null<Error>->Void;\r\n}\r\n\r\n@:remove\r\nextern interface ITransform extends Duplex.IDuplex {}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.stream;\r\n\r\nimport haxe.extern.EitherType;\r\nimport js.node.events.EventEmitter.Event;\r\nimport js.node.stream.Readable.IReadable;\r\nimport js.node.stream.Writable.IWritable;\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n/**\r\n\tWritable streams are an abstraction for a destination to which data is written.\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_writable_streams\r\n**/\r\n@:enum abstract DuplexEvent<T:haxe.Constraints.Function>(Event<T>) to Event<T> {\r\n\t// Writable stream events -------------------------------------------------\r\n\t// var Close:DuplexEvent<Void->Void> = \"close\";\r\n\r\n\t/**\r\n\t\tIf a call to stream.write(chunk) returns `false`, the `'drain'` event will be emitted\r\n\t\twhen it is appropriate to resume writing data to the stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_drain\r\n\t**/\r\n\tvar Drain:DuplexEvent<Void->Void> = \"drain\";\r\n\r\n\t// var Error:DuplexEvent<Error->Void> = \"error\";\r\n\r\n\t/**\r\n\t\tThe `'finish'` event is emitted after the stream.end() method has been called,\r\n\t\tand all data has been flushed to the underlying system.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_finish\r\n\t**/\r\n\tvar Finish:DuplexEvent<Void->Void> = \"finish\";\r\n\r\n\t/**\r\n\t\tThe `'pipe'` event is emitted when the stream.pipe() method is called on a readable stream,\r\n\t\tadding this writable to its set of destinations.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_pipe\r\n\t**/\r\n\tvar Pipe:DuplexEvent<IReadable->Void> = \"pipe\";\r\n\r\n\t/**\r\n\t\tThe `'unpipe'` event is emitted when the stream.unpipe() method is called on a Readable stream,\r\n\t\tremoving this Writable from its set of destinations.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_unpipe\r\n\t**/\r\n\tvar Unpipe:DuplexEvent<IReadable->Void> = \"unpipe\";\r\n\r\n\t// Readable stream events -------------------------------------------------\r\n\t// var Close:DuplexEvent<Void->Void> = \"close\";\r\n\r\n\t/**\r\n\t\tThe `'data'` event is emitted whenever the stream is relinquishing ownership of\r\n\t\ta chunk of data to a consumer. This may occur whenever the stream is switched\r\n\t\tin flowing mode by calling `readable.pipe()`, `readable.resume()`, or by\r\n\t\tattaching a listener callback to the `'data'` event. The `'data'` event will\r\n\t\talso be emitted whenever the `readable.read()` method is called and a chunk of\r\n\t\tdata is available to be returned.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_data\r\n\t**/\r\n\tvar Data:DuplexEvent<Dynamic->Void> = \"data\";\r\n\r\n\t/**\r\n\t\tThe `'end'` event is emitted when there is no more data to be consumed from\r\n\t\tthe stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_end\r\n\t**/\r\n\tvar End:DuplexEvent<Void->Void> = \"end\";\r\n\r\n\t// var Error:DuplexEvent<Error->Void> = \"error\";\r\n\r\n\t/**\r\n\t\tThe `'pause'` event is emitted when `stream.pause()` is called\r\n\t\tand `readableFlowing` is not `false`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_pause\r\n\t**/\r\n\tvar Pause:DuplexEvent<Void->Void> = \"pause\";\r\n\r\n\t/**\r\n\t\tThe `'readable'` event is emitted when there is data available to be read from\r\n\t\tthe stream. In some cases, attaching a listener for the `'readable'` event will\r\n\t\tcause some amount of data to be read into an internal buffer.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_readable\r\n\t**/\r\n\tvar Readable:DuplexEvent<Void->Void> = \"readable\";\r\n\r\n\t/**\r\n\t\tThe `'resume'` event is emitted when `stream.resume()` is\r\n\t\tcalled and `readableFlowing` is not `true`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_resume\r\n\t**/\r\n\tvar Resume:DuplexEvent<Void->Void> = \"resume\";\r\n\r\n\t// Overlapped events ------------------------------------------------------\r\n\r\n\t/**\r\n\t\tThe `'close'` event is emitted when the stream and any of its underlying\r\n\t\tresources (a file descriptor, for example) have been closed.\r\n\t\tThe event indicates that no more events will be emitted, and no further computation will occur.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_close\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_close_1\r\n\t**/\r\n\tvar Close:DuplexEvent<Void->Void> = \"close\";\r\n\r\n\t/**\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_error\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_error_1\r\n\t**/\r\n\tvar Error:DuplexEvent<Error->Void> = \"error\";\r\n}\r\n\r\n/**\r\n\tDuplex streams are streams that implement both the `Readable` and `Writable` interfaces.\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_class_stream_duplex\r\n**/\r\n@:jsRequire(\"stream\", \"Duplex\")\r\nextern class Duplex<TSelf:Duplex<TSelf>> extends Readable<TSelf> implements IDuplex {\r\n\t// --------- Writable interface implementation ----------------------------\r\n\r\n\t/**\r\n\t\tThe `writable.cork()` method forces all written data to be buffered in memory.\r\n\t\tThe buffered data will be flushed when either the `stream.uncork()` or `stream.end()` methods are called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_cork\r\n\t**/\r\n\tfunction cork():Void;\r\n\r\n\t// This field is defined in super class.\r\n\t// function destroy(?error:Error):TSelf;\r\n\t// var destroyed(default, null):Bool;\r\n\r\n\t/**\r\n\t\tCalling the `writable.end()` method signals that no more data will be written to the Writable.\r\n\t\tThe optional `chunk` and `encoding` arguments allow one final additional chunk of data to be written immediately before closing the stream.\r\n\t\tIf provided, the optional `callback` function is attached as a listener for the 'finish' event.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback\r\n\t**/\r\n\t@:overload(function(?callback:EitherType<Void->Void, Null<Error>->Void>):Void {})\r\n\tfunction end(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Void;\r\n\r\n\t/**\r\n\t\tThe `writable.setDefaultEncoding()` method sets the default `encoding` for a Writable stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding\r\n\t**/\r\n\tfunction setDefaultEncoding(encoding:String):TSelf;\r\n\r\n\t/**\r\n\t\tThe `writable.uncork()` method flushes all data buffered since `stream.cork()` was called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_uncork\r\n\t**/\r\n\tfunction uncork():Void;\r\n\r\n\t/**\r\n\t\tIs `true` if it is safe to call `writable.write()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writable\r\n\t**/\r\n\tvar writable(default, null):Bool;\r\n\r\n\t/**\r\n\t\tIs `true` after `writable.end()` has been called. This property\r\n\t\tdoes not indicate whether the data has been flushed, for this use\r\n\t\t`writable.writableFinished` instead.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writableended\r\n\t**/\r\n\tvar writableEnded(default, null):Bool;\r\n\r\n\t/**\r\n\t\tIs set to `true` immediately before the 'finish' event is emitted.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablefinished\r\n\t**/\r\n\tvar writableFinished(default, null):Bool;\r\n\r\n\t/**\r\n\t\tReturn the value of `highWaterMark` passed when constructing this `Writable`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablehighwatermark\r\n\t**/\r\n\tvar writablehighWaterMark(default, null):Int;\r\n\r\n\t/**\r\n\t\tThis property contains the number of bytes (or objects) in the queue ready to be written.\r\n\t\tThe value provides introspection data regarding the status of the `highWaterMark`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writablelength\r\n\t**/\r\n\tvar writableLength(default, null):Int;\r\n\r\n\t/**\r\n\t\tGetter for the property `objectMode` of a given `Writable` stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writableobjectmode\r\n\t**/\r\n\tvar writableObjectMode(default, null):Bool;\r\n\r\n\t/**\r\n\t\tThe `writable.write()` method writes some data to the stream, and calls the supplied `callback` once the data has been fully handled.\r\n\t\tIf an error occurs, the `callback` may or may not be called with the error as its first argument.\r\n\t\tTo reliably detect write errors, add a listener for the `'error'` event.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\r\n\t**/\r\n\tfunction write(chunk:Dynamic, ?encoding:String, ?callback:EitherType<Void->Void, Null<Error>->Void>):Bool;\r\n\r\n\t// --------- API for implementing a Writable Stream -----------------------\r\n\t// function new(?options:DuplexNewOptions);\r\n\r\n\t/**\r\n\t\tAll `Writable` stream implementations must provide a `writable._write()` method to send data to the underlying resource.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1\r\n\t**/\r\n\tprivate function _write(chunk:Dynamic, encoding:String, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThis function MUST NOT be called by application code directly.\r\n\t\tIt should be implemented by child classes, and called by the internal `Writable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_writev_chunks_callback\r\n\t**/\r\n\tprivate function _writev(chunks:Array<Writable.Chunk>, callback:Null<Error>->Void):Void;\r\n\r\n\t// This field is defined in super class.\r\n\t// private function _destroy(err:Null<Error>, ?callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThe `_final()` method must not be called directly.\r\n\t\tt may be implemented by child classes, and if so, will be called by the internal `Writable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_final_callback\r\n\t**/\r\n\tprivate function _final(callback:Null<Error>->Void):Void;\r\n\r\n\t// --------- Overlapped interface -----------------------------------------\r\n\r\n\t/**\r\n\t\tDestroy the stream.\r\n\t\tOptionally emit an `'error'` event, and emit a `'close'` event unless `emitClose` is set in `false`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroy_error\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_destroy_error\r\n\t**/\r\n\toverride function destroy(?error:Error):TSelf;\r\n\r\n\t// This field is defined in super class.\r\n\t// var destroyed(default, null):Bool;\r\n\r\n\t/**\r\n\t\t@see https://nodejs.org/api/stream.html#stream_constructor_new_stream_writable_options\r\n\t\t@see https://nodejs.org/api/stream.html#stream_new_stream_readable_options\r\n\t**/\r\n\tfunction new(?options:DuplexNewOptions);\r\n\r\n\t/**\r\n\t\tThe `_destroy()` method is called by `destroy()`.\r\n\t\tIt can be overridden by child classes but it **must not** be called directly.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_writable_destroy_err_callback\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_destroy_err_callback\r\n\t**/\r\n\tprivate override function _destroy(err:Null<Error>, callback:Null<Error>->Void):Void;\r\n\r\n\t// This field is defined in super class.\r\n\t// var isTTY(default, null):Bool;\r\n}\r\n\r\n/**\r\n\tPassed to both `Writable` and `Readable` constructors. Also has the following fields:\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_new_stream_duplex_options\r\n**/\r\ntypedef DuplexNewOptions = {\r\n\t> Readable.ReadableNewOptions,\r\n\t> Writable.WritableNewOptions,\r\n\r\n\t/**\r\n\t\tIf set to `false`, then the stream will automatically end the writable side when the readable side ends. Default: `true`.\r\n\t**/\r\n\t@:optional var allowHalfOpen:Bool;\r\n\r\n\t/**\r\n\t\tSets `objectMode` for readable side of the stream. Has no effect if `objectMode` is `true`. Default: `false`.\r\n\t**/\r\n\t@:optional var readableObjectMode:Bool;\r\n\r\n\t/**\r\n\t\tSets `objectMode` for writable side of the stream. Has no effect if `objectMode` is `true`. Default: `false`.\r\n\t**/\r\n\t@:optional var writableObjectMode:Bool;\r\n\r\n\t/**\r\n\t\tSets `highWaterMark` for the readable side of the stream. Has no effect if `highWaterMark` is provided.\r\n\t**/\r\n\t@:optional var readableHighWaterMark:Int;\r\n\r\n\t/**\r\n\t\tSets `highWaterMark` for the writable side of the stream. Has no effect if `highWaterMark` is provided.\r\n\t**/\r\n\t@:optional var writableHighWaterMark:Int;\r\n}\r\n\r\n@:remove\r\nextern interface IDuplex extends IReadable extends IWritable {}\r\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n// standard Haxe types\n\n/**\n\tThe standard `Void` type. Only `null` values can be of the type `Void`.\n\n\t@see https://haxe.org/manual/types-void.html\n**/\n#if jvm\n@:runtimeValue\n#end\n@:coreType abstract Void {}\n\n/**\n\tThe standard `Float` type, this is a double-precision IEEE 64bit float.\n\n\tOn static targets, `null` cannot be assigned to Float. If this is necessary,\n\t`Null<Float>` can be used instead.\n\n\t`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n\t`Std.parseFloat` converts a `String` to a `Float`.\n\n\t@see https://haxe.org/manual/types-basic-types.html\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:coreType @:notNull @:runtimeValue abstract Float {}\n\n/**\n\tThe standard `Int` type. Its precision depends on the platform.\n\n\tOn static targets, `null` cannot be assigned to `Int`. If this is necessary,\n\t`Null<Int>` can be used instead.\n\n\t`Std.int` converts a `Float` to an `Int`, rounded towards 0.\n\t`Std.parseInt` converts a `String` to an `Int`.\n\n\t@see https://haxe.org/manual/types-basic-types.html\n\t@see https://haxe.org/manual/std-math-integer-math.html\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:coreType @:notNull @:runtimeValue abstract Int to Float {}\n\n#if (java || cs || hl || cpp)\n/**\n\tSingle-precision IEEE 32bit float (4-byte).\n**/\n@:coreType @:notNull @:runtimeValue abstract Single to Float from Float {}\n#end\n\n/**\n\t`Null<T>` is a wrapper that can be used to make the basic types `Int`,\n\t`Float` and `Bool` nullable on static targets.\n\n\tIf null safety is enabled, only types wrapped in `Null<T>` are nullable.\n\n\tOtherwise, it has no effect on non-basic-types, but it can be useful as a way to document\n\tthat `null` is an acceptable value for a method argument, return value or variable.\n\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:forward\n@:coreType\nabstract Null<T> from T to T {}\n\n/**\n\tThe standard Boolean type, which can either be `true` or `false`.\n\n\tOn static targets, `null` cannot be assigned to `Bool`. If this is necessary,\n\t`Null<Bool>` can be used instead.\n\n\t@see https://haxe.org/manual/types-bool.html\n\t@see https://haxe.org/manual/types-nullability.html\n**/\n@:coreType @:notNull @:runtimeValue abstract Bool {}\n\n/**\n\t`Dynamic` is a special type which is compatible with all other types.\n\n\tUse of `Dynamic` should be minimized as it prevents several compiler\n\tchecks and optimizations. See `Any` type for a safer alternative for\n\trepresenting values of any type.\n\n\t@see https://haxe.org/manual/types-dynamic.html\n**/\n@:coreType @:runtimeValue abstract Dynamic<T> {}\n\n/**\n\tAn `Iterator` is a structure that permits iteration over elements of type `T`.\n\n\tAny class with matching `hasNext()` and `next()` fields is considered an `Iterator`\n\tand can then be used e.g. in `for`-loops. This makes it easy to implement\n\tcustom iterators.\n\n\t@see https://haxe.org/manual/lf-iterators.html\n**/\ntypedef Iterator<T> = {\n\t/**\n\t\tReturns `false` if the iteration is complete, `true` otherwise.\n\n\t\tUsually iteration is considered to be complete if all elements of the\n\t\tunderlying data structure were handled through calls to `next()`. However,\n\t\tin custom iterators any logic may be used to determine the completion\n\t\tstate.\n\t**/\n\tfunction hasNext():Bool;\n\n\t/**\n\t\tReturns the current item of the `Iterator` and advances to the next one.\n\n\t\tThis method is not required to check `hasNext()` first. A call to this\n\t\tmethod while `hasNext()` is `false` yields unspecified behavior.\n\n\t\tOn the other hand, iterators should not require a call to `hasNext()`\n\t\tbefore the first call to `next()` if an element is available.\n\t**/\n\tfunction next():T;\n}\n\n/**\n\tAn `Iterable` is a data structure which has an `iterator()` method.\n\tSee `Lambda` for generic functions on iterable structures.\n\n\t@see https://haxe.org/manual/lf-iterators.html\n**/\ntypedef Iterable<T> = {\n\tfunction iterator():Iterator<T>;\n}\n\n/**\n\tA `KeyValueIterator` is an `Iterator` that has a key and a value.\n**/\ntypedef KeyValueIterator<K, V> = Iterator<{key:K, value:V}>;\n\n/**\n\tA `KeyValueIterable` is a data structure which has a `keyValueIterator()`\n\tmethod to iterate over key-value-pairs.\n**/\ntypedef KeyValueIterable<K, V> = {\n\tfunction keyValueIterator():KeyValueIterator<K, V>;\n}\n\n/**\n\t`ArrayAccess` is used to indicate a class that can be accessed using brackets.\n\tThe type parameter represents the type of the elements stored.\n\n\tThis interface should be used for externs only. Haxe does not support custom\n\tarray access on classes. However, array access can be implemented for\n\tabstract types.\n\n\t@see https://haxe.org/manual/types-abstract-array-access.html\n**/\nextern interface ArrayAccess<T> {}\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.stream;\r\n\r\nimport js.node.Iterator;\r\nimport js.node.Stream;\r\nimport js.node.events.EventEmitter.Event;\r\nimport js.node.stream.Writable.IWritable;\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n/**\r\n\tReadable streams are an abstraction for a source from which data is consumed.\r\n\r\n\t@see https://nodejs.org/api/stream.html#stream_readable_streams\r\n**/\r\n@:enum abstract ReadableEvent<T:haxe.Constraints.Function>(Event<T>) to Event<T> {\r\n\t/**\r\n\t\tThe `'close'` event is emitted when the stream and any of its underlying\r\n\t\tresources (a file descriptor, for example) have been closed.\r\n\t\tThe event indicates that no more events will be emitted, and no further computation will occur.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_close_1\r\n\t**/\r\n\tvar Close:ReadableEvent<Void->Void> = \"close\";\r\n\r\n\t/**\r\n\t\tThe `'data'` event is emitted whenever the stream is relinquishing ownership of\r\n\t\ta chunk of data to a consumer. This may occur whenever the stream is switched\r\n\t\tin flowing mode by calling `readable.pipe()`, `readable.resume()`, or by\r\n\t\tattaching a listener callback to the `'data'` event. The `'data'` event will\r\n\t\talso be emitted whenever the `readable.read()` method is called and a chunk of\r\n\t\tdata is available to be returned.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_data\r\n\t**/\r\n\tvar Data:ReadableEvent<Dynamic->Void> = \"data\";\r\n\r\n\t/**\r\n\t\tThe `'end'` event is emitted when there is no more data to be consumed from\r\n\t\tthe stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_end\r\n\t**/\r\n\tvar End:ReadableEvent<Void->Void> = \"end\";\r\n\r\n\t/**\r\n\t\tThe `'error'` event may be emitted by a `Readable` implementation at any time.\r\n\t\tTypically, this may occur if the underlying stream is unable to generate data\r\n\t\tdue to an underlying internal failure, or when a stream implementation attempts\r\n\t\tto push an invalid chunk of data.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_error_1\r\n\t**/\r\n\tvar Error:ReadableEvent<Error->Void> = \"error\";\r\n\r\n\t/**\r\n\t\tThe `'pause'` event is emitted when `stream.pause()` is called\r\n\t\tand `readableFlowing` is not `false`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_pause\r\n\t**/\r\n\tvar Pause:ReadableEvent<Void->Void> = \"pause\";\r\n\r\n\t/**\r\n\t\tThe `'readable'` event is emitted when there is data available to be read from\r\n\t\tthe stream. In some cases, attaching a listener for the `'readable'` event will\r\n\t\tcause some amount of data to be read into an internal buffer.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_readable\r\n\t**/\r\n\tvar Readable:ReadableEvent<Void->Void> = \"readable\";\r\n\r\n\t/**\r\n\t\tThe `'resume'` event is emitted when `stream.resume()` is\r\n\t\tcalled and `readableFlowing` is not `true`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_event_resume\r\n\t**/\r\n\tvar Resume:ReadableEvent<Void->Void> = \"resume\";\r\n}\r\n\r\n/**\r\n\t@see https://nodejs.org/api/stream.html#stream_class_stream_readable\r\n**/\r\n@:jsRequire(\"stream\", \"Readable\")\r\nextern class Readable<TSelf:Readable<TSelf>> extends Stream<TSelf> implements IReadable {\r\n\t/**\r\n\t\tDestroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event unless `emitClose` is set in `false`.\r\n\t\tAfter this call, the readable stream will release any internal resources and subsequent calls to `push()` will be ignored.\r\n\t\tImplementors should not override this method, but instead implement `readable._destroy()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_destroy_error\r\n\t**/\r\n\tfunction destroy(?error:Error):TSelf;\r\n\r\n\t/**\r\n\t\tIs `true` after `readable.destroy()` has been called.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_destroyed\r\n\t**/\r\n\tvar destroyed(default, null):Bool;\r\n\r\n\t/**\r\n\t\tThe `readable.isPaused()` method returns the current operating state of the `Readable`.\r\n\t\tThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\r\n\t\tIn most typical cases, there will be no reason to use this method directly.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_ispaused\r\n\t**/\r\n\tfunction isPaused():Bool;\r\n\r\n\t/**\r\n\t\tThe `readable.pause()` method will cause a stream in flowing mode to stop emitting `'data'` events,\r\n\t\tswitching out of flowing mode. Any data that becomes available will remain in the internal buffer.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_pause\r\n\t**/\r\n\tfunction pause():TSelf;\r\n\r\n\t/**\r\n\t\tThe `readable.pipe()` method attaches a `Writable` stream to the `readable`,\r\n\t\tcausing it to switch automatically into flowing mode and push all of its data to the attached `Writable`.\r\n\t\tThe flow of data will be automatically managed so that the destination `Writable` stream\r\n\t\tis not overwhelmed by a faster `Readable` stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n\t**/\r\n\tfunction pipe<T:IWritable>(destination:T, ?options:{?end:Bool}):T;\r\n\r\n\t/**\r\n\t\tThe `readable.read()` method pulls some data out of the internal buffer and returns it.\r\n\t\tIf no data available to be read, `null` is returned. By default,\r\n\t\tthe data will be returned as a `Buffer` object unless an encoding has been specified using\r\n\t\tthe `readable.setEncoding()` method or the stream is operating in object mode.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_read_size\r\n\t**/\r\n\tfunction read(?size:Int):Null<Dynamic>;\r\n\r\n\t/**\r\n\t\tIs `true` if it is safe to call `readable.read()`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_readable\r\n\t**/\r\n\tvar readable(default, null):Bool;\r\n\r\n\t/**\r\n\t\tGetter for the property `encoding` of a given `Readable` stream.\r\n\t\tThe `encoding` property can be set using the `readable.setEncoding()` method.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_readableencoding\r\n\t**/\r\n\tvar readableEncoding(default, null):Null<String>;\r\n\r\n\t/**\r\n\t\tBecomes `true` when `'end'` event is emitted.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_readableended\r\n\t**/\r\n\tvar readableEnded(default, null):Bool;\r\n\r\n\t/**\r\n\t\tReturns the value of `highWaterMark` passed when constructing this `Readable`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_readablehighwatermark\r\n\t**/\r\n\tvar readableHighWaterMark(default, null):Int;\r\n\r\n\t/**\r\n\t\tThis property contains the number of bytes (or objects) in the queue ready to be read.\r\n\t\tThe value provides introspection data regarding the status of the `highWaterMark`.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_readablelength\r\n\t**/\r\n\tvar readableLength(default, null):Int;\r\n\r\n\t/**\r\n\t\tGetter for the property `objectMode` of a given `Readable` stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_readableobjectmode\r\n\t**/\r\n\tvar readableObjectMode(default, null):Bool;\r\n\r\n\t/**\r\n\t\tThe `readable.resume()` method causes an explicitly paused `Readable` stream to resume emitting `'data'` events,\r\n\t\tswitching the stream into flowing mode.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_resume\r\n\t**/\r\n\tfunction resume():TSelf;\r\n\r\n\t/**\r\n\t\tThe `readable.setEncoding()` method sets the character encoding for data read from the `Readable` stream.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_setencoding_encoding\r\n\t**/\r\n\tfunction setEncoding(encoding:String):TSelf;\r\n\r\n\t/**\r\n\t\tThe `readable.unpipe()` method detaches a `Writable` stream previously attached using the `stream.pipe()` method.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_unpipe_destination\r\n\t**/\r\n\tfunction unpipe(?destination:IWritable):TSelf;\r\n\r\n\t/**\r\n\t\tPassing `chunk` as `null` signals the end of the stream (EOF), after which no more data can be written.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_unshift_chunk_encoding\r\n\t**/\r\n\tfunction unshift(chunk:Null<Dynamic>, ?encoding:String):Void;\r\n\r\n\t/**\r\n\t\tPrior to Node.js 0.10, streams did not implement the entire `stream` module API as it is currently defined.\r\n\t\t(See Compatibility for more information.)\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_wrap_stream\r\n\t**/\r\n\tfunction wrap(stream:Dynamic):IReadable;\r\n\r\n\t// --------- API for implementing a Readable Stream -----------------------\r\n\r\n\t/**\r\n\t\t@see https://nodejs.org/api/stream.html#stream_new_stream_readable_options\r\n\t**/\r\n\tfunction new(?options:ReadableNewOptions);\r\n\r\n\t/**\r\n\t\tThis function **MUST NOT** be called by application code directly.\r\n\t\tIt should be implemented by child classes, and called by the internal `Readable` class methods only.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_read_size_1\r\n\t**/\r\n\tprivate function _read(size:Int):Void;\r\n\r\n\t/**\r\n\t\tThe `_destroy()` method is called by `readable.destroy()`.\r\n\t\tIt can be overridden by child classes but it **must not** be called directly.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_destroy_err_callback\r\n\t**/\r\n\tprivate function _destroy(err:Null<Error>, callback:Null<Error>->Void):Void;\r\n\r\n\t/**\r\n\t\tThe `readable.push()` method is intended be called only by `Readable` implementers,\r\n\t\tand only from within the `readable._read()` method.\r\n\r\n\t\t@see https://nodejs.org/api/stream.html#stream_readable_push_chunk_encoding\r\n\t**/\r\n\tprivate function push(chunk:Null<Dynamic>, ?encoding:String):Bool;\r\n\r\n\t// --------- TTY module API  ----------------------------------------------\r\n\r\n\t/**\r\n\t\tTerminal read streams (i.e. process.stdin) have this property set to true.\r\n\t\tIt is false for any other read streams.\r\n\r\n\t\t@see https://nodejs.org/api/tty.html#tty_readstream_istty\r\n\t**/\r\n\tvar isTTY(default, null):Bool;\r\n\r\n\t// --------- static API  --------------------------------------------------\r\n\t// TODO @:overload(function<T>(iterable:AsyncIterator<T>, ?options:ReadableNewOptions):IReadable {})\r\n\tstatic function from<T>(iterable:Iterator<T>, ?options:ReadableNewOptions):IReadable;\r\n}\r\n\r\n/**\r\n\tOptions for `Readable` private constructor.\r\n\tFor stream implementors only, see node.js API documentation\r\n**/\r\ntypedef ReadableNewOptions = {\r\n\t/**\r\n\t\tThe maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource.\r\n\t\tDefault: `16384` (16kb), or `16` for `objectMode` streams.\r\n\t**/\r\n\t@:optional var highWaterMark:Int;\r\n\r\n\t/**\r\n\t\tIf specified, then buffers will be decoded to strings using the specified encoding.\r\n\t\tDefault: `null`.\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tWhether this stream should behave as a stream of objects.\r\n\t\tMeaning that `stream.read(n)` returns a single value instead of a `Buffer` of size `n`.\r\n\t\tDefault: `false`.\r\n\t**/\r\n\t@:optional var objectMode:Bool;\r\n\r\n\t/**\r\n\t\tWhether or not the stream should emit `'close'` after it has been destroyed.\r\n\t\tDefault: `true`.\r\n\t**/\r\n\t@:optional var emitClose:Bool;\r\n\r\n\t/**\r\n\t\tImplementation for the `stream._read()` method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var read:(size:Int) -> Void;\r\n\t#else\r\n\t@:optional var read:Int->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\tImplementation for the `stream._destroy()` method.\r\n\t**/\r\n\t#if haxe4\r\n\t@:optional var destroy:(err:Null<Error>, callback:Null<Error>->Void) -> Void;\r\n\t#else\r\n\t@:optional var destroy:Null<Error>->(Null<Error>->Void)->Void;\r\n\t#end\r\n\r\n\t/**\r\n\t\tWhether this stream should automatically call `.destroy()` on itself after ending.\r\n\t\tDefault: `false`.\r\n\t**/\r\n\t@:optional var autoDestroy:Bool;\r\n}\r\n\r\n/**\r\n\t`IReadable` interface is used as \"any Readable\".\r\n\r\n\tSee `Readable` for actual class documentation.\r\n**/\r\n@:remove\r\nextern interface IReadable extends IStream {\r\n\tfunction destroy(?error:Error):IReadable;\r\n\r\n\tvar destroyed(default, null):Bool;\r\n\r\n\tfunction isPaused():Bool;\r\n\r\n\tfunction pause():IReadable;\r\n\r\n\tfunction pipe<T:IWritable>(destination:T, ?options:{?end:Bool}):T;\r\n\r\n\tfunction read(?size:Int):Null<Dynamic>;\r\n\r\n\tvar readable(default, null):Bool;\r\n\r\n\tvar readableEncoding(default, null):Null<String>;\r\n\r\n\tvar readableEnded(default, null):Bool;\r\n\r\n\tvar readableHighWaterMark(default, null):Int;\r\n\r\n\tvar readableLength(default, null):Int;\r\n\r\n\tvar readableObjectMode(default, null):Bool;\r\n\r\n\tfunction resume():IReadable;\r\n\r\n\tfunction setEncoding(encoding:String):IReadable;\r\n\r\n\tfunction unpipe(?destination:IWritable):IReadable;\r\n\r\n\tfunction unshift(chunk:Null<Dynamic>, ?encoding:String):Void;\r\n\r\n\tfunction wrap(stream:Dynamic):IReadable;\r\n}\r\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi extern class String {\n\tvar length(default, null):Int;\n\n\t@:pure function new(string:String):Void;\n\t@:pure function toUpperCase():String;\n\t@:pure function toLowerCase():String;\n\t@:pure function charAt(index:Int):String;\n\t@:pure function indexOf(str:String, ?startIndex:Int):Int;\n\t@:pure function lastIndexOf(str:String, ?startIndex:Int):Int;\n\t@:pure function split(delimiter:String):Array<String>;\n\t@:pure function toString():String;\n\t@:pure function substring(startIndex:Int, ?endIndex:Int):String;\n\n\t@:pure inline function charCodeAt(index:Int):Null<Int> {\n\t\treturn @:privateAccess HxOverrides.cca(this, index);\n\t}\n\n\t@:pure inline function substr(pos:Int, ?len:Int):String {\n\t\treturn @:privateAccess HxOverrides.substr(this, pos, len);\n\t}\n\n\t@:pure static inline function fromCharCode(code:Int):String {\n\t\treturn untyped __define_feature__('String.fromCharCode', js.Syntax.code(\"String.fromCodePoint({0})\", code));\n\t}\n\n\tstatic function __init__():Void {\n\t\tuntyped __feature__('String.fromCharCode',\n\t\t\tjs.Syntax.code(\"if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }\"));\n\t}\n}\n","/*\n * Copyright (C)2005-2018 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage js.lib;\n\n@:native(\"Error\")\nextern class Error {\n\tvar message:String;\n\tvar name:String;\n\tvar stack(default, null):String;\n\n\tfunction new(?message:String):Void;\n}\n\n@:native(\"EvalError\")\nextern class EvalError extends Error {\n\tfunction new(?message:String):Void;\n}\n\n@:native(\"RangeError\")\nextern class RangeError extends Error {\n\tfunction new(?message:String):Void;\n}\n\n@:native(\"ReferenceError\")\nextern class ReferenceError extends Error {\n\tfunction new(?message:String):Void;\n}\n\n@:native(\"SyntaxError\")\nextern class SyntaxError extends Error {\n\tfunction new(?message:String):Void;\n}\n\n@:native(\"TypeError\")\nextern class TypeError extends Error {\n\tfunction new(?message:String):Void;\n}\n\n@:native(\"URIError\")\nextern class URIError extends Error {\n\tfunction new(?message:String):Void;\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport haxe.iterators.ArrayKeyValueIterator;\n\n@:coreApi\nextern class Array<T> {\n\tvar length(default, null):Int;\n\n\tfunction new():Void;\n\tfunction concat(a:Array<T>):Array<T>;\n\tfunction join(sep:String):String;\n\tfunction pop():Null<T>;\n\tfunction push(x:T):Int;\n\tfunction reverse():Void;\n\tfunction shift():Null<T>;\n\tfunction slice(pos:Int, ?end:Int):Array<T>;\n\tfunction sort(f:T->T->Int):Void;\n\tfunction splice(pos:Int, len:Int):Array<T>;\n\tfunction toString():String;\n\tfunction unshift(x:T):Void;\n\n\tinline function insert(pos:Int, x:T):Void {\n\t\t(cast this).splice(pos, 0, x);\n\t}\n\n\tinline function remove(x:T):Bool {\n\t\treturn @:privateAccess HxOverrides.remove(this, x);\n\t}\n\n\tinline function contains(x:T):Bool {\n\t\t#if (js_es >= 6)\n\t\treturn (cast this).includes(x);\n\t\t#else\n\t\treturn this.indexOf(x) != -1;\n\t\t#end\n\t}\n\n\t#if (js_es >= 5)\n\t@:pure function indexOf(x:T, ?fromIndex:Int):Int;\n\t@:pure function lastIndexOf(x:T, ?fromIndex:Int):Int;\n\t#else\n\tinline function indexOf(x:T, ?fromIndex:Int):Int {\n\t\treturn @:privateAccess HxOverrides.indexOf(this, x, (fromIndex != null) ? fromIndex : 0);\n\t}\n\n\tinline function lastIndexOf(x:T, ?fromIndex:Int):Int {\n\t\treturn @:privateAccess HxOverrides.lastIndexOf(this, x, (fromIndex != null) ? fromIndex : length - 1);\n\t}\n\t#end\n\n\t@:pure\n\tinline function copy():Array<T> {\n\t\treturn (cast this).slice();\n\t}\n\n\t@:runtime inline function map<S>(f:T->S):Array<S> {\n\t\tvar result:Array<S> = js.Syntax.construct(Array, length);\n\t\tfor(i in 0...length) {\n\t\t\tresult[i] = f(this[i]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@:runtime inline function filter(f:T->Bool):Array<T> {\n\t\treturn [for (v in this) if (f(v)) v];\n\t}\n\n\t@:runtime inline function iterator():haxe.iterators.ArrayIterator<T> {\n\t\treturn new haxe.iterators.ArrayIterator(this);\n\t}\n\n\t@:runtime inline function keyValueIterator():ArrayKeyValueIterator<T> {\n\t\treturn new ArrayKeyValueIterator(this);\n\t}\n\n\tinline function resize(len:Int):Void {\n\t\tthis.length = len;\n\t}\n}\n"]}