{"sourceRoot":"","names":[],"mappings":"QA8BA;QCCA;QCDA;QCHA;QCRA;QCMA;QCpBA;QCAA;OC4dO;OC1JA;QC5RA;QCjBG;QCLA;;;;;;ACVV;AAAA;;;;;CACC,gBACC;EAAA,qBAAqB,WAAW;;;;;;;;CAGjC,kBAAsD,CACrD;EAAA,qBAAqB,WAAW,IAChC;EAAA,qBAAqB;;;;;;;;;;;CAGtB,cACC;EAAA,AAAO,0BAAmB;;;;;;;CAG3B,iBACQ;EAAA,mBAAY;;;;;;;;CAGpB,oBACC;EAAA,YAAY,KAAK;;;;;;CAGlB,qBAAyD,CACxD;EAAA,QAAQ,gBACR;EAAA;EAAA,UAAY,4BAAZ;EAAA,YAAY,YAAZ,CAAK;GAAA,UAAL,AAAY,IAAZ;GAAA,KACC;GAAA,QAAS,YAAY,KAArB;GAAA,WAAE,KAAF;IACD;EAAA,AAAO;;;;;;;CAGR,0BACC;EAAA,AAAO;;;;;;CAGR,gBACC;EAAA,AAAO;;;;;;;;CAGR,iBACC;EAAA,cAAc;;;;;;;;;;CAGf,oBACC,CAAe;EAAA;EAAA;GACC,AAAV,cAAU;IAAA;;GACC,AAAX,eAAW;IAAA;;GACF,AAAT,aAAS;IAAA;;GACA,AAAT,aAAS;IAAA;;GACd,QAAK;GAAA,YALS,GAKF;GAAA;;;;;;;;;;;;;;;;;;;;CAId,iCACC;EAAA,GAAI,SAAQ,MACX;GAAA,AAAO,8BAAuB,KAAK,CAAQ,eAAa;GAExD;GAAA,AAAO,8BAAuB,KAAK,MAAM,CAAQ;;;;;;;;;;CAGnD,kBACC;EAAA,aAAa;;;;;;CAGd,cACC;EAAA,AAAO,OAAM,aAAc;;;;;;;CAG5B,iBACC;EAAA,AAAO;;;;;;CAMR,wBACC;EAAA,AAAO,oBAAa;;;;;;;;CAIrB,qBACC;EAAA,AAAO;;;;;;;CAIR,qBACC;EAAA,uBAAM;;;;;;CAGP,sBAAiD,CAChD;EAAA,UAAU,AAAM,aAAc,UAAU,KACxC;EAAA,MAAO,CAAM,cAAe,KAA5B;;;;;;;;;CAGD,eACC;EAAA,AAAO,qBAAc;;;;;;CAGtB,gBACC;EAAA,AAAO,sBAAe;;;;;;CAGvB,gBACC;EAAA,AAAO,sBAAe;;;;;;;;;;;AAIhB;AAAA;CAGP,QACC;EAAA,UAAU;;CAGX,aACC;EAAA,aAAa,SAAI;;CAGlB,wBACC,CAAwB;EAAA,WAAmB,IAA3C;EAAA,AAAO,oBAAa,SAAI,0CAAmB,WAAI,KAAK;;CAGrD,gCACC;EAAA,aAAa,SAAI;;CAGlB,QACC;EAAA,aAAa;;CAGd,QACC;EAAA,aAAa;;;;;;;;;;;;;;AAIP;AAAA;CAGP,QACC;EAAA,UAAU;;CAGX,WAAwC,CACvC;EAAA,UAAU,aAAa,GACvB;EAAA,IACC;GAAA,YAAY,SAAI,KAAK,GAAG,GAAG;cAE3B;;yCAAA;GAAA,GAAI,WAAU,OACb;IAAA,uBAAM;IAEN;IAAA,uBAAM,aAAa;;IAErB;EAAA,AAAO,WAAI;;CAGZ,uBAAkE,CACvD;EAAA,WAAmB,IAA7B;EAAA,UAAU,0CAAmB,UAC7B;EAAA,IACC;GAAA,AAAO,mBAAY,SAAI,KAAK,KAAK,KAAK;cAEtC;;yCAAA;GAAA,GAAI,WAAU,OACb;IAAA,uBAAM;IAEN;IAAA,uBAAM,aAAa;;;;CAItB,QACC;EAAA,aAAa","version":3,"file":"Sys.js.map","sources":["../../../../../haxe/versions/4.1.1/std/haxe/io/Output.hx","../../../../../haxe/versions/4.1.1/std/haxe/io/Input.hx","../../../../../haxe/versions/4.1.1/std/haxe/io/Error.hx","../../../../../haxe/versions/4.1.1/std/haxe/io/Eof.hx","../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/haxe/ds/StringMap.hx","../../../../../haxe/versions/4.1.1/std/js/_std/haxe/NativeStackTrace.hx","../../../../../haxe/versions/4.1.1/std/js/_std/haxe/Exception.hx","../../../../../haxe/haxe_libraries/genes/0.3.2/github/c0832e2c0971599e5139e57795981c7a450426d6/src/genes/Register.hx","../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/Fs.hx","../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/ChildProcess.hx","../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/js/node/buffer/Buffer.hx","../../../../../haxe/versions/4.1.1/std/js/_std/Std.hx","../../../../../haxe/versions/4.1.1/std/js/_std/Reflect.hx","../../../../../haxe/haxe_libraries/hxnodejs/12.1.0/haxelib/src/Sys.hx"],"sourcesContent":["/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Output is an abstract write. A specific output implementation will only\n\thave to override the `writeByte` and maybe the `write`, `flush` and `close`\n\tmethods. See `File.write` and `String.write` for two ways of creating an\n\tOutput.\n**/\nclass Output {\n\t/**\n\t\tEndianness (word byte order) used when writing numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tWrite one byte.\n\t**/\n\tpublic function writeByte(c:Int):Void {\n\t\tthrow \"Not implemented\";\n\t}\n\n\t/**\n\t\tWrite `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tReturns the actual length of written data that can differ from `len`.\n\n\t\tSee `writeFullBytes` that tries to write the exact amount of specified bytes.\n\t**/\n\tpublic function writeBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\t#if !neko\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\t#end\n\t\tvar b = #if js @:privateAccess s.b #else s.getData() #end;\n\t\tvar k = len;\n\t\twhile (k > 0) {\n\t\t\t#if neko\n\t\t\twriteByte(untyped __dollar__sget(b, pos));\n\t\t\t#elseif php\n\t\t\twriteByte(b.get(pos));\n\t\t\t#elseif cpp\n\t\t\twriteByte(untyped b[pos]);\n\t\t\t#elseif hl\n\t\t\twriteByte(b[pos]);\n\t\t\t#else\n\t\t\twriteByte(untyped b[pos]);\n\t\t\t#end\n\t\t\tpos++;\n\t\t\tk--;\n\t\t}\n\t\treturn len;\n\t}\n\n\t/**\n\t\tFlush any buffered data.\n\t**/\n\tpublic function flush() {}\n\n\t/**\n\t\tClose the output.\n\n\t\tBehaviour while writing after calling this method is unspecified.\n\t**/\n\tpublic function close() {}\n\n\tfunction set_bigEndian(b) {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tWrite all bytes stored in `s`.\n\t**/\n\tpublic function write(s:Bytes):Void {\n\t\tvar l = s.length;\n\t\tvar p = 0;\n\t\twhile (l > 0) {\n\t\t\tvar k = writeBytes(s, p, l);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tl -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `len` bytes from `s` starting by position specified by `pos`.\n\n\t\tUnlike `writeBytes`, this method tries to write the exact `len` amount of bytes.\n\t**/\n\tpublic function writeFullBytes(s:Bytes, pos:Int, len:Int) {\n\t\twhile (len > 0) {\n\t\t\tvar k = writeBytes(s, pos, len);\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeFloat(x:Float) {\n\t\twriteInt32(FPHelper.floatToI32(x));\n\t}\n\n\t/**\n\t\tWrite `x` as 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeDouble(x:Float) {\n\t\tvar i64 = FPHelper.doubleToI64(x);\n\t\tif (bigEndian) {\n\t\t\twriteInt32(i64.high);\n\t\t\twriteInt32(i64.low);\n\t\t} else {\n\t\t\twriteInt32(i64.low);\n\t\t\twriteInt32(i64.high);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 8-bit signed integer.\n\t**/\n\tpublic function writeInt8(x:Int) {\n\t\tif (x < -0x80 || x >= 0x80)\n\t\t\tthrow Error.Overflow;\n\t\twriteByte(x & 0xFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt16(x:Int) {\n\t\tif (x < -0x8000 || x >= 0x8000)\n\t\t\tthrow Error.Overflow;\n\t\twriteUInt16(x & 0xFFFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeUInt16(x:Int) {\n\t\tif (x < 0 || x >= 0x10000)\n\t\t\tthrow Error.Overflow;\n\t\tif (bigEndian) {\n\t\t\twriteByte(x >> 8);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte(x >> 8);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt24(x:Int) {\n\t\tif (x < -0x800000 || x >= 0x800000)\n\t\t\tthrow Error.Overflow;\n\t\twriteUInt24(x & 0xFFFFFF);\n\t}\n\n\t/**\n\t\tWrite `x` as 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeUInt24(x:Int) {\n\t\tif (x < 0 || x >= 0x1000000)\n\t\t\tthrow Error.Overflow;\n\t\tif (bigEndian) {\n\t\t\twriteByte(x >> 16);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x >> 16);\n\t\t}\n\t}\n\n\t/**\n\t\tWrite `x` as 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function writeInt32(x:Int) {\n\t\tif (bigEndian) {\n\t\t\twriteByte(x >>> 24);\n\t\t\twriteByte((x >> 16) & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte(x & 0xFF);\n\t\t} else {\n\t\t\twriteByte(x & 0xFF);\n\t\t\twriteByte((x >> 8) & 0xFF);\n\t\t\twriteByte((x >> 16) & 0xFF);\n\t\t\twriteByte(x >>> 24);\n\t\t}\n\t}\n\n\t/**\n\t\tInform that we are about to write at least `nbytes` bytes.\n\n\t\tThe underlying implementation can allocate proper working space depending\n\t\ton this information, or simply ignore it. This is not a mandatory call\n\t\tbut a tip and is only used in some specific cases.\n\t**/\n\tpublic function prepare(nbytes:Int) {}\n\n\t/**\n\t\tRead all available data from `i` and write it.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read and written. Its default value is 4096.\n\t**/\n\tpublic function writeInput(i:Input, ?bufsize:Int) {\n\t\tif (bufsize == null)\n\t\t\tbufsize = 4096;\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = i.readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\tvar p = 0;\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tvar k = writeBytes(buf, p, len);\n\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\t\tp += k;\n\t\t\t\t\tlen -= k;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t}\n\n\t/**\n\t\tWrite `s` string.\n\t**/\n\tpublic function writeString(s:String, ?encoding:Encoding) {\n\t\t#if neko\n\t\tvar b = untyped new Bytes(s.length, s.__s);\n\t\t#else\n\t\tvar b = Bytes.ofString(s, encoding);\n\t\t#end\n\t\twriteFullBytes(b, 0, b.length);\n\t}\n\n\t#if neko\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tOutput.prototype.bigEndian = false;\n\t\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tAn Input is an abstract reader. See other classes in the `haxe.io` package\n\tfor several possible implementations.\n\n\tAll functions which read data throw `Eof` when the end of the stream\n\tis reached.\n**/\nclass Input {\n\t/**\n\t\tEndianness (word byte order) used when reading numbers.\n\n\t\tIf `true`, big-endian is used, otherwise `little-endian` is used.\n\t**/\n\tpublic var bigEndian(default, set):Bool;\n\n\t#if cs\n\tprivate var helper:BytesData;\n\t#elseif java\n\tprivate var helper:java.nio.ByteBuffer;\n\t#end\n\n\t/**\n\t\tRead and return one byte.\n\t**/\n\tpublic function readByte():Int {\n\t\t#if cpp\n\t\tthrow \"Not implemented\";\n\t\t#else\n\t\treturn throw \"Not implemented\";\n\t\t#end\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tReturns the actual length of read data that can be smaller than `len`.\n\n\t\tSee `readFullBytes` that tries to read the exact amount of specified bytes.\n\t**/\n\tpublic function readBytes(s:Bytes, pos:Int, len:Int):Int {\n\t\tvar k = len;\n\t\tvar b = #if (js || hl) @:privateAccess s.b #else s.getData() #end;\n\t\tif (pos < 0 || len < 0 || pos + len > s.length)\n\t\t\tthrow Error.OutsideBounds;\n\t\ttry {\n\t\t\twhile (k > 0) {\n\t\t\t\t#if neko\n\t\t\t\tuntyped __dollar__sset(b, pos, readByte());\n\t\t\t\t#elseif php\n\t\t\t\tb.set(pos, readByte());\n\t\t\t\t#elseif cpp\n\t\t\t\tb[pos] = untyped readByte();\n\t\t\t\t#else\n\t\t\t\tb[pos] = cast readByte();\n\t\t\t\t#end\n\t\t\t\tpos++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t} catch (eof:haxe.io.Eof) {}\n\t\treturn len - k;\n\t}\n\n\t/**\n\t\tClose the input source.\n\n\t\tBehaviour while reading after calling this method is unspecified.\n\t**/\n\tpublic function close():Void {}\n\n\tfunction set_bigEndian(b:Bool):Bool {\n\t\tbigEndian = b;\n\t\treturn b;\n\t}\n\n\t/* ------------------ API ------------------ */\n\t/**\n\t\tRead and return all available data.\n\n\t\tThe `bufsize` optional argument specifies the size of chunks by\n\t\twhich data is read. Its default value is target-specific.\n\t**/\n\tpublic function readAll(?bufsize:Int):Bytes {\n\t\tif (bufsize == null)\n\t\t\t#if php\n\t\t\tbufsize = 8192; // default value for PHP and max under certain circumstances\n\t\t\t#else\n\t\t\tbufsize = (1 << 14); // 16 Ko\n\t\t\t#end\n\n\t\tvar buf = Bytes.alloc(bufsize);\n\t\tvar total = new haxe.io.BytesBuffer();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tvar len = readBytes(buf, 0, bufsize);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tthrow Error.Blocked;\n\t\t\t\ttotal.addBytes(buf, 0, len);\n\t\t\t}\n\t\t} catch (e:Eof) {}\n\t\treturn total.getBytes();\n\t}\n\n\t/**\n\t\tRead `len` bytes and write them into `s` to the position specified by `pos`.\n\n\t\tUnlike `readBytes`, this method tries to read the exact `len` amount of bytes.\n\t**/\n\tpublic function readFullBytes(s:Bytes, pos:Int, len:Int):Void {\n\t\twhile (len > 0) {\n\t\t\tvar k = readBytes(s, pos, len);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tpos += k;\n\t\t\tlen -= k;\n\t\t}\n\t}\n\n\t/**\n\t\tRead and return `nbytes` bytes.\n\t**/\n\tpublic function read(nbytes:Int):Bytes {\n\t\tvar s = Bytes.alloc(nbytes);\n\t\tvar p = 0;\n\t\twhile (nbytes > 0) {\n\t\t\tvar k = readBytes(s, p, nbytes);\n\t\t\tif (k == 0)\n\t\t\t\tthrow Error.Blocked;\n\t\t\tp += k;\n\t\t\tnbytes -= k;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a string until a character code specified by `end` is occurred.\n\n\t\tThe final character is not included in the resulting string.\n\t**/\n\tpublic function readUntil(end:Int):String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\twhile ((last = readByte()) != end)\n\t\t\tbuf.addByte(last);\n\t\treturn buf.getBytes().toString();\n\t}\n\n\t/**\n\t\tRead a line of text separated by CR and/or LF bytes.\n\n\t\tThe CR/LF characters are not included in the resulting string.\n\t**/\n\tpublic function readLine():String {\n\t\tvar buf = new BytesBuffer();\n\t\tvar last:Int;\n\t\tvar s;\n\t\ttry {\n\t\t\twhile ((last = readByte()) != 10)\n\t\t\t\tbuf.addByte(last);\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.charCodeAt(s.length - 1) == 13)\n\t\t\t\ts = s.substr(0, -1);\n\t\t} catch (e:Eof) {\n\t\t\ts = buf.getBytes().toString();\n\t\t\tif (s.length == 0)\n\t\t\t\t#if neko neko.Lib.rethrow #else throw #end (e);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tRead a 32-bit floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readFloat():Float {\n\t\treturn FPHelper.i32ToFloat(readInt32());\n\t}\n\n\t/**\n\t\tRead a 64-bit double-precision floating point number.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readDouble():Float {\n\t\tvar i1 = readInt32();\n\t\tvar i2 = readInt32();\n\t\treturn bigEndian ? FPHelper.i64ToDouble(i2, i1) : FPHelper.i64ToDouble(i1, i2);\n\t}\n\n\t/**\n\t\tRead a 8-bit signed integer.\n\t**/\n\tpublic function readInt8():Int {\n\t\tvar n = readByte();\n\t\tif (n >= 128)\n\t\t\treturn n - 256;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar n = bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t\tif (n & 0x8000 != 0)\n\t\t\treturn n - 0x10000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 16-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt16():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\treturn bigEndian ? ch2 | (ch1 << 8) : ch1 | (ch2 << 8);\n\t}\n\n\t/**\n\t\tRead a 24-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar n = bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t\tif (n & 0x800000 != 0)\n\t\t\treturn n - 0x1000000;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tRead a 24-bit unsigned integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readUInt24():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\treturn bigEndian ? ch3 | (ch2 << 8) | (ch1 << 16) : ch1 | (ch2 << 8) | (ch3 << 16);\n\t}\n\n\t/**\n\t\tRead a 32-bit signed integer.\n\n\t\tEndianness is specified by the `bigEndian` property.\n\t**/\n\tpublic function readInt32():Int {\n\t\tvar ch1 = readByte();\n\t\tvar ch2 = readByte();\n\t\tvar ch3 = readByte();\n\t\tvar ch4 = readByte();\n\t\t#if (php || python)\n\t\t// php will overflow integers.  Convert them back to signed 32-bit ints.\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\tif (n & 0x80000000 != 0)\n\t\t\treturn (n | 0x80000000);\n\t\telse\n\t\t\treturn n;\n\t\t#elseif lua\n\t\tvar n = bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\treturn lua.Boot.clampInt32(n);\n\t\t#else\n\t\treturn bigEndian ? ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24) : ch1 | (ch2 << 8) | (ch3 << 16) | (ch4 << 24);\n\t\t#end\n\t}\n\n\t/**\n\t\tRead and `len` bytes as a string.\n\t**/\n\tpublic function readString(len:Int, ?encoding:Encoding):String {\n\t\tvar b = Bytes.alloc(len);\n\t\treadFullBytes(b, 0, len);\n\t\t#if neko\n\t\treturn neko.Lib.stringReference(b);\n\t\t#else\n\t\treturn b.getString(0, len, encoding);\n\t\t#end\n\t}\n\n\t#if neko\n\tstatic var _float_of_bytes = neko.Lib.load(\"std\", \"float_of_bytes\", 2);\n\tstatic var _double_of_bytes = neko.Lib.load(\"std\", \"double_of_bytes\", 2);\n\n\tstatic function __init__()\n\t\tuntyped {\n\t\t\tInput.prototype.bigEndian = false;\n\t\t}\n\t#end\n\n\t#if (flash || js || python)\n\tfunction getDoubleSig(bytes:Array<Int>) {\n\t\treturn (((bytes[1] & 0xF) << 16) | (bytes[2] << 8) | bytes[3]) * 4294967296.\n\t\t\t+ (bytes[4] >> 7) * 2147483648\n\t\t\t+ (((bytes[4] & 0x7F) << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7]);\n\t}\n\t#end\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThe possible IO errors that can occur\n**/\n#if eval\n@:keep\n#end\nenum Error {\n\t/** The IO is set into nonblocking mode and some data cannot be read or written **/\n\tBlocked;\n\n\t/** An integer value is outside its allowed range **/\n\tOverflow;\n\n\t/** An operation on Bytes is outside of its valid range **/\n\tOutsideBounds;\n\n\t/** Other errors **/\n\tCustom(e:Dynamic);\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.io;\n\n/**\n\tThis exception is raised when reading while data is no longer available in the `haxe.io.Input`.\n**/\nclass Eof {\n\tpublic function new() {}\n\n\t@:ifFeature(\"haxe.io.Eof.*\")\n\tfunction toString() {\n\t\treturn \"Eof\";\n\t}\n}\n","package haxe.ds;\n\n#if !js\nextern class StringMap<T> implements haxe.Constraints.IMap<String, T> {\n  public function new(): Void;\n  public function set(key: String, value: T): Void;\n  public function get(key: String): Null<T>;\n  public function exists(key: String): Bool;\n  public function remove(key: String): Bool;\n  public function keys(): Iterator<String>;\n  public function iterator(): Iterator<T>;\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n  public function copy(): StringMap<T>;\n  public function toString(): String;\n  public function clear(): Void;\n}\n#else\nclass StringMap<T> extends genes.util.EsMap<String, T> implements haxe.Constraints.IMap<String, T> {\n  public inline function copy(): StringMap<T> {\n    var copied = new genes.util.EsMap();\n    copied.inst = new js.lib.Map(inst);\n    return cast copied;\n  }\n\n  @:runtime public inline function keyValueIterator(): KeyValueIterator<String,\n    T>\n    return new haxe.iterators.MapKeyValueIterator(this);\n}\n#end\n","package haxe;\n\nimport js.Syntax;\nimport js.lib.Error;\nimport haxe.CallStack.StackItem;\n\n// https://v8.dev/docs/stack-trace-api\n@:native(\"Error\")\nprivate extern class V8Error {\n\tstatic var prepareStackTrace:(error:Error, structuredStackTrace:Array<V8CallSite>)->Any;\n}\n\ntypedef V8CallSite = {\n\tfunction getFunctionName():String;\n\tfunction getFileName():String;\n\tfunction getLineNumber():Int;\n\tfunction getColumnNumber():Int;\n}\n\n/**\n\tDo not use manually.\n**/\n@:dox(hide)\n@:noCompletion\n@:allow(haxe.Exception)\nclass NativeStackTrace {\n\tstatic var lastError:Error;\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:V8CallSite->V8CallSite;\n\n\t@:ifFeature('haxe.NativeStackTrace.exceptionStack')\n\tstatic public inline function saveStack(e:Error):Void {\n\t\tlastError = e;\n\t}\n\n\tstatic public function callStack():Any {\n\t\tvar e:Null<Error> = new Error('');\n\t\tvar stack = tryHaxeStack(e);\n\t\t//Internet Explorer provides call stack only if error was thrown\n\t\tif(Syntax.typeof(stack) == \"undefined\") {\n\t\t\ttry throw e catch(e:Exception) {}\n\t\t\tstack = e.stack;\n\t\t}\n\t\treturn normalize(stack, 2);\n\t}\n\n\tstatic public function exceptionStack():Any {\n\t\treturn normalize(tryHaxeStack(lastError));\n\t}\n\n\tstatic public function toHaxe(s:Null<Any>, skip:Int = 0):Array<StackItem> {\n\t\tif (s == null) {\n\t\t\treturn [];\n\t\t} else if (Syntax.typeof(s) == \"string\") {\n\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\tvar stack:Array<String> = (s:String).split(\"\\n\");\n\t\t\tif (stack[0] == \"Error\")\n\t\t\t\tstack.shift();\n\t\t\tvar m = [];\n\t\t\tfor (i in 0...stack.length) {\n\t\t\t\tif(skip > i) continue;\n\t\t\t\tvar line = stack[i];\n\t\t\t\tvar matched:Null<Array<String>> = Syntax.code('{0}.match(/^    at ([A-Za-z0-9_. ]+) \\\\(([^)]+):([0-9]+):([0-9]+)\\\\)$/)', line);\n\t\t\t\tif (matched != null) {\n\t\t\t\t\tvar path = matched[1].split(\".\");\n\t\t\t\t\tif(path[0] == \"$hxClasses\") {\n\t\t\t\t\t\tpath.shift();\n\t\t\t\t\t}\n\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\tvar file = matched[2];\n\t\t\t\t\tvar line = Std.parseInt(matched[3]);\n\t\t\t\t\tvar column = Std.parseInt(matched[4]);\n\t\t\t\t\tm.push(FilePos(meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"), meth), file, line,\n\t\t\t\t\t\tcolumn));\n\t\t\t\t} else {\n\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m;\n\t\t} else if(skip > 0 && Syntax.code('Array.isArray({0})', s)) {\n\t\t\treturn (s:Array<StackItem>).slice(skip);\n\t\t} else {\n\t\t\treturn cast s;\n\t\t}\n\t}\n\n\tstatic function tryHaxeStack(e:Null<Error>):Any {\n\t\tif (e == null) {\n\t\t\treturn [];\n\t\t}\n\t\t// https://v8.dev/docs/stack-trace-api\n\t\tvar oldValue = V8Error.prepareStackTrace;\n\t\tV8Error.prepareStackTrace = prepareHxStackTrace;\n\t\tvar stack = e.stack;\n\t\tV8Error.prepareStackTrace = oldValue;\n\t\treturn stack;\n\t}\n\n\tstatic function prepareHxStackTrace(e:Error, callsites:Array<V8CallSite>):Any {\n\t\tvar stack = [];\n\t\tfor (site in callsites) {\n\t\t\tif (wrapCallSite != null)\n\t\t\t\tsite = wrapCallSite(site);\n\t\t\tvar method = null;\n\t\t\tvar fullName = site.getFunctionName();\n\t\t\tif (fullName != null) {\n\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tvar className = fullName.substring(0, idx);\n\t\t\t\t\tvar methodName = fullName.substring(idx + 1);\n\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t} else {\n\t\t\t\t\tmethod = Method(null, fullName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fileName = site.getFileName();\n\t\t\tvar fileAddr = fileName == null ? -1 : fileName.indexOf(\"file:\");\n\t\t\tif (wrapCallSite != null && fileAddr > 0)\n\t\t\t\tfileName = fileName.substring(fileAddr + 6);\n\t\t\tstack.push(FilePos(method, fileName, site.getLineNumber(), site.getColumnNumber()));\n\t\t}\n\t\treturn stack;\n\t}\n\n\tstatic function normalize(stack:Any, skipItems:Int = 0):Any {\n\t\tif(Syntax.code('Array.isArray({0})', stack) && skipItems > 0) {\n\t\t\treturn (stack:Array<StackItem>).slice(skipItems);\n\t\t} else if(Syntax.typeof(stack) == \"string\") {\n\t\t\tswitch (stack:String).substring(0, 6) {\n\t\t\t\tcase 'Error:' | 'Error\\n': skipItems += 1;\n\t\t\t\tcase _:\n\t\t\t}\n\t\t\treturn skipLines(stack, skipItems);\n\t\t} else {\n\t\t\t//nothing we can do\n\t\t\treturn stack;\n\t\t}\n\t}\n\n\tstatic function skipLines(stack:String, skip:Int, pos:Int = 0):String {\n\t\treturn if(skip > 0) {\n\t\t\tpos = stack.indexOf('\\n', pos);\n\t\t\treturn pos < 0 ? '' : skipLines(stack, --skip, pos + 1);\n\t\t} else {\n\t\t\treturn stack.substring(pos);\n\t\t}\n\t}\n}","package haxe;\n\nimport js.lib.Error;\n\n@:coreApi\nclass Exception extends NativeException {\n\tpublic var message(get,never):String;\n\tpublic var stack(get,never):CallStack;\n\tpublic var previous(get,never):Null<Exception>;\n\tpublic var native(get,never):Any;\n\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\t@:noCompletion var __skipStack:Int;\n\t@:noCompletion var __exceptionStack(get,set):Null<CallStack>;\n\t@:noCompletion var __nativeException:Any;\n\t@:noCompletion var __previousException:Null<Exception>;\n\n\tstatic function caught(value:Any):Exception {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn value;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn new Exception((cast value:Error).message, null, value);\n\t\t} else {\n\t\t\treturn new ValueException(value, null, value);\n\t\t}\n\t}\n\n\tstatic function thrown(value:Any):Any {\n\t\tif(Std.isOfType(value, Exception)) {\n\t\t\treturn (value:Exception).native;\n\t\t} else if(Std.isOfType(value, Error)) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tvar e = new ValueException(value);\n\t\t\tuntyped __feature__(\"haxe.Exception.get_stack\", e.__shiftStack());\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tpublic function new(message:String, ?previous:Exception, ?native:Any) {\n\t\tsuper(message);\n\t\t(cast this).message = message;\n\t\t__previousException = previous;\n\t\t__nativeException = native != null ? native : this;\n\t\tuntyped __feature__('haxe.Exception.stack', {\n\t\t\t__skipStack = 0;\n\t\t\tvar old = js.Syntax.code('Error.prepareStackTrace');\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = function(e) { return e.stack; }');\n\t\t\tif(Std.isOfType(native, Error)) {\n\t\t\t\t(cast this).stack = native.stack;\n\t\t\t} else {\n\t\t\t\tvar e:Error = null;\n\t\t\t\tif ((cast Error).captureStackTrace) {\n\t\t\t\t\t(cast Error).captureStackTrace(this, Exception);\n\t\t\t\t\te = cast this;\n\t\t\t\t} else {\n\t\t\t\t\te = new Error();\n\t\t\t\t\t//Internet Explorer provides call stack only if error was thrown\n\t\t\t\t\tif(js.Syntax.typeof(e.stack) == \"undefined\") {\n\t\t\t\t\t\tjs.Syntax.code('try { throw {0}; } catch(_) {}', e);\n\t\t\t\t\t\t__skipStack++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(cast this).stack = e.stack;\n\t\t\t}\n\t\t\tjs.Syntax.code('Error.prepareStackTrace = {0}', old);\n\t\t});\n\t}\n\n\tfunction unwrap():Any {\n\t\treturn __nativeException;\n\t}\n\n\tpublic function toString():String {\n\t\treturn message;\n\t}\n\n\tpublic function details():String {\n\t\treturn inline CallStack.exceptionToString(this);\n\t}\n\n\t@:noCompletion\n\t@:ifFeature(\"haxe.Exception.get_stack\")\n\tinline function __shiftStack():Void {\n\t\t__skipStack++;\n\t}\n\n\tfunction get_message():String {\n\t\treturn (cast this:Error).message;\n\t}\n\n\tfunction get_previous():Null<Exception> {\n\t\treturn __previousException;\n\t}\n\n\tfinal function get_native():Any {\n\t\treturn __nativeException;\n\t}\n\n\tfunction get_stack():CallStack {\n\t\treturn switch __exceptionStack {\n\t\t\tcase null:\n\t\t\t\t__exceptionStack = NativeStackTrace.toHaxe(NativeStackTrace.normalize((cast this).stack), __skipStack);\n\t\t\tcase s: s;\n\t\t}\n\t}\n\n\t@:noCompletion\n\tfunction setProperty(name:String, value:Any):Void {\n\t\ttry {\n\t\t\tjs.lib.Object.defineProperty(this, name, {value:value});\n\t\t} catch(e:Exception) {\n\t\t\tjs.Syntax.code('{0}[{1}] = {2}', this, name, value);\n\t\t}\n\t}\n\n\t@:noCompletion\n\tinline function get___exceptionStack():CallStack {\n\t\treturn (cast this).__exceptionStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___exceptionStack(value:CallStack):CallStack {\n\t\tsetProperty('__exceptionStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___skipStack():Int {\n\t\treturn (cast this).__skipStack;\n\t}\n\n\t@:noCompletion\n\tinline function set___skipStack(value:Int):Int {\n\t\tsetProperty('__skipStack', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___nativeException():Any {\n\t\treturn (cast this).__nativeException;\n\t}\n\n\t@:noCompletion\n\tinline function set___nativeException(value:Any):Any {\n\t\tsetProperty('__nativeException', value);\n\t\treturn value;\n\t}\n\n\t@:noCompletion\n\tinline function get___previousException():Null<Exception> {\n\t\treturn (cast this).__previousException;\n\t}\n\n\t@:noCompletion\n\tinline function set___previousException(value:Null<Exception>):Null<Exception> {\n\t\tsetProperty('__previousException', value);\n\t\treturn value;\n\t}\n}\n\n@:dox(hide)\n@:noCompletion\n@:native('Error')\nprivate extern class NativeException {\n\t// private var message:String; //redefined in haxe.Exception\n\t// private var stack(default, null):String; //redefined in haxe.Exception\n\n\tfunction new(?message:String);\n}\n","package genes;\n\nimport js.lib.Object;\nimport js.Syntax;\n\nclass Register {\n  @:keep @:native(\"$global\")\n  public static final _global = js.Syntax.code('typeof window != \"undefined\" ? window : typeof global != \"undefined\" ? global : typeof self != \"undefined\" ? self : this');\n\n  static final globals = {}\n\n  @:keep public static function global(name) {\n    return untyped globals[name] ? globals[name] : globals[name] = {};\n  }\n\n  @:keep public static function createStatic<T>(obj: {}, name: String,\n      get: () -> T) {\n    var value: T = null;\n    inline function init() {\n      if (get != null) {\n        value = get();\n        get = null;\n      }\n    }\n    Object.defineProperty(obj, name, {\n      enumerable: true,\n      get: () -> {\n        init();\n        return value;\n      },\n      set: v -> {\n        init();\n        value = v;\n      }\n    });\n  }\n\n  @:keep public static function iter<T>(a: Array<T>): Iterator<T> {\n    return untyped if (!Array.isArray(a))\n      js.Syntax.code('a.iterator()')\n    else untyped {\n      cur: 0,\n      arr: a,\n      hasNext: function() {\n        return __this__.cur < __this__.arr.length;\n      },\n      next: function() {\n        return __this__.arr[__this__.cur++];\n      }\n    }\n  }\n\n  @:keep public static function extend(superClass) {\n    Syntax.code('\n      function res() {\n        this.new.apply(this, arguments)\n      }\n      Object.setPrototypeOf(res.prototype, superClass.prototype)\n      return res\n    ');\n  }\n\n  @:keep public static function inherits(resolve, defer = false) {\n    Syntax.code('\n      function res() {\n        if (defer && resolve && res.__init__) res.__init__()\n        this.new.apply(this, arguments)\n      }\n      if (!defer) {\n        if (resolve && resolve.__init__) {\n          defer = true\n          res.__init__ = () => {\n            resolve.__init__()\n            Object.setPrototypeOf(res.prototype, resolve.prototype)\n            res.__init__ = undefined\n          } \n        } else if (resolve) {\n          Object.setPrototypeOf(res.prototype, resolve.prototype)\n        }\n      } else {\n        res.__init__ = () => {\n          const superClass = resolve()\n          if (superClass.__init__) superClass.__init__()\n          Object.setPrototypeOf(res.prototype, superClass.prototype)\n          res.__init__ = undefined\n        } \n      }\n      return res\n    ');\n  }\n\n  static var fid = 0;\n\n  @:keep public static function bind(o: Dynamic, m: Dynamic) {\n    if (m == null)\n      return null;\n    if (m.__id__ == null)\n      m.__id__ = fid++;\n    var f = null;\n    if (o.hx__closures__ == null)\n      o.hx__closures__ = {}\n    else\n      f = o.hx__closures__[m.__id__];\n    if (f == null) {\n      f = m.bind(o);\n      o.hx__closures__[m.__id__] = f;\n    }\n    return f;\n  }\n}\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node;\r\n\r\nimport haxe.DynamicAccess;\r\nimport haxe.extern.EitherType;\r\nimport js.node.Buffer;\r\nimport js.node.fs.FSWatcher;\r\nimport js.node.fs.ReadStream;\r\nimport js.node.fs.Stats;\r\nimport js.node.fs.WriteStream;\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n/**\r\n\tMost FS functions now support passing `String` and `Buffer`.\r\n\tThis type is used for path arguments and allows passing either of those.\r\n**/\r\ntypedef FsPath = EitherType<String, Buffer>;\r\n\r\n/**\r\n\tPossible options for `Fs.watchFile`.\r\n**/\r\ntypedef FsWatchFileOptions = {\r\n\t/**\r\n\t\tindicates whether the process should continue to run as long as files are being watched\r\n\t\tdefault: true\r\n\t**/\r\n\t@:optional var persistent:Bool;\r\n\r\n\t/**\r\n\t\tindicates how often the target should be polled, in milliseconds\r\n\t\tdefault: 5007\r\n\t**/\r\n\t@:optional var interval:Int;\r\n}\r\n\r\n/**\r\n\tThe `mode` argument used by `Fs.open` and related functions\r\n\tcan be either an integer or a string with octal number.\r\n**/\r\ntypedef FsMode = EitherType<Int, String>;\r\n\r\n/**\r\n\tPossible options for `Fs.writeFile` and `Fs.appendFile`.\r\n**/\r\ntypedef FsWriteFileOptions = {\r\n\t/**\r\n\t\tEncoding for writing strings.\r\n\t\tDefaults to 'utf8'.\r\n\t\tIgnored if data is a buffer\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tdefault = 438 (aka 0666 in Octal)\r\n\t**/\r\n\t@:optional var mode:FsMode;\r\n\r\n\t/**\r\n\t\tdefault: 'w' for `Fs.writeFile`, 'a' for `Fs.appendFile`\r\n\t**/\r\n\t@:optional var flag:FsOpenFlag;\r\n}\r\n\r\n/**\r\n\tDefaults:\r\n\t{ flags: 'r',\r\n\t  encoding: null,\r\n\t  fd: null,\r\n\t  mode: 0666,\r\n\t  autoClose: true\r\n\t}\r\n**/\r\n/**\r\n\tOptions for `Fs.createReadStream`.\r\n**/\r\ntypedef FsCreateReadStreamOptions = {\r\n\t/**\r\n\t\tdefault: 'r'\r\n\t**/\r\n\t@:optional var flags:FsOpenFlag;\r\n\r\n\t/**\r\n\t\tcan be 'utf8', 'ascii', or 'base64'.\r\n\t\tdefault: null\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tdefault: null\r\n\t**/\r\n\t@:optional var fd:Int;\r\n\r\n\t/**\r\n\t\tdefault: 0666\r\n\t**/\r\n\t@:optional var mode:FsMode;\r\n\r\n\t/**\r\n\t\tIf autoClose is false, then the file descriptor won't be closed, even if there's an error.\r\n\t\tIt is your responsiblity to close it and make sure there's no file descriptor leak.\r\n\r\n\t\tIf autoClose is set to true (default behavior), on error or end the file\r\n\t\tdescriptor will be closed automatically.\r\n\t**/\r\n\t@:optional var autoClose:Bool;\r\n\r\n\t/**\r\n\t\tStart of the range of bytes to read\r\n\t**/\r\n\t@:optional var start:Int;\r\n\r\n\t/**\r\n\t\tEnd of the range of bytes to read\r\n\t**/\r\n\t@:optional var end:Int;\r\n};\r\n\r\n/**\r\n\tOptions for `Fs.createWriteStream`.\r\n**/\r\ntypedef FsCreateWriteStreamOptions = {\r\n\t/**\r\n\t\tdefault: 'w'\r\n\t**/\r\n\t@:optional var flags:FsOpenFlag;\r\n\r\n\t/**\r\n\t\tdefault: null\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tdefault: 0666\r\n\t**/\r\n\t@:optional var mode:FsMode;\r\n\r\n\t/**\r\n\t\tposition to write data the beginning of the file.\r\n\t**/\r\n\t@:optional var start:Int;\r\n}\r\n\r\n/**\r\n\tEnumeration of possible symlink types\r\n**/\r\n@:enum abstract SymlinkType(String) from String to String {\r\n\tvar Dir = \"dir\";\r\n\tvar File = \"file\";\r\n\tvar Junction = \"junction\";\r\n}\r\n\r\n/**\r\n\tEnumeration of possible flags for opening file.\r\n\r\n\tThe exclusive flag 'x' (O_EXCL flag in open(2)) ensures that path is newly created.\r\n\tOn POSIX systems, path is considered to exist even if it is a symlink to a non-existent file.\r\n\tThe exclusive flag may or may not work with network file systems.\r\n\r\n\tOn Linux, positional writes don't work when the file is opened in append mode.\r\n\tThe kernel ignores the position argument and always appends the data to the end of the file.\r\n**/\r\n@:enum abstract FsOpenFlag(String) from String to String {\r\n\t/**\r\n\t\tOpen file for reading.\r\n\t\tAn exception occurs if the file does not exist.\r\n\t**/\r\n\tvar Read = \"r\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and writing.\r\n\t\tAn exception occurs if the file does not exist.\r\n\t**/\r\n\tvar ReadWrite = \"r+\";\r\n\r\n\t/**\r\n\t\tOpen file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.\r\n\r\n\t\tThis is primarily useful for opening files on NFS mounts as it allows you to skip the potentially stale local cache.\r\n\t\tIt has a very real impact on I/O performance so don't use this flag unless you need it.\r\n\r\n\t\tNote that this doesn't turn `Fs.open` into a synchronous blocking call.\r\n\t\tIf that's what you want then you should be using `Fs.openSync`\r\n\t**/\r\n\tvar ReadSync = \"rs\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and writing, telling the OS to open it synchronously.\r\n\t\tSee notes for `ReadSync` about using this with caution.\r\n\t**/\r\n\tvar ReadWriteSync = \"rs+\";\r\n\r\n\t/**\r\n\t\tOpen file for writing.\r\n\t\tThe file is created (if it does not exist) or truncated (if it exists).\r\n\t**/\r\n\tvar WriteCreate = \"w\";\r\n\r\n\t/**\r\n\t\tLike `WriteCreate` but fails if path exists.\r\n\t**/\r\n\tvar WriteCheck = \"wx\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and writing.\r\n\t\tThe file is created (if it does not exist) or truncated (if it exists).\r\n\t**/\r\n\tvar WriteReadCreate = \"w+\";\r\n\r\n\t/**\r\n\t\tLike `WriteReadCreate` but fails if path exists.\r\n\t**/\r\n\tvar WriteReadCheck = \"wx+\";\r\n\r\n\t/**\r\n\t\tOpen file for appending.\r\n\t\tThe file is created if it does not exist.\r\n\t**/\r\n\tvar AppendCreate = \"a\";\r\n\r\n\t/**\r\n\t\tLike `AppendCreate` but fails if path exists.\r\n\t**/\r\n\tvar AppendCheck = \"ax\";\r\n\r\n\t/**\r\n\t\tOpen file for reading and appending.\r\n\t\tThe file is created if it does not exist.\r\n\t */\r\n\tvar AppendReadCreate = \"a+\";\r\n\r\n\t/**\r\n\t\tLike `AppendReadCreate` but fails if path exists.\r\n\t**/\r\n\tvar AppendReadCheck = \"ax+\";\r\n}\r\n\r\n/**\r\n\tConstants for use in `Fs` module.\r\n\r\n\tNote: Not every constant will be available on every operating system.\r\n**/\r\ntypedef FsConstants = {\r\n\t/**\r\n\t\tFlag indicating that the file is visible to the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar F_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file can be read by the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar R_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file can be written by the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar W_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file can be executed by the calling process.\r\n\t\tMeant for use with `Fs.access`.\r\n\t**/\r\n\tvar X_OK:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open a file for read-only access.\r\n\t**/\r\n\tvar O_RDONLY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open a file for write-only access.\r\n\t**/\r\n\tvar O_WRONLY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open a file for read-write access.\r\n\t**/\r\n\tvar O_RDWR:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to create the file if it does not already exist.\r\n\t**/\r\n\tvar O_CREAT:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists.\r\n\t**/\r\n\tvar O_EXCL:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that if path identifies a terminal device, opening the path shall not cause that terminal to become the controlling terminal for the process (if the process does not already have one).\r\n\t**/\r\n\tvar O_NOCTTY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero.\r\n\t**/\r\n\tvar O_TRUNC:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that data will be appended to the end of the file.\r\n\t**/\r\n\tvar O_APPEND:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the open should fail if the path is not a directory.\r\n\t**/\r\n\tvar O_DIRECTORY:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating reading accesses to the file system will no longer result in an update to the atime information associated with the file. This flag is available on Linux operating systems only.\r\n\t**/\r\n\tvar O_NOATIME:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the open should fail if the path is a symbolic link.\r\n\t**/\r\n\tvar O_NOFOLLOW:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating that the file is opened for synchronous I/O.\r\n\t**/\r\n\tvar O_SYNC:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open the symbolic link itself rather than the resource it is pointing to.\r\n\t**/\r\n\tvar O_SYMLINK:Int;\r\n\r\n\t/**\r\n\t\tWhen set, an attempt will be made to minimize caching effects of file I/O.\r\n\t**/\r\n\tvar O_DIRECT:Int;\r\n\r\n\t/**\r\n\t\tFlag indicating to open the file in nonblocking mode when possible.\r\n\t**/\r\n\tvar O_NONBLOCK:Int;\r\n\r\n\t/**\r\n\t\tBit mask used to extract the file type code.\r\n\t**/\r\n\tvar S_IFMT:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a regular file.\r\n\t**/\r\n\tvar S_IFREG:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a directory.\r\n\t**/\r\n\tvar S_IFDIR:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a character-oriented device file.\r\n\t**/\r\n\tvar S_IFCHR:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a block-oriented device file.\r\n\t**/\r\n\tvar S_IFBLK:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a FIFO/pipe.\r\n\t**/\r\n\tvar S_IFIFO:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a symbolic link.\r\n\t**/\r\n\tvar S_IFLNK:Int;\r\n\r\n\t/**\r\n\t\tFile type constant for a socket.\r\n\t**/\r\n\tvar S_IFSOCK:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable, writable and executable by owner.\r\n\t**/\r\n\tvar S_IRWXU:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable by owner.\r\n\t**/\r\n\tvar S_IRUSR:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating writable by owner.\r\n\t**/\r\n\tvar S_IWUSR:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating executable by owner.\r\n\t**/\r\n\tvar S_IXUSR:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable, writable and executable by group.\r\n\t**/\r\n\tvar S_IRWXG:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable by group.\r\n\t**/\r\n\tvar S_IRGRP:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating writable by group.\r\n\t**/\r\n\tvar S_IWGRP:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating executable by group.\r\n\t**/\r\n\tvar S_IXGRP:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable, writable and executable by others.\r\n\t**/\r\n\tvar S_IRWXO:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating readable by others.\r\n\t**/\r\n\tvar S_IROTH:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating writable by others.\r\n\t**/\r\n\tvar S_IWOTH:Int;\r\n\r\n\t/**\r\n\t\tFile mode indicating executable by others.\r\n\t**/\r\n\tvar S_IXOTH:Int;\r\n}\r\n\r\n/**\r\n\tFile I/O is provided by simple wrappers around standard POSIX functions.\r\n\tAll the methods have asynchronous and synchronous forms.\r\n\r\n\tThe asynchronous form always take a completion callback as its last argument.\r\n\tThe arguments passed to the completion callback depend on the method,\r\n\tbut the first argument is always reserved for an exception.\r\n\r\n\tIf the operation was completed successfully, then the first argument will be null.\r\n\r\n\tWhen using the synchronous form any exceptions are immediately thrown.\r\n\tYou can use try/catch to handle exceptions or allow them to bubble up.\r\n**/\r\n@:jsRequire(\"fs\")\r\nextern class Fs {\r\n\t/**\r\n\t\tAn object containing commonly used constants for file system operations.\r\n\t**/\r\n\tstatic var constants(default, null):FsConstants;\r\n\r\n\t/**\r\n\t\tAsynchronous rename(2).\r\n\t**/\r\n\tstatic function rename(oldPath:FsPath, newPath:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous rename(2).\r\n\t**/\r\n\tstatic function renameSync(oldPath:FsPath, newPath:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous ftruncate(2).\r\n\t**/\r\n\tstatic function ftruncate(fd:Int, len:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous ftruncate(2).\r\n\t**/\r\n\tstatic function ftruncateSync(fd:Int, len:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous truncate(2).\r\n\t**/\r\n\tstatic function truncate(path:FsPath, len:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous truncate(2).\r\n\t**/\r\n\tstatic function truncateSync(path:FsPath, len:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous chown(2).\r\n\t**/\r\n\tstatic function chown(path:FsPath, uid:Int, gid:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous chown(2).\r\n\t**/\r\n\tstatic function chownSync(path:FsPath, uid:Int, gid:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fchown(2).\r\n\t**/\r\n\tstatic function fchown(fd:Int, uid:Int, gid:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous fchown(2).\r\n\t**/\r\n\tstatic function fchownSync(fd:Int, uid:Int, gid:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous lchown(2).\r\n\t**/\r\n\tstatic function lchown(path:FsPath, uid:Int, gid:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous lchown(2).\r\n\t**/\r\n\tstatic function lchownSync(path:FsPath, uid:Int, gid:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous chmod(2).\r\n\t**/\r\n\tstatic function chmod(path:FsPath, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous chmod(2).\r\n\t**/\r\n\tstatic function chmodSync(path:FsPath, mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fchmod(2).\r\n\t**/\r\n\tstatic function fchmod(fd:Int, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous fchmod(2).\r\n\t**/\r\n\tstatic function fchmodSync(fd:Int, mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous lchmod(2).\r\n\t\tOnly available on Mac OS X.\r\n\t**/\r\n\tstatic function lchmod(path:FsPath, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous lchmod(2).\r\n\t**/\r\n\tstatic function lchmodSync(path:FsPath, mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous stat(2).\r\n\t**/\r\n\tstatic function stat(path:FsPath, callback:Error->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous lstat(2).\r\n\r\n\t\tlstat() is identical to stat(), except that if path is a symbolic link,\r\n\t\tthen the link itself is stat-ed, not the file that it refers to.\r\n\t**/\r\n\tstatic function lstat(path:FsPath, callback:Error->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fstat(2).\r\n\r\n\t\tfstat() is identical to stat(), except that the file to be stat-ed\r\n\t\tis specified by the file descriptor fd.\r\n\t**/\r\n\tstatic function fstat(fd:Int, callback:Error->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous stat(2).\r\n\t**/\r\n\tstatic function statSync(path:FsPath):Stats;\r\n\r\n\t/**\r\n\t\tSynchronous lstat(2).\r\n\t**/\r\n\tstatic function lstatSync(path:FsPath):Stats;\r\n\r\n\t/**\r\n\t\tSynchronous fstat(2).\r\n\t**/\r\n\tstatic function fstatSync(fd:Int):Stats;\r\n\r\n\t/**\r\n\t\tAsynchronous link(2).\r\n\t**/\r\n\tstatic function link(srcpath:FsPath, dstpath:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous link(2).\r\n\t**/\r\n\tstatic function linkSync(srcpath:FsPath, dstpath:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous symlink(2).\r\n\r\n\t\tThe `type` argument can be set to 'dir', 'file', or 'junction' (default is 'file')\r\n\t\tand is only available on Windows (ignored on other platforms). Note that Windows junction\r\n\t\tpoints require the destination path to be absolute. When using 'junction', the destination\r\n\t\targument will automatically be normalized to absolute path.\r\n\t**/\r\n\t@:overload(function(srcpath:FsPath, dstpath:FsPath, callback:Error->Void):Void {})\r\n\tstatic function symlink(srcpath:FsPath, dstpath:FsPath, type:SymlinkType, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous symlink(2).\r\n\t**/\r\n\t@:overload(function(srcpath:FsPath, dstpath:FsPath):Void {})\r\n\tstatic function symlinkSync(srcpath:FsPath, dstpath:FsPath, type:SymlinkType):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous readlink(2).\r\n\t**/\r\n\tstatic function readlink(path:FsPath, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous readlink(2).\r\n\t\tReturns the symbolic link's string value.\r\n\t**/\r\n\tstatic function readlinkSync(path:FsPath):String;\r\n\r\n\t/**\r\n\t\tAsynchronous realpath(2).\r\n\r\n\t\tThe callback gets two arguments (err, resolvedPath).\r\n\r\n\t\tMay use process.cwd to resolve relative paths.\r\n\r\n\t\t`cache` is an object literal of mapped paths that can be used to force a specific path resolution\r\n\t\tor avoid additional `stat` calls for known real paths.\r\n\t**/\r\n\t@:overload(function(path:FsPath, callback:Error->String->Void):Void {})\r\n\tstatic function realpath(path:FsPath, cache:DynamicAccess<String>, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous realpath(2).\r\n\t\tReturns the resolved path.\r\n\t**/\r\n\t@:overload(function(path:FsPath):String {})\r\n\tstatic function realpathSync(path:FsPath, cache:DynamicAccess<String>):String;\r\n\r\n\t/**\r\n\t\tAsynchronous unlink(2).\r\n\t**/\r\n\tstatic function unlink(path:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous unlink(2).\r\n\t**/\r\n\tstatic function unlinkSync(path:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous rmdir(2).\r\n\t**/\r\n\tstatic function rmdir(path:FsPath, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous rmdir(2).\r\n\t**/\r\n\tstatic function rmdirSync(path:FsPath):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous mkdir(2).\r\n\t\t`mode` defaults to 0777.\r\n\t**/\r\n\t@:overload(function(path:FsPath, callback:Error->Void):Void {})\r\n\tstatic function mkdir(path:FsPath, mode:FsMode, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous mkdir(2).\r\n\t**/\r\n\tstatic function mkdirSync(path:FsPath, ?mode:FsMode):Void;\r\n\r\n\t/**\r\n\t\tCreates a unique temporary directory.\r\n\r\n\t\tGenerates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\r\n\r\n\t\tThe created folder path is passed as a string to the `callback`'s second parameter.\r\n\t**/\r\n\tstatic function mkdtemp(prefix:String, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tThe synchronous version of `mkdtemp`.\r\n\r\n\t\tReturns the created folder path.\r\n\t**/\r\n\tstatic function mkdtempSync(template:String):String;\r\n\r\n\t/**\r\n\t\tAsynchronous readdir(3).\r\n\t\tReads the contents of a directory.\r\n\r\n\t\tThe callback gets two arguments (err, files) where files is an array of the\r\n\t\tnames of the files in the directory excluding '.' and '..'.\r\n\t**/\r\n\tstatic function readdir(path:FsPath, callback:Error->Array<String>->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous readdir(3).\r\n\t\tReturns an array of filenames excluding '.' and '..'.\r\n\t**/\r\n\tstatic function readdirSync(path:FsPath):Array<String>;\r\n\r\n\t/**\r\n\t\tAsynchronous close(2).\r\n\t**/\r\n\tstatic function close(fd:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous close(2).\r\n\t**/\r\n\tstatic function closeSync(fd:Int):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous file open. See open(2).\r\n\r\n\t\tSee `FsOpenFlag` for description of possible `flags`.\r\n\r\n\t\t`mode` sets the file mode (permission and sticky bits), but only if the file was created.\r\n\t\tIt defaults to 0666, readable and writeable.\r\n\r\n\t\tThe `callback` gets two arguments (err, fd).\r\n\t**/\r\n\t@:overload(function(path:FsPath, flags:FsOpenFlag, callback:Error->Int->Void):Void {})\r\n\tstatic function open(path:FsPath, flags:FsOpenFlag, mode:FsMode, callback:Error->Int->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of open().\r\n\t**/\r\n\t@:overload(function(path:FsPath, flags:FsOpenFlag):Int {})\r\n\tstatic function openSync(path:FsPath, flags:FsOpenFlag, mode:FsMode):Int;\r\n\r\n\t/**\r\n\t\tChange file timestamps of the file referenced by the supplied path.\r\n\t**/\r\n\tstatic function utimes(path:FsPath, atime:Date, mtime:Date, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tChange file timestamps of the file referenced by the supplied path.\r\n\t**/\r\n\tstatic function utimesSync(path:FsPath, atime:Date, mtime:Date):Void;\r\n\r\n\t/**\r\n\t\tChange the file timestamps of a file referenced by the supplied file descriptor.\r\n\t**/\r\n\tstatic function futimes(fd:Int, atime:Date, mtime:Date, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tChange the file timestamps of a file referenced by the supplied file descriptor.\r\n\t**/\r\n\tstatic function futimesSync(fd:Int, atime:Date, mtime:Date):Void;\r\n\r\n\t/**\r\n\t\tAsynchronous fsync(2).\r\n\t**/\r\n\tstatic function fsync(fd:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous fsync(2).\r\n\t**/\r\n\tstatic function fsyncSync(fd:Int):Void;\r\n\r\n\t/**\r\n\t\tDocumentation for the overloads with the `buffer` argument:\r\n\r\n\t\tWrite `buffer` to the file specified by `fd`.\r\n\r\n\t\t`offset` and `length` determine the part of the `buffer` to be written.\r\n\r\n\t\t`position` refers to the offset from the beginning of the file where this data should be written.\r\n\t\tIf position is null, the data will be written at the current position. See pwrite(2).\r\n\r\n\t\tThe `callback` will be given three arguments (err, written, buffer)\r\n\t\twhere `written` specifies how many bytes were written from `buffer`.\r\n\r\n\t\t---\r\n\r\n\t\tDocumentation for the overloads with the `data` argument:\r\n\r\n\t\tWrite `data` to the file specified by `fd`. If `data` is not a `Buffer` instance then\r\n\t\tthe value will be coerced to a string.\r\n\r\n\t\t`position` refers to the offset from the beginning of the file where this data should be written.\r\n\t\tIf omitted, the data will be written at the current position. See pwrite(2).\r\n\r\n\t\t`encoding` is the expected string encoding.\r\n\r\n\t\tThe `callback` will receive the arguments (err, written, string) where written specifies how many bytes\r\n\t\tthe passed string required to be written. Note that bytes written is not the same as string characters.\r\n\t\tSee `Buffer.byteLength`.\r\n\r\n\t\tUnlike when writing `buffer`, the entire string must be written. No substring may be specified.\r\n\t\tThis is because the byte offset of the resulting data may not be the same as the string offset.\r\n\r\n\t\t---\r\n\r\n\t\tCommon notes:\r\n\r\n\t\tNote that it is unsafe to use `write` multiple times on the same file without waiting for the callback.\r\n\t\tFor this scenario, `createWriteStream` is strongly recommended.\r\n\r\n\t\tOn Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position\r\n\t\targument and always appends the data to the end of the file.\r\n\t**/\r\n\t@:overload(function(fd:Int, data:Dynamic, position:Int, encoding:String, callback:Error->Int->String->Void):Void {})\r\n\t@:overload(function(fd:Int, data:Dynamic, position:Int, callback:Error->Int->String->Void):Void {})\r\n\t@:overload(function(fd:Int, data:Dynamic, callback:Error->Int->String->Void):Void {})\r\n\t@:overload(function(fd:Int, buffer:Buffer, offset:Int, length:Int, callback:Error->Int->Buffer->Void):Void {})\r\n\tstatic function write(fd:Int, buffer:Buffer, offset:Int, length:Int, position:Int, callback:Error->Int->Buffer->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `write`. Returns the number of bytes written.\r\n\t**/\r\n\t@:overload(function(fd:Int, data:Dynamic, position:Int, encoding:String):Int {})\r\n\t@:overload(function(fd:Int, data:Dynamic, ?position:Int):Int {})\r\n\tstatic function writeSync(fd:Int, buffer:Buffer, offset:Int, length:Int, ?position:Int):Int;\r\n\r\n\t/**\r\n\t\tRead data from the file specified by `fd`.\r\n\r\n\t\t`buffer` is the buffer that the data will be written to.\r\n\r\n\t\t`offset` is the offset in the `buffer` to start writing at.\r\n\r\n\t\t`length` is an integer specifying the number of bytes to read.\r\n\r\n\t\t`position` is an integer specifying where to begin reading from in the file.\r\n\t\tIf position is null, data will be read from the current file position.\r\n\r\n\t\tThe `callback` is given the three arguments, (err, bytesRead, buffer).\r\n\t**/\r\n\tstatic function read(fd:Int, buffer:Buffer, offset:Int, length:Int, position:Null<Int>, callback:Error->Int->Buffer->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `read`. Returns the number of bytes read.\r\n\t**/\r\n\tstatic function readSync(fd:Int, buffer:Buffer, offset:Int, length:Int, position:Null<Int>):Int;\r\n\r\n\t/**\r\n\t\tAsynchronously reads the entire contents of a file.\r\n\r\n\t\tThe `callback` is passed two arguments (err, data), where data is the contents of the file.\r\n\t\tIf no `encoding` is specified, then the raw buffer is returned.\r\n\r\n\t\tIf `options` is a string, then it specifies the encoding.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, callback:Error->Buffer->Void):Void {})\r\n\t@:overload(function(filename:FsPath, options:{flag:FsOpenFlag}, callback:Error->Buffer->Void):Void {})\r\n\t@:overload(function(filename:FsPath, options:String, callback:Error->String->Void):Void {})\r\n\tstatic function readFile(filename:FsPath, options:{encoding:String, ?flag:FsOpenFlag}, callback:Error->String->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `readFile`. Returns the contents of the filename.\r\n\t\tIf the `encoding` option is specified then this function returns a string. Otherwise it returns a buffer.\r\n\t**/\r\n\t@:overload(function(filename:FsPath):Buffer {})\r\n\t@:overload(function(filename:FsPath, options:{flag:FsOpenFlag}):Buffer {})\r\n\t@:overload(function(filename:FsPath, options:String):String {})\r\n\tstatic function readFileSync(filename:FsPath, options:{encoding:String, ?flag:FsOpenFlag}):String;\r\n\r\n\t/**\r\n\t\tAsynchronously writes data to a file, replacing the file if it already exists.\r\n\r\n\t\t`data` can be a string or a buffer.\r\n\r\n\t\tThe encoding option is ignored if data is a buffer. It defaults to 'utf8'.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:String, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void {})\r\n\tstatic function writeFile(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tThe synchronous version of `writeFile`.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer):Void {})\r\n\t@:overload(function(filename:FsPath, data:String):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>):Void {})\r\n\tstatic function writeFileSync(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>):Void;\r\n\r\n\t/**\r\n\t\tAsynchronously append data to a file, creating the file if it not yet exists.\r\n\t\t`data` can be a string or a buffer.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:String, callback:Error->Void):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void {})\r\n\tstatic function appendFile(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tThe synchronous version of `appendFile`.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, data:Buffer):Void {})\r\n\t@:overload(function(filename:FsPath, data:String):Void {})\r\n\t@:overload(function(filename:FsPath, data:Buffer, options:EitherType<String, FsWriteFileOptions>):Void {})\r\n\tstatic function appendFileSync(filename:FsPath, data:String, options:EitherType<String, FsWriteFileOptions>):Void;\r\n\r\n\t/**\r\n\t\tUnstable. Use `watch` instead, if possible.\r\n\r\n\t\tWatch for changes on `filename`.\r\n\t\tThe callback `listener` will be called each time the file is accessed.\r\n\r\n\t\tThe `options` if provided should be an object containing two members:\r\n\t\t\t- `persistent` indicates whether the process should continue to run as long as files are being watched.\r\n\t\t\t- `interval` indicates how often the target should be polled, in milliseconds.\r\n\t\tThe default is { persistent: true, interval: 5007 }.\r\n\r\n\t\tThe `listener` gets two arguments: the current stat object and the previous stat object.\r\n\t**/\r\n\t@:overload(function(filename:FsPath, listener:Stats->Stats->Void):Void {})\r\n\tstatic function watchFile(filename:FsPath, options:FsWatchFileOptions, listener:Stats->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tUnstable. Use `watch` instead, if possible.\r\n\r\n\t\tStop watching for changes on filename.\r\n\t\tIf `listener` is specified, only that particular listener is removed.\r\n\t\tOtherwise, all listeners are removed and you have effectively stopped watching filename.\r\n\t\tCalling `unwatchFile` with a `filename` that is not being watched is a no-op, not an error.\r\n\t**/\r\n\tstatic function unwatchFile(filename:FsPath, ?listener:Stats->Stats->Void):Void;\r\n\r\n\t/**\r\n\t\tWatch for changes on `filename`, where filename is either a file or a directory.\r\n\r\n\t\t`persistent` indicates whether the process should continue to run as long as files are being watched. Default is `true`.\r\n\r\n\t\tThe `listener` callback gets two arguments (event, filename). event is either 'rename' or 'change', and filename\r\n\t\tis the name of the file which triggered the event.\r\n\t**/\r\n\t@:overload(function(filename:FsPath):FSWatcher {})\r\n\t@:overload(function(filename:FsPath, options:{persistent:Bool, ?recursive:Bool}, listener:FSWatcherChangeType->String->Void):FSWatcher {})\r\n\tstatic function watch(filename:FsPath, listener:FSWatcherChangeType->FsPath->Void):FSWatcher;\r\n\r\n\t/**\r\n\t\tTest whether or not the given `path` exists by checking with the file system.\r\n\t\tThen call the `callback` argument with either `true` or `false`.\r\n\r\n\t\t`exists` is an anachronism and exists only for historical reasons.\r\n\t\tThere should almost never be a reason to use it in your own code.\r\n\r\n\t\tIn particular, checking if a file exists before opening it is an anti-pattern that leaves you vulnerable to race conditions:\r\n\t\tanother process may remove the file between the calls to `exists` and `open`.\r\n\r\n\t\tJust open the file and handle the error when it's not there.\r\n\t**/\r\n\t@:deprecated(\"Use Fs.stat or Fs.access instead\")\r\n\tstatic function exists(path:FsPath, callback:Bool->Void):Void;\r\n\r\n\t/**\r\n\t\tSynchronous version of `exists`.\r\n\t**/\r\n\tstatic function existsSync(path:FsPath):Bool;\r\n\r\n\t/**\r\n\t\tTests a user's permissions for the file or directory specified by `path`.\r\n\r\n\t\tThe `mode` argument is an optional integer that specifies the accessibility checks to be performed.\r\n\t\tThe following constants define the possible values of `mode`. It is possible to create a mask consisting\r\n\t\tof the bitwise OR of two or more values.\r\n\r\n\t\t* `Fs.constants.F_OK` - path is visible to the calling process. This is useful for determining if a file exists,\r\n\t\t  but says nothing about `rwx` permissions. Default if no `mode` is specified.\r\n\t\t* `Fs.constants.R_OK` - path can be read by the calling process.\r\n\t\t* `Fs.constants.W_OK` - path can be written by the calling process.\r\n\t\t* `Fs.constants.X_OK` - path can be executed by the calling process.\r\n\t\t  This has no effect on Windows (will behave like `Fs.constants.F_OK`).\r\n\r\n\t\tThe final argument, `callback`, is a callback function that is invoked with a possible error argument.\r\n\t\tIf any of the accessibility checks fail, the error argument will be populated.\r\n\t**/\r\n\t@:overload(function(path:FsPath, callback:Error->Void):Void {})\r\n\tstatic function access(path:FsPath, mode:Int, callback:Error->Void):Void;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile is visible to the calling process.\r\n\t\tThis is useful for determining if a file exists, but says nothing about rwx permissions.\r\n\t**/\r\n\tstatic var F_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile can be read by the calling process.\r\n\t**/\r\n\tstatic var R_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile can be written by the calling process.\r\n\t**/\r\n\tstatic var W_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tA mode flag for `access` and `accessSync` methods:\r\n\r\n\t\tFile can be executed by the calling process.\r\n\t\tThis has no effect on Windows.\r\n\t**/\r\n\tstatic var X_OK(default, null):Int;\r\n\r\n\t/**\r\n\t\tSynchronous version of `access`.\r\n\t\tThis throws if any accessibility checks fail, and does nothing otherwise.\r\n\t**/\r\n\tstatic function accessSync(path:FsPath, ?mode:Int):Void;\r\n\r\n\t/**\r\n\t\tReturns a new ReadStream object (See Readable Stream).\r\n\r\n\t\t`options` can include `start` and `end` values to read a range of bytes from the file instead of the entire file.\r\n\t\tBoth `start` and `end` are inclusive and start at 0.\r\n\r\n\t\tThe encoding can be 'utf8', 'ascii', or 'base64'.\r\n\r\n\t\tIf `autoClose` is `false`, then the file descriptor won't be closed, even if there's an error.\r\n\t\tIt is your responsiblity to close it and make sure there's no file descriptor leak.\r\n\t\tIf `autoClose` is set to true (default behavior), on error or end the file descriptor will be closed automatically.\r\n\t**/\r\n\tstatic function createReadStream(path:FsPath, ?options:EitherType<String, FsCreateReadStreamOptions>):ReadStream;\r\n\r\n\t/**\r\n\t\tReturns a new WriteStream object (See Writable Stream).\r\n\r\n\t\t`options` may also include a `start` option to allow writing data at some position past the beginning of the file.\r\n\r\n\t\tModifying a file rather than replacing it may require a flags mode of r+ rather than the default mode w.\r\n\t**/\r\n\tstatic function createWriteStream(path:FsPath, ?options:FsCreateWriteStreamOptions):WriteStream;\r\n}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node;\r\n\r\nimport haxe.DynamicAccess;\r\nimport haxe.extern.EitherType;\r\nimport js.node.child_process.ChildProcess as ChildProcessObject;\r\n#if haxe4\r\nimport js.lib.Error;\r\n#else\r\nimport js.Error;\r\n#end\r\n\r\n/**\r\n\tCommon options for all `ChildProcess` methods.\r\n**/\r\nprivate typedef ChildProcessCommonOptions = {\r\n\t/**\r\n\t\tCurrent working directory of the child process.\r\n\t**/\r\n\t@:optional var cwd:String;\r\n\r\n\t/**\r\n\t\tEnvironment key-value pairs\r\n\t**/\r\n\t@:optional var env:DynamicAccess<String>;\r\n\r\n\t/**\r\n\t\tSets the user identity of the process. See setuid(2).\r\n\t**/\r\n\t@:optional var uid:Int;\r\n\r\n\t/**\r\n\t\tSets the group identity of the process. See setgid(2).\r\n\t**/\r\n\t@:optional var gid:Int;\r\n\r\n\t/**\r\n\t\tShell to execute the command with.\r\n\t\tDefault: '/bin/sh' on UNIX, 'cmd.exe' on Windows.\r\n\r\n\t\tThe shell should understand the -c switch on UNIX or /s /c on Windows.\r\n\t\tOn Windows, command line parsing should be compatible with cmd.exe.\r\n\t**/\r\n\t@:optional var shell:EitherType<Bool, String>;\r\n}\r\n\r\n/**\r\n\tCommon options for `spawn` and `spawnSync` methods.\r\n**/\r\nprivate typedef ChildProcessSpawnOptionsBase = {\r\n\t> ChildProcessCommonOptions,\r\n\r\n\t/**\r\n\t\tChild's stdio configuration.\r\n\t**/\r\n\t@:optional var stdio:ChildProcessSpawnOptionsStdio;\r\n}\r\n\r\n/**\r\n\tOptions for the `spawn` method.\r\n**/\r\ntypedef ChildProcessSpawnOptions = {\r\n\t> ChildProcessSpawnOptionsBase,\r\n\r\n\t/**\r\n\t\tThe child will be a process group leader.\r\n\t**/\r\n\t@:optional var detached:Bool;\r\n}\r\n\r\n/**\r\n\tOptions for the `spawnSync` method.\r\n**/\r\ntypedef ChildProcessSpawnSyncOptions = {\r\n\t> ChildProcessSpawnOptionsBase,\r\n\t> ChildProcessExecOptionsBase,\r\n\r\n\t@:optional var input:EitherType<String, Buffer>;\r\n}\r\n\r\n/**\r\n\tThe `stdio` option is an array where each index corresponds to a fd in the child.\r\n\tThe value is one of the following:\r\n\r\n\t\t* 'pipe' - Create a pipe between the child process and the parent process.\r\n\t\t\t\t   The parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].\r\n\t\t\t\t   Pipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.\r\n\r\n\t\t* 'ipc' - Create an IPC channel for passing messages/file descriptors between parent and child.\r\n\t\t\t\t  A ChildProcess may have at most one IPC stdio file descriptor. Setting this option enables the ChildProcess.send() method.\r\n\t\t\t\t  If the child writes JSON messages to this file descriptor, then this will trigger ChildProcess.on('message').\r\n\t\t\t\t  If the child is a Node.js program, then the presence of an IPC channel will enable process.send() and process.on('message').\r\n\r\n\t\t* 'ignore' - Do not set this file descriptor in the child. Note that Node will always open fd 0 - 2 for the processes it spawns.\r\n\t\t\t\t\t When any of these is ignored node will open /dev/null and attach it to the child's fd.\r\n\r\n\t\t* Stream object - Share a readable or writable stream that refers to a tty, file, socket, or a pipe with the child process.\r\n\t\t\t\t\t\t  The stream's underlying file descriptor is duplicated in the child process to the fd that corresponds to the index\r\n\t\t\t\t\t\t  in the stdio array. Note that the stream must have an underlying descriptor (file streams do not until the 'open'\r\n\t\t\t\t\t\t  event has occurred).\r\n\r\n\t\t* Positive integer - The integer value is interpreted as a file descriptor that is is currently open in the parent process.\r\n\t\t\t\t\t\t\t It is shared with the child process, similar to how Stream objects can be shared.\r\n\r\n\t\t* null - Use default value. For stdio fds 0, 1 and 2 (in other words, stdin, stdout, and stderr) a pipe is created.\r\n\t\t\t\t For fd 3 and up, the default is 'ignore'.\r\n\r\n\t As a shorthand, the stdio argument may also be one of the following strings, rather than an array:\r\n\t\tignore - ['ignore', 'ignore', 'ignore']\r\n\t\tpipe - ['pipe', 'pipe', 'pipe']\r\n\t\tinherit - [process.stdin, process.stdout, process.stderr] or [0,1,2]\r\n**/\r\ntypedef ChildProcessSpawnOptionsStdio = EitherType<ChildProcessSpawnOptionsStdioSimple, ChildProcessSpawnOptionsStdioFull>;\r\n\r\n/**\r\n\tA shorthand for the `stdio` argument in `ChildProcessSpawnOptions`\r\n**/\r\n@:enum abstract ChildProcessSpawnOptionsStdioSimple(String) from String to String {\r\n\t/**\r\n\t\tEquivalent to ['ignore', 'ignore', 'ignore']\r\n\t**/\r\n\tvar Ignore = \"ignore\";\r\n\r\n\t/**\r\n\t\tEquivalent to ['pipe', 'pipe', 'pipe']\r\n\t**/\r\n\tvar Pipe = \"pipe\";\r\n\r\n\t/**\r\n\t\tEquivalent to [process.stdin, process.stdout, process.stderr] or [0,1,2]\r\n\t**/\r\n\tvar Inherit = \"inherit\";\r\n}\r\n\r\n/**\r\n\tEnumeration of possible `stdio` behaviours.\r\n**/\r\n@:enum abstract ChildProcessSpawnOptionsStdioBehaviour(String) from String to String {\r\n\t/**\r\n\t\tCreate a pipe between the child process and the parent process.\r\n\t\tThe parent end of the pipe is exposed to the parent as a property on the child_process object as ChildProcess.stdio[fd].\r\n\t\tPipes created for fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout and ChildProcess.stderr, respectively.\r\n\t**/\r\n\tvar Pipe = \"pipe\";\r\n\r\n\t/**\r\n\t\tCreate an IPC channel for passing messages/file descriptors between parent and child.\r\n\t\tA ChildProcess may have at most one IPC stdio file descriptor.\r\n\r\n\t\tSetting this option enables the ChildProcess.send() method.\r\n\r\n\t\tIf the child writes JSON messages to this file descriptor, then this will trigger\r\n\t\tChildProcess.on('message').\r\n\r\n\t\tIf the child is a Node.js program, then the presence of an IPC channel will\r\n\t\tenable process.send() and process.on('message').\r\n\t**/\r\n\tvar Ipc = \"ipc\";\r\n\r\n\t/**\r\n\t\tDo not set this file descriptor in the child.\r\n\t\tNote that Node will always open fd 0 - 2 for the processes it spawns.\r\n\t\tWhen any of these is ignored node will open /dev/null and attach it to the child's fd.\r\n\t**/\r\n\tvar Ignore = \"ignore\";\r\n}\r\n\r\n// see https://github.com/HaxeFoundation/haxe/issues/3499\r\n// typedef ChildProcessSpawnOptionsStdioFull = Array<EitherType<ChildProcessSpawnOptionsStdioBehaviour,EitherType<IStream,Int>>>;\r\ntypedef ChildProcessSpawnOptionsStdioFull = Array<Dynamic>;\r\n\r\n/**\r\n\tCommon options for `exec` and `execFile` methods.\r\n**/\r\nprivate typedef ChildProcessExecOptionsBase = {\r\n\t> ChildProcessCommonOptions,\r\n\r\n\t/**\r\n\t\tDefault: 'utf8'\r\n\t**/\r\n\t@:optional var encoding:String;\r\n\r\n\t/**\r\n\t\tIf greater than 0, then it will kill the child process if it runs longer than timeout milliseconds.\r\n\t**/\r\n\t@:optional var timeout:Int;\r\n\r\n\t/**\r\n\t\tThe child process is killed with `killSignal` (default: 'SIGTERM').\r\n\t**/\r\n\t@:optional var killSignal:String;\r\n\r\n\t/**\r\n\t\tThe largest amount of data allowed on stdout or stderr.\r\n\t\tIf this value is exceeded then the child process is killed.\r\n\t\tDefault: 200*1024\r\n\t**/\r\n\t@:optional var maxBuffer:Int;\r\n}\r\n\r\n/**\r\n\tOptions for the `exec` method.\r\n**/\r\ntypedef ChildProcessExecOptions = {\r\n\t> ChildProcessExecOptionsBase,\r\n}\r\n\r\n/**\r\n\tOptions for the `execFile` method.\r\n**/\r\ntypedef ChildProcessExecFileOptions = {\r\n\t> ChildProcessExecOptionsBase,\r\n}\r\n\r\n/**\r\n\tOptions for the `fork` method.\r\n**/\r\ntypedef ChildProcessForkOptions = {\r\n\t> ChildProcessCommonOptions,\r\n\r\n\t/**\r\n\t\tExecutable used to create the child process\r\n\t**/\r\n\t@:optional var execPath:String;\r\n\r\n\t/**\r\n\t\tList of string arguments passed to the executable (Default: process.execArgv)\r\n\t**/\r\n\t@:optional var execArgv:Array<String>;\r\n\r\n\t/**\r\n\t\tIf `true`, stdin, stdout, and stderr of the child will be piped to the parent,\r\n\t\totherwise they will be inherited from the parent, see the \"pipe\" and \"inherit\"\r\n\t\toptions for `ChildProcessSpawnOptions.stdio` for more details (default is `false`)\r\n\t**/\r\n\t@:optional var silent:Bool;\r\n}\r\n\r\n/**\r\n\tAn error passed to the `ChildProcess.exec` callback.\r\n**/\r\n@:native(\"Error\")\r\nextern class ChildProcessExecError extends Error {\r\n\t/**\r\n\t\tthe exit code of the child proces.\r\n\t**/\r\n\tvar code(default, null):Int;\r\n\r\n\t/**\r\n\t\tthe signal that terminated the process.\r\n\t**/\r\n\tvar signal(default, null):String;\r\n}\r\n\r\n/**\r\n\tA callback type for `ChildProcess.exec`.\r\n\tIt receives three arguments: `error`, `stdout`, `stderr`.\r\n\r\n\tOn success, error will be `null`. On error, `error` will be an instance of `Error`\r\n\tand `error.code` will be the exit code of the child process, and `error.signal` will be set\r\n\tto the signal that terminated the process (see `ChildProcessExecError`).\r\n**/\r\ntypedef ChildProcessExecCallback = #if (haxe_ver >= 4) (error : Null<ChildProcessExecError>, stdout : EitherType<Buffer, String>, stderr : EitherType<Buffer,\r\n\tString>) -> Void; #else Null<ChildProcessExecError>->EitherType<Buffer, String>->EitherType<Buffer, String>->Void; #end\r\n\r\n/**\r\n\tObject returned from the `spawnSync` method.\r\n**/\r\ntypedef ChildProcessSpawnSyncResult = {\r\n\t/**\r\n\t\tPid of the child process\r\n\t**/\r\n\tvar pid:Int;\r\n\r\n\t/**\r\n\t\tArray of results from stdio output\r\n\t**/\r\n\tvar output:Array<EitherType<Buffer, String>>;\r\n\r\n\t/**\r\n\t\tThe contents of output[1]\r\n\t**/\r\n\tvar stdout:EitherType<Buffer, String>;\r\n\r\n\t/**\r\n\t\tThe contents of output[2]\r\n\t**/\r\n\tvar stderr:EitherType<Buffer, String>;\r\n\r\n\t/**\r\n\t\tThe exit code of the child process\r\n\t**/\r\n\tvar status:Int;\r\n\r\n\t/**\r\n\t\tThe signal used to kill the child process\r\n\t**/\r\n\tvar signal:String;\r\n\r\n\t/**\r\n\t\tThe error object if the child process failed or timed out\r\n\t**/\r\n\tvar error:Error;\r\n}\r\n\r\n@:jsRequire(\"child_process\")\r\nextern class ChildProcess {\r\n\t/**\r\n\t\tLaunches a new process with the given `command`, with command line arguments in `args`.\r\n\t\tIf omitted, `args` defaults to an empty `Array`.\r\n\r\n\t\tThe third argument is used to specify additional options, which defaults to:\r\n\t\t\t{ cwd: null,\r\n\t\t\t  env: process.env\r\n\t\t\t}\r\n\r\n\t\tNote that if spawn receives an empty options object, it will result in spawning the process with an empty\r\n\t\tenvironment rather than using `process.env`. This due to backwards compatibility issues with a deprecated API.\r\n\t**/\r\n\t@:overload(function(command:String, ?options:ChildProcessSpawnOptions):ChildProcessObject {})\r\n\t@:overload(function(command:String, args:Array<String>, ?options:ChildProcessSpawnOptions):ChildProcessObject {})\r\n\tstatic function spawn(command:String, ?args:Array<String>):ChildProcessObject;\r\n\r\n\t/**\r\n\t\tRuns a command in a shell and buffers the output.\r\n\r\n\t\t`command` is the command to run, with space-separated arguments.\r\n\r\n\t\tThe default `options` are:\r\n\t\t\t{ encoding: 'utf8',\r\n\t\t\t  timeout: 0,\r\n\t\t\t  maxBuffer: 200*1024,\r\n\t\t\t  killSignal: 'SIGTERM',\r\n\t\t\t  cwd: null,\r\n\t\t\t  env: null }\r\n\t**/\r\n\t@:overload(function(command:String, options:ChildProcessExecOptions, callback:ChildProcessExecCallback):ChildProcessObject {})\r\n\tstatic function exec(command:String, callback:ChildProcessExecCallback):ChildProcessObject;\r\n\r\n\t/**\r\n\t\tThis is similar to `exec` except it does not execute a subshell but rather the specified file directly.\r\n\t\tThis makes it slightly leaner than `exec`\r\n\t**/\r\n\t@:overload(function(file:String, args:Array<String>, options:ChildProcessExecFileOptions, ?callback:ChildProcessExecCallback):ChildProcessObject {})\r\n\t@:overload(function(file:String, options:ChildProcessExecFileOptions, ?callback:ChildProcessExecCallback):ChildProcessObject {})\r\n\t@:overload(function(file:String, args:Array<String>, ?callback:ChildProcessExecCallback):ChildProcessObject {})\r\n\tstatic function execFile(file:String, ?callback:ChildProcessExecCallback):ChildProcessObject;\r\n\r\n\t/**\r\n\t\tThis is a special case of the `spawn` functionality for spawning Node processes.\r\n\t\tIn addition to having all the methods in a normal `ChildProcess` instance,\r\n\t\tthe returned object has a communication channel built-in.\r\n\t\tSee `send` for details.\r\n\t**/\r\n\t@:overload(function(modulePath:String, args:Array<String>, options:ChildProcessForkOptions):ChildProcessObject {})\r\n\t@:overload(function(modulePath:String, options:ChildProcessForkOptions):ChildProcessObject {})\r\n\tstatic function fork(modulePath:String, ?args:Array<String>):ChildProcessObject;\r\n\r\n\t/**\r\n\t\tSynchronous version of `spawn`.\r\n\r\n\t\t`spawnSync` will not return until the child process has fully closed.\r\n\t\tWhen a timeout has been encountered and `killSignal` is sent, the method won't return until the process\r\n\t\thas completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,\r\n\t\tyour process will wait until the child process has exited.\r\n\t**/\r\n\t@:overload(function(command:String, args:Array<String>, ?options:ChildProcessSpawnSyncOptions):ChildProcessSpawnSyncResult {})\r\n\tstatic function spawnSync(command:String, ?options:ChildProcessSpawnSyncOptions):ChildProcessSpawnSyncResult;\r\n\r\n\t/**\r\n\t\tSynchronous version of `execFile`.\r\n\r\n\t\t`execFileSync` will not return until the child process has fully closed.\r\n\t\tWhen a timeout has been encountered and `killSignal` is sent, the method won't return until the process\r\n\t\thas completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,\r\n\t\tyour process will wait until the child process has exited.\r\n\r\n\t\tIf the process times out, or has a non-zero exit code, this method will throw.\r\n\t\tThe Error object will contain the entire result from `spawnSync`\r\n\t**/\r\n\t@:overload(function(command:String, ?options:ChildProcessSpawnSyncOptions):EitherType<String, Buffer> {})\r\n\t@:overload(function(command:String, args:Array<String>, ?options:ChildProcessSpawnSyncOptions):EitherType<String, Buffer> {})\r\n\tstatic function execFileSync(command:String, ?args:Array<String>):EitherType<String, Buffer>;\r\n\r\n\t/**\r\n\t\tSynchronous version of `exec`.\r\n\r\n\t\t`execSync` will not return until the child process has fully closed.\r\n\t\tWhen a timeout has been encountered and `killSignal` is sent, the method won't return until the process\r\n\t\thas completely exited. That is to say, if the process handles the SIGTERM signal and doesn't exit,\r\n\t\tyour process will wait until the child process has exited.\r\n\r\n\t\tIf the process times out, or has a non-zero exit code, this method will throw.\r\n\t\tThe Error object will contain the entire result from `spawnSync`\r\n\t**/\r\n\tstatic function execSync(command:String, ?options:ChildProcessSpawnSyncOptions):EitherType<String, Buffer>;\r\n}\r\n","/*\r\n * Copyright (C)2014-2020 Haxe Foundation\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\npackage js.node.buffer;\r\n\r\nimport haxe.io.Bytes;\r\nimport haxe.io.UInt8Array;\r\n#if haxe4\r\nimport js.lib.ArrayBuffer;\r\nimport js.lib.ArrayBufferView;\r\nimport js.lib.Object;\r\nimport js.lib.Uint8Array;\r\n#else\r\nimport js.html.ArrayBuffer;\r\nimport js.html.ArrayBufferView;\r\nimport js.html.Uint8Array;\r\n#end\r\n\r\n/**\r\n\tThe `Buffer` class is a global type for dealing with binary data directly. It can be constructed in a variety of ways.\r\n\r\n\t@see https://nodejs.org/api/buffer.html#buffer_class_buffer\r\n**/\r\n@:jsRequire(\"buffer\", \"Buffer\")\r\nextern class Buffer extends Uint8Array {\r\n\t/**\r\n\t\tAllocates a new buffer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_array\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_arraybuffer_byteoffset_length\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_buffer\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_size\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding\r\n\t**/\r\n\t@:deprecated\r\n\t@:overload(function(array:Array<Int>):Void {})\r\n\t@:overload(function(arrayBuffer:ArrayBuffer, ?byteOffset:Int, ?length:Int):Void {})\r\n\t@:overload(function(buffer:UInt8Array):Void {})\r\n\t@:overload(function(size:Int):Void {})\r\n\tfunction new(string:String, ?encoding:String):Void;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the `Buffer` will be zero-filled.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding\r\n\t**/\r\n\t@:overload(function(size:Int, fill:String, ?encoding:String):Buffer {})\r\n\t@:overload(function(size:Int, fill:Uint8Array):Buffer {})\r\n\t@:overload(function(size:Int, fill:Int):Buffer {})\r\n\tstatic function alloc(size:Int):Buffer;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer` of `size` bytes. If `size` is larger than\r\n\t\t`buffer.constants.MAX_LENGTH` or smaller than 0, `ERR_INVALID_OPT_VALUE`\r\n\t\tis thrown. A zero-length `Buffer` is created if `size` is 0.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafe_size\r\n\t**/\r\n\tstatic function allocUnsafe(size:Int):Buffer;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer` of `size` bytes. If `size` is larger than\r\n\t\t`buffer.constants.MAX_LENGTH` or smaller than 0, `ERR_INVALID_OPT_VALUE`\r\n\t\tis thrown. A zero-length `Buffer` is created if `size` is 0.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_allocunsafeslow_size\r\n\t**/\r\n\tstatic function allocUnsafeSlow(size:Int):Buffer;\r\n\r\n\t/**\r\n\t\tReturns the actual byte length of a string. This is not the same as\r\n\t\t`String.prototype.length` since that returns the number of characters in\r\n\t\ta string.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_bytelength_string_encoding\r\n\t**/\r\n\t#if (haxe_ver >= 3.3)\r\n\t// it need extern SharedArrayBuffer for Node\r\n\t// @:overload(function(string:SharedArrayBuffer):Int {})\r\n\t@:overload(function(string:String, ?encoding:String):Int {})\r\n\t@:overload(function(string:ArrayBufferView):Int {})\r\n\t@:overload(function(string:ArrayBuffer):Int {})\r\n\tstatic function byteLength(string:Buffer):Int;\r\n\t#end\r\n\r\n\t#if (haxe_ver >= 3.3)\r\n\t@:deprecated(\"In haxe 3.3+, use Buffer.byteLength instead!\")\r\n\t#end\r\n\tinline static function _byteLength(string:String, ?encoding:String):Int\r\n\t\treturn untyped Buffer['byteLength'](string, encoding);\r\n\r\n\t/**\r\n\t\tCompares `buf1` to `buf2` typically for the purpose of sorting arrays of\r\n\t\t`Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_compare_buf1_buf2\r\n\t**/\r\n\t@:native(\"compare\")\r\n\tstatic function compareBuffers(buf1:Uint8Array, buf2:Uint8Array):Int;\r\n\r\n\t/**\r\n\t\tReturns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_concat_list_totallength\r\n\t**/\r\n\tstatic function concat<T:Uint8Array>(list:Array<T>, ?totalLength:Int):Buffer;\r\n\r\n\t/**\r\n\t\tAllocates a new `Buffer`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_array\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_buffer\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_object_offsetorencoding_length\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_from_string_encoding\r\n\t**/\r\n\t// it need extern SharedArrayBuffer for node\r\n\t// @:overload(function(arrayBuffer:SharedArrayBuffer, ?byteOffset:Int, ?length:Int):Buffer {})\r\n\t@:overload(function(array:Array<Int>):Buffer {})\r\n\t@:overload(function(arrayBuffer:ArrayBuffer, ?byteOffset:Int, ?length:Int):Buffer {})\r\n\t@:overload(function(buffer:Uint8Array):Buffer {})\r\n\t@:overload(function(object:{}, ?offset:Int, ?length:Int):Buffer {})\r\n\t@:overload(function(object:{}, ?encoding:String, ?length:Int):Buffer {})\r\n\tstatic function from(string:String, ?encoding:String):Buffer;\r\n\r\n\t/**\r\n\t\tReturns `true` if `obj` is a `Buffer`, `false` otherwise.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_isbuffer_obj\r\n\t**/\r\n\tstatic function isBuffer(obj:Dynamic):Bool;\r\n\r\n\t/**\r\n\t\tReturns `true` if `encoding` contains a supported character encoding, or `false` otherwise.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_method_buffer_isencoding_encoding\r\n\t**/\r\n\tstatic function isEncoding(encoding:String):Bool;\r\n\r\n\t/**\r\n\t\tThis is the size (in bytes) of pre-allocated internal `Buffer` instances used for pooling. This value may be modified.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_class_property_buffer_poolsize\r\n\t**/\r\n\tstatic var poolSize:Int;\r\n\r\n\t// buf[index]\r\n\t// var buffer:ArrayBuffer;\r\n\r\n\t/**\r\n\t\tWhen setting `byteOffset` in `Buffer.from(ArrayBuffer, byteOffset, length)`\r\n\t\tor sometimes when allocating a buffer smaller than `Buffer.poolSize` the\r\n\t\tbuffer doesn't start from a zero offset on the underlying `ArrayBuffer`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_byteoffset\r\n\t**/\r\n\tstatic var byteOffset(default, null):Int;\r\n\r\n\t/**\r\n\t\tCompares `buf` with `target` and returns a number indicating whether `buf` comes before, after,\r\n\t\tor is the same as `target` in sort order. Comparison is based on the actual sequence of bytes in each `Buffer`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend\r\n\t**/\r\n\t@:overload(function(target:Uint8Array):Int {})\r\n\tfunction compare(target:Uint8Array, ?targetStart:Int, ?targetEnd:Int, ?sourceStart:Int, ?sourceEnd:Int):Int;\r\n\r\n\t/**\r\n\t\tCopies data from a region of `buf` to a region in `target` even if the `target` memory region overlaps with `buf`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_copy_target_targetstart_sourcestart_sourceend\r\n\t**/\r\n\t@:overload(function(target:Uint8Array):Void {})\r\n\tfunction copy(target:Uint8Array, ?targetStart:Int, ?sourceStart:Int, ?sourceEnd:Int):Void;\r\n\r\n\t/**\r\n\t\tCreates and returns an iterator of `[index, byte]` pairs from the contents of `buf`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_entries\r\n\t**/\r\n\tfunction entries():js.node.Iterator<js.node.KeyValue<Int, Int>>;\r\n\r\n\t/**\r\n\t\tReturns `true` if both `buf` and `otherBuffer` have exactly the same bytes, `false` otherwise.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_equals_otherbuffer\r\n\t**/\r\n\tfunction equals(otherBuffer:Uint8Array):Bool;\r\n\r\n\t/**\r\n\t\tFills `buf` with the specified `value`. If the `offset` and `end` are not given, the entire `buf` will be filled:\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_fill_value_offset_end_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?offset:Int, ?end:Int):Buffer {})\r\n\t@:overload(function(value:Int, ?offset:Int, ?end:Int):Buffer {})\r\n\tfunction fill(value:String, ?offset:Int, ?end:Int, ?encoding:String):Buffer;\r\n\r\n\t/**\r\n\t\tEquivalent to `buf.indexOf() !== -1`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_includes_value_byteoffset_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?byteOffset:Int):Bool {})\r\n\t@:overload(function(value:Int, ?byteOffset:Int):Bool {})\r\n\tfunction includes(value:String, ?byteOffset:Int, ?encoding:String):Bool;\r\n\r\n\t/**\r\n\t\tIf `value` is:\r\n\r\n\t\t- a string, `value` is interpreted according to the character encoding in `encoding`.\r\n\t\t- a `Buffer` or Uint8Array, `value` will be used in its entirety. To compare a partial `Buffer`, use buf.slice().\r\n\t\t- a number, `value` will be interpreted as an unsigned 8-bit integer value between `0` and `255`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_indexof_value_byteoffset_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?byteOffset:Int):Int {})\r\n\t@:overload(function(value:Int, ?byteOffset:Int):Int {})\r\n\tfunction indexOf(value:String, ?byteOffset:Int, ?encoding:String):Int;\r\n\r\n\t/**\r\n\t\tCreates and returns an iterator of `buf` keys (indices).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_keys\r\n\t**/\r\n\tfunction keys():js.node.Iterator<Int>;\r\n\r\n\t/**\r\n\t\tIdentical to `buf.indexOf()`, except the last occurrence of `value` is found\r\n\t\trather than the first occurrence.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_lastindexof_value_byteoffset_encoding\r\n\t**/\r\n\t@:overload(function(value:Uint8Array, ?byteOffset:Int):Int {})\r\n\t@:overload(function(value:Int, ?byteOffset:Int):Int {})\r\n\tfunction lastIndexOf(value:String, ?byteOffset:Int, ?encoding:String):Int;\r\n\r\n\t// var length(default, null):Int;\r\n\t// these functions need BigInt implementation.\r\n\t// /**\r\n\t// \tReads a signed 64-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t// \t(`readBigInt64BE()` returns big endian, `readBigInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbigint64be_offset\r\n\t// **/\r\n\t// function readBigInt64BE(?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tReads a signed 64-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t// \t(`readBigInt64BE()` returns big endian, `readBigInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbigint64le_offset\r\n\t// **/\r\n\t// function readBigInt64LE(?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tReads an unsigned 64-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t// \t(`readBigUInt64BE()` returns big endian, `readBigUInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbiguint64be_offset\r\n\t// **/\r\n\t// function readBigUInt64BE(?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tReads an unsigned 64-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t// \t(`readBigUInt64BE()` returns big endian, `readBigUInt64LE()` returns little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_readbiguint64le_offset\r\n\t// **/\r\n\t// function readBigUInt64LE(?offset:Int):BigInt;\r\n\r\n\t/**\r\n\t\tReads a 64-bit double from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readDoubleBE()` returns big endian, `readDoubleLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readdoublebe_offset\r\n\t**/\r\n\tfunction readDoubleBE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a 64-bit double from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readDoubleBE()` returns big endian, `readDoubleLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readdoublele_offset\r\n\t**/\r\n\tfunction readDoubleLE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a 32-bit float from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readFloatBE()` returns big endian, `readFloatLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readfloatbe_offset\r\n\t**/\r\n\tfunction readFloatBE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a 32-bit float from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readFloatBE()` returns big endian, `readFloatLE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readfloatle_offset\r\n\t**/\r\n\tfunction readFloatLE(?offset:Int):Float;\r\n\r\n\t/**\r\n\t\tReads a signed 8-bit integer from `buf` at the specified `offset`.\r\n\r\n\t\thttps://nodejs.org/api/buffer.html#buffer_buf_readint8_offset\r\n\t**/\r\n\tfunction readInt8(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 16-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t\t(`readInt16BE()` returns big endian, `readInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint16be_offset\r\n\t**/\r\n\tfunction readInt16BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 16-bit integer from `buf` at the specified `offset` with the specified endian format\r\n\t\t(`readInt16BE()` returns big endian, `readInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint16le_offset\r\n\t**/\r\n\tfunction readInt16LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 32-bit integer from buf at the specified offset with the specified endian format\r\n\t\t(`readInt32BE()` returns big endian, `readInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint32be_offset\r\n\t**/\r\n\tfunction readInt32BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads a signed 32-bit integer from buf at the specified offset with the specified endian format\r\n\t\t(`readInt32BE()` returns big endian, `readInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readint32be_offset\r\n\t**/\r\n\tfunction readInt32LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result\r\n\t\tas a two's complement signed value. Supports up to 48 bits of accuracy.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readintbe_offset_bytelength\r\n\t**/\r\n\tfunction readIntBE(offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tReads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result\r\n\t\tas a two's complement signed value. Supports up to 48 bits of accuracy.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readintle_offset_bytelength\r\n\t**/\r\n\tfunction readIntLE(offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 8-bit integer from `buf` at the specified `offset`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint8_offset\r\n\t**/\r\n\tfunction readUInt8(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 16-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t`readUInt16BE()` returns big endian, `readUInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint16be_offset\r\n\t**/\r\n\tfunction readUInt16BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 16-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readUInt16BE()` returns big endian, `readUInt16LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint16le_offset\r\n\t**/\r\n\tfunction readUInt16LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 32-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readUInt32BE()` returns big endian, `readUInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint32be_offset\r\n\t**/\r\n\tfunction readUInt32BE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReads an unsigned 32-bit integer from `buf` at the specified `offset` with specified endian format\r\n\t\t(`readUInt32BE()` returns big endian, `readUInt32LE()` returns little endian).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_readuint32be_offset\r\n\t**/\r\n\tfunction readUInt32LE(?offset:Int):Int;\r\n\r\n\t/**\r\n\t\tReturns a new `Buffer` that references the same memory as the original,\r\n\t\tbut offset and cropped by the `start` and `end` indices.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_subarray_start_end\r\n\t**/\r\n\t#if haxe4\r\n\tfunction subarray(?start:Int, ?end:Int):Buffer;\r\n\t#else\r\n\toverride function subarray(start:Int, ?end:Int):Buffer;\r\n\t#end\r\n\r\n\t/**\r\n\t\tReturns a new `Buffer` that references the same memory as the original,\r\n\t\tbut offset and cropped by the `start` and `end` indices.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_slice_start_end\r\n\t**/\r\n\tfunction slice(?start:Int, ?end:Int):Buffer;\r\n\r\n\t/**\r\n\t\tInterprets `buf` as an array of unsigned 16-bit integers and swaps the\r\n\t\tbyte order in-place. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length`\r\n\t\tis not a multiple of 2.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_swap16\r\n\t**/\r\n\tfunction swap16():Buffer;\r\n\r\n\t/**\r\n\t\tInterprets `buf` as an array of unsigned 32-bit integers and swaps the\r\n\t\tbyte order in-place. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length`\r\n\t\tis not a multiple of 4.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_swap32\r\n\t**/\r\n\tfunction swap32():Buffer;\r\n\r\n\t/**\r\n\t\tInterprets `buf` as an array of 64-bit numbers and swaps byte order in-place.\r\n\t\tThrows `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_swap64\r\n\t**/\r\n\tfunction swap64():Buffer;\r\n\r\n\t/**\r\n\t\tReturns a JSON representation of `buf`. `JSON.stringify()` implicitly calls\r\n\t\tthis function when stringifying a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_tojson\r\n\t**/\r\n\tfunction toJSON():Dynamic;\r\n\r\n\t/**\r\n\t\tDecodes `buf` to a string according to the specified character encoding in `encoding`.\r\n\t\t`start` and `end` may be passed to decode only a subset of `buf`.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end\r\n\t**/\r\n\t@:overload(function(?encoding:String, ?start:Int, ?end:Int):String {})\r\n\tfunction toString():String;\r\n\r\n\t/**\r\n\t\tCreates and returns an iterator for `buf` values (bytes). This function is called automatically\r\n\t\twhen a `Buffer` is used in a `for..of` statement.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_values\r\n\t**/\r\n\tfunction values():js.node.Iterator<Int>;\r\n\r\n\t/**\r\n\t\tWrites `string` to `buf` at `offset` according to the character encoding in `encoding`.\r\n\t\tThe `length` parameter is the number of bytes to write.\r\n\t\tIf `buf` did not contain enough space to fit the entire `string`, only part of string will be written.\r\n\t\tHowever, partially encoded characters will not be written.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_write_string_offset_length_encoding\r\n\t**/\r\n\tfunction write(string:String, ?offset:Int, ?length:Int, ?encoding:String):Int;\r\n\r\n\t// these functions need BigInt Implementation.\r\n\t// /**\r\n\t// \tWrites `value` to `buf` at the specified `offset` with specified endian format (`writeBigInt64BE()` writes big endian, `writeBigInt64LE()` writes little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_writebigint64be_value_offset\r\n\t// **/\r\n\t// function writeBigInt64BE(value:Int, ?offset:Int):BigInt;\r\n\t// /**\r\n\t// \tWrites `value` to `buf` at the specified `offset` with specified endian format (`writeBigInt64BE()` writes big endian, `writeBigInt64LE()` writes little endian).\r\n\t// \t@see https://nodejs.org/api/buffer.html#buffer_buf_writebigint64le_value_offset\r\n\t// **/\r\n\t// function writeBigInt64LE(value:Int, ?offset:Int):BigInt;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little endian).\r\n\t\t`value` should be a valid 64-bit double. Behavior is undefined when `value` is anything other than a 64-bit double.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writedoublebe_value_offset\r\n\t**/\r\n\tfunction writeDoubleBE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little endian).\r\n\t\t`value` should be a valid 64-bit double. Behavior is undefined when `value` is anything other than a 64-bit double.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writedoublele_value_offset\r\n\t**/\r\n\tfunction writeDoubleLE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeFloatBE()` writes big endian, `writeFloatLE()` writes little endian).\r\n\t\t`value` should be a valid 32-bit float. Behavior is undefined when `value` is anything other than a 32-bit float.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writefloatbe_value_offset\r\n\t**/\r\n\tfunction writeFloatBE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeFloatBE()` writes big endian, `writeFloatLE()` writes little endian).\r\n\t\t`value` should be a valid 32-bit float. Behavior is undefined when `value` is anything other than a 32-bit float.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writefloatle_value_offset\r\n\t**/\r\n\tfunction writeFloatLE(value:Float, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset`. `value` should be a valid signed 8-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than a signed 8-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint8_value_offset\r\n\t**/\r\n\tfunction writeInt8(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt16BE()` writes big endian, `writeInt16LE()` writes little endian).\r\n\t\t`value` should be a valid signed 16-bit integer.\r\n\t\tBehavior is undefined when value is anything other than a signed 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint16be_value_offset\r\n\t**/\r\n\tfunction writeInt16BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt16BE()` writes big endian, `writeInt16LE()` writes little endian).\r\n\t\t`value` should be a valid signed 16-bit integer.\r\n\t\tBehavior is undefined when value is anything other than a signed 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint16le_value_offset\r\n\t**/\r\n\tfunction writeInt16LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt32BE()` writes big endian, `writeInt32LE()` writes little endian).\r\n\t\t`value` should be a valid signed 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than a signed 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint32be_value_offset\r\n\t**/\r\n\tfunction writeInt32BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeInt32BE()` writes big endian, `writeInt32LE()` writes little endian).\r\n\t\t`value` should be a valid signed 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than a signed 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeint32le_value_offset\r\n\t**/\r\n\tfunction writeInt32LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `byteLength` bytes of `value` to `buf` at the specified `offset`.\r\n\t\tSupports up to 48 bits of accuracy. Behavior is undefined when `value` is anything other than a signed integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeintbe_value_offset_bytelength\r\n\t**/\r\n\tfunction writeIntBE(value:Int, offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tWrites `byteLength` bytes of `value` to `buf` at the specified `offset`.\r\n\t\tSupports up to 48 bits of accuracy. Behavior is undefined when `value` is anything other than a signed integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeintle_value_offset_bytelength\r\n\t**/\r\n\tfunction writeIntLE(value:Int, offset:Int, byteLength:Int):Int;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset`. `value` should be a valid unsigned 8-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 8-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint8_value_offset\r\n\t**/\r\n\tfunction writeUInt8(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 16-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint16be_value_offset\r\n\t**/\r\n\tfunction writeUInt16BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 16-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 16-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint16le_value_offset\r\n\t**/\r\n\tfunction writeUInt16LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint32be_value_offset\r\n\t**/\r\n\tfunction writeUInt32BE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tWrites `value` to `buf` at the specified `offset` with specified endian format\r\n\t\t(`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little endian).\r\n\t\t`value` should be a valid unsigned 32-bit integer.\r\n\t\tBehavior is undefined when `value` is anything other than an unsigned 32-bit integer.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buf_writeuint32le_value_offset\r\n\t**/\r\n\tfunction writeUInt32LE(value:Int, ?offset:Int):Void;\r\n\r\n\t/**\r\n\t\tDefault: `50`\r\n\r\n\t\tReturns the maximum number of bytes that will be returned when `buf.inspect()` is called.\r\n\t\tThis can be overridden by user modules.\r\n\t\tSee `util.inspect()` for more details on `buf.inspect()` behavior.\r\n\r\n\t\tThis is a property on the `buffer` module returned by `require('buffer')`, not on the `Buffer` global or a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_inspect_max_bytes\r\n\t**/\r\n\tstatic var INSPECT_MAX_BYTES(get, set):Int;\r\n\r\n\tprivate static inline function get_INSPECT_MAX_BYTES():Int {\r\n\t\treturn BufferModule.INSPECT_MAX_BYTES;\r\n\t}\r\n\tprivate static inline function set_INSPECT_MAX_BYTES(bytes:Int):Int {\r\n\t\treturn BufferModule.INSPECT_MAX_BYTES = bytes;\r\n\t}\r\n\r\n\t/**\r\n\t\tAn alias for `buffer.constants.MAX_LENGTH`.\r\n\r\n\t\tThis is a property on the `buffer` module returned by `require('buffer')`, not on the `Buffer` global or a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_kmaxlength\r\n\t**/\r\n\tstatic var kMaxLength(get, never):Int;\r\n\r\n\tprivate static inline function get_kMaxLength():Int {\r\n\t\treturn BufferModule.kMaxLength;\r\n\t}\r\n\r\n\t/**\r\n\t\tRe-encodes the given `Buffer` or `Uint8Array` instance from one character encoding to another.\r\n\t\tReturns a new `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_transcode_source_fromenc_toenc\r\n\t**/\r\n\tstatic inline function transcode(source:Uint8Array, fromEnc:String, toEnc:String):Buffer {\r\n\t\treturn BufferModule.transcode(source, fromEnc, toEnc);\r\n\t};\r\n\r\n\t/**\r\n\t\t`buffer.constants` is a property on the `buffer` module returned by `require('buffer')`,\r\n\t\tnot on the `Buffer` global or a `Buffer` instance.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_constants\r\n\t**/\r\n\tstatic var constants(default, never):BufferConstants;\r\n\r\n\tprivate static inline function get_constants():BufferConstants {\r\n\t\treturn BufferModule.constants;\r\n\t}\r\n\r\n\t/**\r\n\t\tCreate `haxe.io.Bytes` object that uses the same underlying data storage as `this` buffer.\r\n\t\tAny modifications done using the returned object will be reflected in the `this` buffer.\r\n\t**/\r\n\tinline function hxToBytes():Bytes {\r\n\t\treturn Helper.bytesOfBuffer(this);\r\n\t}\r\n\r\n\t/**\r\n\t\tCreate `Buffer` object from `haxe.io.Bytes` using the same underlying data storage.\r\n\t\tAny modifications done using the returned object will be reflected in given `haxe.io.Bytes` object.\r\n\t**/\r\n\tstatic inline function hxFromBytes(b:Bytes):Buffer {\r\n\t\tvar data = @:privateAccess b.b;\r\n\t\treturn Buffer.from(data.buffer, data.byteOffset, b.length);\r\n\t}\r\n}\r\n\r\n@:dce\r\nprivate class Helper {\r\n\tpublic static function bytesOfBuffer(b:Buffer):haxe.io.Bytes untyped {\r\n\t\tvar o = Object.create(haxe.io.Bytes.prototype);\r\n\t\t// the following is basically a haxe.io.Bytes constructor,\r\n\t\t// but using given buffer instead of creating new Uint8Array\r\n\t\to.length = b.byteLength;\r\n\t\to.b = b;\r\n\t\tb.bufferValue = b;\r\n\t\tb.hxBytes = o;\r\n\t\tb.bytes = b;\r\n\t\treturn o;\r\n\t}\r\n}\r\n\r\n@:jsRequire(\"buffer\")\r\nprivate extern class BufferModule {\r\n\tstatic var INSPECT_MAX_BYTES:Int;\r\n\tstatic var kMaxLength(default, never):Int;\r\n\tstatic function transcode(source:Uint8Array, fromEnc:String, toEnc:String):Buffer;\r\n\tstatic var constants(default, never):BufferConstants;\r\n}\r\n\r\ntypedef BufferConstants = {\r\n\t/**\r\n\t\tOn 32-bit architectures, this value is `(2^30)-1` (`~1GB`).\r\n\t\tOn 64-bit architectures, this value is `(2^31)-1` (`~2GB`).\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_length\r\n\t**/\r\n\tvar MAX_LENGTH(default, never):Int;\r\n\r\n\t/**\r\n\t\tRepresents the largest `length` that a `string` primitive can have, counted\r\n\t\tin UTF-16 code units.\r\n\r\n\t\t@see https://nodejs.org/api/buffer.html#buffer_buffer_constants_max_string_length\r\n\t**/\r\n\tvar MAX_STRING_LENGTH(default, never):Int;\r\n}\r\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport js.Boot;\nimport js.Syntax;\n\n@:keepInit\n@:coreApi class Std {\n\tpublic static inline function is(v:Dynamic, t:Dynamic):Bool {\n\t\treturn isOfType(v, t);\n\t}\n\n\tpublic static inline function isOfType(v:Dynamic, t:Dynamic):Bool {\n\t\treturn @:privateAccess js.Boot.__instanceof(v, t);\n\t}\n\n\tpublic static inline function downcast<T:{}, S:T>(value:T, c:Class<S>):S@:privateAccess {\n\t\treturn if (js.Boot.__downcastCheck(value, c)) cast value else null;\n\t}\n\n\t@:deprecated('Std.instance() is deprecated. Use Std.downcast() instead.')\n\tpublic static inline function instance<T:{}, S:T>(value:T, c:Class<S>):S {\n\t\treturn downcast(value, c);\n\t}\n\n\t@:pure\n\tpublic static function string(s:Dynamic):String {\n\t\treturn @:privateAccess js.Boot.__string_rec(s, \"\");\n\t}\n\n\tpublic static inline function int(x:Float):Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt(x:String):Null<Int> {\n\t\tif(x != null) {\n\t\t\tfor(i in 0...x.length) {\n\t\t\t\tvar c = StringTools.fastCodeAt(x, i);\n\t\t\t\tif(c <= 8 || (c >= 14 && c != ' '.code && c != '-'.code)) {\n\t\t\t\t\tvar nc = StringTools.fastCodeAt(x, i + 1);\n\t\t\t\t\tvar v = js.Lib.parseInt(x, (nc == \"x\".code || nc == \"X\".code) ? 16 : 10);\n\t\t\t\t\treturn Math.isNaN(v) ? null : cast v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static inline function parseFloat(x:String):Float {\n\t\treturn js.Syntax.code(\"parseFloat({0})\", x);\n\t}\n\n\tpublic static function random(x:Int):Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random() * x);\n\t}\n\n\tstatic function __init__():Void\n\t\tuntyped {\n\t\t\t__feature__(\"js.Boot.getClass\", String.prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"String\"] = String, String));\n\t\t\t__feature__(\"js.Boot.isClass\", String.__name__ = __feature__(\"Type.getClassName\", \"String\", true));\n\t\t\t__feature__(\"Type.resolveClass\", $hxClasses[\"Array\"] = Array);\n\t\t\t__feature__(\"js.Boot.isClass\", Array.__name__ = __feature__(\"Type.getClassName\", \"Array\", true));\n\t\t\t__feature__(\"Date.*\", {\n\t\t\t\t__feature__(\"js.Boot.getClass\",\n\t\t\t\t\tjs.Syntax.code('Date').prototype.__class__ = __feature__(\"Type.resolveClass\", $hxClasses[\"Date\"] = js.Syntax.code('Date'), js.Syntax.code('Date')));\n\t\t\t\t__feature__(\"js.Boot.isClass\", js.Syntax.code('Date').__name__ = \"Date\");\n\t\t\t});\n\t\t\t__feature__(\"Int.*\", js.Syntax.code('var Int = { };'));\n\t\t\t__feature__(\"Dynamic.*\", js.Syntax.code('var Dynamic = { };'));\n\t\t\t__feature__(\"Float.*\", js.Syntax.code('var Float = Number'));\n\t\t\t__feature__(\"Bool.*\", js.Syntax.code('var Bool = Boolean'));\n\t\t\t__feature__(\"Class.*\", js.Syntax.code('var Class = { };'));\n\t\t\t__feature__(\"Enum.*\", js.Syntax.code('var Enum = { };'));\n\t\t\t#if (js_es < 5)\n\t\t\t__feature__(\"Array.map\", if (Array.prototype.map == null) Array.prototype.map = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length)\n\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t__feature__(\"Array.filter\", if (Array.prototype.filter == null) Array.prototype.filter = function(f) {\n\t\t\t\tvar a = [];\n\t\t\t\tfor (i in 0...__this__.length) {\n\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\tif (f(e))\n\t\t\t\t\t\ta.push(e);\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t});\n\t\t\t#end\n\t\t}\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\t@:pure\n\tpublic inline static function hasField(o:Dynamic, field:String):Bool {\n\t\treturn js.lib.Object.prototype.hasOwnProperty.call(o, field);\n\t}\n\n\t@:pure\n\tpublic static function field(o:Dynamic, field:String):Dynamic {\n\t\ttry\n\t\t\treturn o[cast field]\n\t\tcatch (e:Dynamic)\n\t\t\treturn null;\n\t}\n\n\tpublic inline static function setField(o:Dynamic, field:String, value:Dynamic):Void {\n\t\to[cast field] = value;\n\t}\n\n\tpublic static function getProperty(o:Dynamic, field:String):Dynamic\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\treturn if (o == null) __define_feature__(\"Reflect.getProperty\",\n\t\t\t\tnull) else if (o.__properties__ && (tmp = o.__properties__[\"get_\" + field])) o[tmp]() else o[field];\n\t\t}\n\n\tpublic static function setProperty(o:Dynamic, field:String, value:Dynamic):Void\n\t\tuntyped {\n\t\t\tvar tmp;\n\t\t\tif (o.__properties__ && (tmp = o.__properties__[\"set_\" + field]))\n\t\t\t\to[tmp](value)\n\t\t\telse\n\t\t\t\to[field] = __define_feature__(\"Reflect.setProperty\", value);\n\t\t}\n\n\tpublic inline static function callMethod(o:Dynamic, func:haxe.Constraints.Function, args:Array<Dynamic>):Dynamic {\n\t\treturn (cast func : js.lib.Function).apply(o, args);\n\t}\n\n\tpublic static function fields(o:Dynamic):Array<String> {\n\t\tvar a = [];\n\t\tif (o != null)\n\t\t\tuntyped {\n\t\t\t\tvar hasOwnProperty = js.lib.Object.prototype.hasOwnProperty;\n\t\t\t\tjs.Syntax.code(\"for( var f in o ) {\");\n\t\t\t\tif (f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f))\n\t\t\t\t\ta.push(f);\n\t\t\t\tjs.Syntax.code(\"}\");\n\t\t\t}\n\t\treturn a;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isFunction(f:Dynamic):Bool {\n\t\treturn js.Syntax.typeof(f) == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>(a:T, b:T):Int {\n\t\treturn (a == b) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods(f1:Dynamic, f2:Dynamic):Bool {\n\t\tif (f1 == f2)\n\t\t\treturn true;\n\t\tif (!isFunction(f1) || !isFunction(f2))\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\t@:access(js.Boot)\n\tpublic static function isObject(v:Dynamic):Bool {\n\t\tif (v == null)\n\t\t\treturn false;\n\t\tvar t = js.Syntax.typeof(v);\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null))\n\t\t\t|| (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue(v:Dynamic):Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField(o:Dynamic, field:String):Bool {\n\t\tif (!hasField(o, field))\n\t\t\treturn false;\n\t\tjs.Syntax.delete(o, field);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>(o:Null<T>):Null<T> {\n\t\tif (o == null)\n\t\t\treturn null;\n\t\tvar o2:Dynamic = {};\n\t\tfor (f in Reflect.fields(o))\n\t\t\tReflect.setField(o2, f, Reflect.field(o, f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function(f:Array<Dynamic>->Void):Dynamic {})\n\tpublic static function makeVarArgs(f:Array<Dynamic>->Dynamic):Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(js.Syntax.code(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n}\n","import haxe.io.Bytes;\r\nimport haxe.io.Output;\r\nimport haxe.io.Error;\r\nimport haxe.io.Eof;\r\nimport js.node.Buffer;\r\nimport js.node.ChildProcess;\r\nimport js.node.Fs;\r\nimport js.Node.process;\r\n\r\n@:dce\r\n@:coreApi\r\nclass Sys {\r\n\tpublic static inline function print(v:Dynamic):Void {\r\n\t\tprocess.stdout.write(Std.string(v));\r\n\t}\r\n\r\n\tpublic static inline function println(v:Dynamic):Void {\r\n\t\tprocess.stdout.write(Std.string(v));\r\n\t\tprocess.stdout.write(\"\\n\");\r\n\t}\r\n\r\n\tpublic static inline function args():Array<String> {\r\n\t\treturn process.argv.slice(2);\r\n\t}\r\n\r\n\tpublic static inline function getEnv(s:String):String {\r\n\t\treturn process.env[s];\r\n\t}\r\n\r\n\tpublic static inline function putEnv(s:String, v:String):Void {\r\n\t\tprocess.env[s] = v;\r\n\t}\r\n\r\n\tpublic static function environment():Map<String, String> {\r\n\t\tvar m = new Map();\r\n\t\tfor (key in process.env.keys())\r\n\t\t\tm[key] = process.env[key];\r\n\t\treturn m;\r\n\t}\r\n\r\n\tpublic inline static function setTimeLocale(loc:String):Bool {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic inline static function getCwd():String {\r\n\t\treturn process.cwd();\r\n\t}\r\n\r\n\tpublic static inline function setCwd(s:String):Void {\r\n\t\tprocess.chdir(s);\r\n\t}\r\n\r\n\tpublic static function systemName():String {\r\n\t\treturn switch (process.platform) {\r\n\t\t\tcase \"darwin\": \"Mac\";\r\n\t\t\tcase \"freebsd\": \"BSD\";\r\n\t\t\tcase \"linux\": \"Linux\";\r\n\t\t\tcase \"win32\": \"Windows\";\r\n\t\t\tcase other: other; // throw?\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static inline function command(cmd:String, ?args:Array<String>):Int {\r\n\t\tif (args == null)\r\n\t\t\treturn ChildProcess.spawnSync(cmd, {shell: true, stdio: \"inherit\"}).status;\r\n\t\telse\r\n\t\t\treturn ChildProcess.spawnSync(cmd, args, {stdio: \"inherit\"}).status;\r\n\t}\r\n\r\n\tpublic static inline function exit(code:Int):Void {\r\n\t\tprocess.exit(code);\r\n\t}\r\n\r\n\tpublic static inline function time():Float {\r\n\t\treturn (cast Date).now() / 1000;\r\n\t}\r\n\r\n\tpublic static inline function cpuTime():Float {\r\n\t\treturn process.uptime();\r\n\t}\r\n\r\n\t#if (haxe_ver >= 3.3)\r\n\t@:deprecated(\"Use programPath instead\")\r\n\t#end\r\n\tpublic static inline function executablePath():String {\r\n\t\treturn process.argv[0];\r\n\t}\r\n\r\n\t#if (haxe_ver >= 3.3)\r\n\tpublic static inline function programPath():String {\r\n\t\treturn js.Node.__filename;\r\n\t}\r\n\t#end\r\n\r\n\tpublic static function getChar(echo:Bool):Int {\r\n\t\tthrow \"Sys.getChar is currently not implemented on node.js\";\r\n\t}\r\n\r\n\tpublic static function sleep(seconds:Float):Void {\r\n\t\tvar end = (cast Date).now() + seconds * 1000;\r\n\t\twhile ((cast Date).now() <= end) {}\r\n\t}\r\n\r\n\tpublic static inline function stdin():haxe.io.Input {\r\n\t\treturn new FileInput(0);\r\n\t}\r\n\r\n\tpublic static inline function stdout():haxe.io.Output {\r\n\t\treturn new FileOutput(1);\r\n\t}\r\n\r\n\tpublic static inline function stderr():haxe.io.Output {\r\n\t\treturn new FileOutput(2);\r\n\t}\r\n}\r\n\r\nprivate class FileOutput extends haxe.io.Output {\r\n\tvar fd:Int;\r\n\r\n\tpublic function new(fd:Int) {\r\n\t\tthis.fd = fd;\r\n\t}\r\n\r\n\toverride public function writeByte(c:Int) {\r\n\t\tFs.writeSync(fd, String.fromCharCode(c));\r\n\t}\r\n\r\n\toverride public function writeBytes(s:Bytes, pos:Int, len:Int):Int {\r\n\t\treturn Fs.writeSync(fd, Buffer.hxFromBytes(s), pos, len);\r\n\t}\r\n\r\n\toverride public function writeString(s:String #if (haxe_ver >= 4), ?encoding:haxe.io.Encoding #end) {\r\n\t\tFs.writeSync(fd, s);\r\n\t}\r\n\r\n\toverride public function flush() {\r\n\t\tFs.fsyncSync(fd);\r\n\t}\r\n\r\n\toverride public function close() {\r\n\t\tFs.closeSync(fd);\r\n\t}\r\n}\r\n\r\nprivate class FileInput extends haxe.io.Input {\r\n\tvar fd:Int;\r\n\r\n\tpublic function new(fd:Int) {\r\n\t\tthis.fd = fd;\r\n\t}\r\n\r\n\toverride public function readByte():Int {\r\n\t\tvar buf = Buffer.alloc(1);\r\n\t\ttry {\r\n\t\t\tFs.readSync(fd, buf, 0, 1, null);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"EOF\")\r\n\t\t\t\tthrow new Eof();\r\n\t\t\telse\r\n\t\t\t\tthrow Error.Custom(e);\r\n\t\t}\r\n\t\treturn buf[0];\r\n\t}\r\n\r\n\toverride public function readBytes(s:Bytes, pos:Int, len:Int):Int {\r\n\t\tvar buf = Buffer.hxFromBytes(s);\r\n\t\ttry {\r\n\t\t\treturn Fs.readSync(fd, buf, pos, len, null);\r\n\t\t} catch (e:Dynamic) {\r\n\t\t\tif (e.code == \"EOF\")\r\n\t\t\t\tthrow new Eof();\r\n\t\t\telse\r\n\t\t\t\tthrow Error.Custom(e);\r\n\t\t}\r\n\t}\r\n\r\n\toverride public function close():Void {\r\n\t\tFs.closeSync(fd);\r\n\t}\r\n}\r\n"]}